@doc raw"""
    Œ≥‚Çö‚Çô(pnsystem)
    inverse_separation(pnsystem)

Compute the post-Newtonian parameter
```math
\gamma_{\mathrm{PN}} \equiv \frac{G\, M}{r\, c^2},
```
where ``r`` is the magnitude of the orbital separation.  This quantity has PN order 1, and
is given by Eq. (4.3) of [Boh√© et al. (2013)](https://arxiv.org/abs/1212.5520) and Eq.
(3.32) of [Boh√© et al.  (2015)](https://arxiv.org/abs/1501.01529).

Note that there is a 3PN gauge term of ``-22ŒΩ\\ln(r/r‚ÇÄ‚Ä≤)/3`` that is simply ignored here, as
it should cancel out of any physical quantity.
"""
@pn_expression function Œ≥‚Çö‚Çô(pnsystem)
    return (v / c)^2 * @pn_expansion(
        # Non-spinning terms; Eq. (4.3) of Boh√© et al. (2013)
        1 +
            (v / c)^2 * (1 - ŒΩ / 3) +
            (v / c)^4 * (1 - 65ŒΩ / 12) +
            (v / c)^6 * (1 + (-2203//2520 - 41œÄ^2 / 192)ŒΩ + 229ŒΩ^2 / 36 + ŒΩ^3 / 81)

            # Spin-orbit terms; Eq. (4.3) of Boh√© et al. (2013)
            +
            (v / c)^3 * (5//3 * s‚Çó + Œ¥ * œÉ‚Çó) +
            (v / c)^5 * ((10//3 + 8ŒΩ / 9) * s‚Çó + 2Œ¥ * œÉ‚Çó) +
            (v / c)^7 * ((5 - 127ŒΩ / 12 - 6ŒΩ^2) * s‚Çó + Œ¥ * (3 - 61ŒΩ / 6 - 8ŒΩ^2 / 3) * œÉ‚Çó)

            # Spin-squared terms; Eq. (3.32) of Boh√© et al. (2015)
            +
            (v / c)^4 * (
                s‚Çó^2 * (-Œ∫‚Çä / 2 - 1) +
                s‚Çó * œÉ‚Çó * (-Œ¥ * Œ∫‚Çä / 2 - Œ¥ + Œ∫‚Çã / 2) +
                œÉ‚Çó^2 * (Œ¥ * Œ∫‚Çã / 4 - Œ∫‚Çä / 4 + (Œ∫‚Çä / 2 + 1)ŒΩ)
            ) +
            (v / c)^6 * (
                s‚Çó^2 * (-11Œ¥ * Œ∫‚Çã / 12 - 11Œ∫‚Çä / 12 + 14//9 + (-Œ∫‚Çä / 6 - 1//3)ŒΩ) +
                s‚Çó * œÉ‚Çó * (5Œ¥ / 3 + (-Œ¥ * Œ∫‚Çä / 6 - Œ¥ / 3 + 23Œ∫‚Çã / 6)ŒΩ) +
                œÉ‚Çó^2 * (1 + (Œ¥ * Œ∫‚Çã - Œ∫‚Çä - 2)ŒΩ + (Œ∫‚Çä / 6 + 1//3)ŒΩ^2)
            )
    )
end
const inverse_separation = Œ≥‚Çö‚Çô

@doc raw"""
    Œ≥‚Çö‚Çô‚Ä≤(pnsystem)
    inverse_separation_deriv(pnsystem)

Compute the derivative of [`Œ≥‚Çö‚Çô`](@ref) with respect to `v`.

"""
@generated function Œ≥‚Çö‚Çô‚Ä≤(
    pnsystem::PNSystem{ST,PNOrder}; pn_expansion_reducer::Val{PNExpansionReducer}=Val(sum)
) where {ST,PNOrder,PNExpansionReducer}
    # Create a `PNSystem` with `FastDifferentiation` (henceforth FD) variables, using the
    # same PNOrder as the input `pnsystem`.
    fdpnsystem = FDPNSystem(eltype(ST), PNOrder)

    # FD expects a single vector of variables, so we concatenate the state vector with the
    # two tidal-coupling parameters
    vars = FastDifferentiation.Node[fdpnsystem.state; Œõ‚ÇÅ(fdpnsystem); Œõ‚ÇÇ(fdpnsystem)]

    # Now we evaluate Œ≥‚Çö‚Çô using the FD variables.  This will expand all derived variables in
    # terms of the fundamental variables, but FD will take care of evaluating those
    # efficiently via common subexpression elimination (CSE).
    Œ≥‚Çö‚Çôformula = Œ≥‚Çö‚Çô(fdpnsystem; pn_expansion_reducer=Val(PNExpansionReducer))

    # Now we take the derivative of Œ≥‚Çö‚Çô with respect to v.
    Œ≥‚Çö‚Çô‚Ä≤ = SVector(FastDifferentiation.derivative(Œ≥‚Çö‚Çôformula, v(fdpnsystem)))

    # Turn that into an Expr (FD insists on making it a function)
    in_place = true
    init_with_zeros = false
    Œ≥‚Çö‚Çô‚Ä≤expr = FastDifferentiation.make_Expr(Œ≥‚Çö‚Çô‚Ä≤, vars, in_place, init_with_zeros)

    # Now, we use `MacroTools` to get the body of the function.
    Œ≥‚Çö‚Çô‚Ä≤body = MacroTools.unblock(MacroTools.splitdef(Œ≥‚Çö‚Çô‚Ä≤expr)[:body])

    # # At this point, the function is just a long series of statements inside an `@inbounds`
    # # block, which we will want later, but first we need to extract them.
    MacroTools.@capture(Œ≥‚Çö‚Çô‚Ä≤body, @inbounds begin
        Œ≥‚Çö‚Çô‚Ä≤statements__
    end) || throw(
        ArgumentError(
            "\nNo @inbounds block found in Œ≥‚Çö‚Çô‚Ä≤ expression." *
            "\nSomething may have changed in FastDifferentiation." *
            "\nOpen an issue citing this Julia call:" *
            "\n```julia" *
            "\nusing PostNewtonian" *
            "\nŒ≥‚Çö‚Çô‚Ä≤($pnsystem)" *
            "\n```",
        ),
    )

    # The Œ≥‚Çö‚Çô‚Ä≤statements are mostly what we want, except that the last line is a return
    # statement.  We want that result, but we don't to return it yet; we want to wrap that
    # result, so we just get that returned quantity here.
    MacroTools.@capture(Œ≥‚Çö‚Çô‚Ä≤statements[end], return Œ≥‚Çö‚Çô‚Ä≤return_) || throw(
        ArgumentError(
            "\nNo return statement found in Œ≥‚Çö‚Çô‚Ä≤ expression." *
            "\nSomething may have changed in FastDifferentiation." *
            "\nOpen an issue citing this Julia call:" *
            "\n```julia" *
            "\nusing PostNewtonian" *
            "\nŒ≥‚Çö‚Çô‚Ä≤($pnsystem)" *
            "\n```",
        ),
    )
    Œ≥‚Çö‚Çô‚Ä≤statements[end] = Œ≥‚Çö‚Çô‚Ä≤return

    if PNExpansionReducer === identity
        # When `pn_expansion_reducer=Val(identity)` is passed, we return a PNExpansion
        NMax = Int(2PNOrder + 1)
        return quote
            input_variables = SVector(pnsystem)
            result = MVector{$(length(Œ≥‚Çö‚Çô‚Ä≤)),$(eltype(ST))}(undef)
            result .= 0
            @fastmath @inbounds begin
                $(Œ≥‚Çö‚Çô‚Ä≤statements...)
            end
            return PNExpansion{$(length(Œ≥‚Çö‚Çô‚Ä≤)),$(eltype(ST)),$NMax}(Tuple(result))
        end
    else
        # Otherwise, FD produces a 1-tuple, so we just extract the value from that.
        return quote
            input_variables = SVector(pnsystem)
            result = MVector{1,$(eltype(ST))}(undef)
            result .= 0
            @fastmath @inbounds begin
                $(Œ≥‚Çö‚Çô‚Ä≤statements...)
            end
            return result[1]
        end
    end
end
const inverse_separation_deriv = Œ≥‚Çö‚Çô‚Ä≤

"""
    r(pnsystem)
    separation(pnsystem)

Compute the separation between the two black holes.  This is essentially the inverse of
[`Œ≥‚Çö‚Çô`](@ref), with some factors of `G` and `M` thrown in.

Note that there should be a factor of `1/c^2` in this expression; we reserve it to use
explicitly in PN expansions.  That is, for every factor of `1/r`, we explicitly include a
factor of `1/c^2` in the expansion.
"""
@pn_expression function r(pnsystem)
    let Œ≥‚Çö‚Çô = Œ≥‚Çö‚Çô(pnsystem)
        return G * M / (Œ≥‚Çö‚Çô)
    end
end
const separation = r

"""
    r‚Ä≤(pnsystem)
    separation_prime(pnsystem)

Compute the derivative of the separation between the two black holes with respect to `v`.
"""
@pn_expression function r‚Ä≤(pnsystem)
    let Œ≥‚Çö‚Çô = Œ≥‚Çö‚Çô(pnsystem)
        -Œ≥‚Çö‚Çô‚Ä≤ * G * M / (Œ≥‚Çö‚Çô^2 * c^2)
    end
end
const separation_prime = r‚Ä≤

@pn_expression function rÃá(pnsystem)
    let Œ≥‚Çö‚Çô = Œ≥‚Çö‚Çô(pnsystem), Œ≥‚Çö‚Çô‚Ä≤ = Œ≥‚Çö‚Çô‚Ä≤(pnsystem), ùìï = ùìï(pnsystem), ùìî‚Ä≤ = ùìî‚Ä≤(pnsystem)
        ùìï * Œ≥‚Çö‚Çô‚Ä≤ * G * M / (Œ≥‚Çö‚Çô^2 * c^2 * ùìî‚Ä≤)
    end
end
const separation_dot = rÃá

"""
This module contains a few expressions from [Kidder
(1995)](https://arxiv.org/abs/gr-qc/9506022).

This is mostly here for testing, because these expressions are not directly used in this
package: they are somewhat outdated and describe quantities that are not actually used in
this formulation.  However, they were used in the SpEC code as an initial guess for
eccentricity reduction, so we want to make sure that results from this package are
consistent with those from SpEC.

"""
module Kidder1995

using PostNewtonian: @pn_expansion, @pn_expression, M, M‚ÇÅ, M‚ÇÇ, ŒΩ, Œ¥, œá‚ÇÅ‚Çó, œá‚ÇÇ‚Çó, œá‚ÇÅ‚ÇÇ, Œ©

"""
    r(pnsystem)

Eq. (4.13).
"""
@pn_expression function r(pnsystem)
    let m = M, m‚ÇÅ = M‚ÇÅ, m‚ÇÇ = M‚ÇÇ, Œ∑ = ŒΩ, Œ¥m = Œ¥ * M, œá‚ÇÅLÃÇ‚ÇôsÃÇ‚ÇÅ = œá‚ÇÅ‚Çó, œá‚ÇÇLÃÇ‚ÇôsÃÇ‚ÇÇ = œá‚ÇÇ‚Çó, œâ = Œ©
        m *
        (m * œâ)^(-2//3) *
        @pn_expansion(
            1 - 1//3 * (3 - Œ∑) * (m * œâ)^(2//3) / c^2 -
            (
                1//3 *
                ((œá‚ÇÅLÃÇ‚ÇôsÃÇ‚ÇÅ * (2 * m‚ÇÅ^2 / m^2 + 3Œ∑)) + (œá‚ÇÇLÃÇ‚ÇôsÃÇ‚ÇÇ * (2 * m‚ÇÇ^2 / m^2 + 3Œ∑)))
            ) * (m * œâ) / c^3 +
                (Œ∑ * (19//4 + Œ∑ / 9) - 1//2 * Œ∑ * (œá‚ÇÅ‚ÇÇ - 3œá‚ÇÅLÃÇ‚ÇôsÃÇ‚ÇÅ * œá‚ÇÇLÃÇ‚ÇôsÃÇ‚ÇÇ)) *
            (m * œâ)^(4//3) / c^4
        )
    end
end

"""
    drdt(pnsystem)

Eq. (4.12), computed as rÃá = (dE/dt) / (dE/dr), re-expanded and truncated.
"""
@pn_expression function drdt(pnsystem)
    let r = r(pnsystem)
        let m = M, m‚ÇÅ = M‚ÇÅ, m‚ÇÇ = M‚ÇÇ, Œ∑ = ŒΩ, Œ¥m = Œ¥ * M, œá‚ÇÅLÃÇ‚ÇôsÃÇ‚ÇÅ = œá‚ÇÅ‚Çó, œá‚ÇÇLÃÇ‚ÇôsÃÇ‚ÇÇ = œá‚ÇÇ‚Çó
            -64//5 *
            Œ∑ *
            (m / r)^3 *
            @pn_expansion(
                1 - 1//336 * (1751 + 588Œ∑) * (m / r) / c^2 -
                (
                    7//12 * (
                        (œá‚ÇÅLÃÇ‚ÇôsÃÇ‚ÇÅ * (19 * m‚ÇÅ^2 / m^2 + 15Œ∑)) +
                        (œá‚ÇÇLÃÇ‚ÇôsÃÇ‚ÇÇ * (19 * m‚ÇÇ^2 / m^2 + 15Œ∑))
                    ) - 4œÄ
                ) * (m / r)^(3//2) / c^3 -
                    5//48 * Œ∑ * (59œá‚ÇÅ‚ÇÇ - 173œá‚ÇÅLÃÇ‚ÇôsÃÇ‚ÇÅ * œá‚ÇÇLÃÇ‚ÇôsÃÇ‚ÇÇ) * (m / r)^2 / c^4
            )
        end
    end
end

end  # module Kidder1995

@testitem "separation" begin
    using Random
    using PostNewtonian: @pn_expansion, @pn_expression, separation_dot
    using PostNewtonian.Kidder1995: drdt

    rng = Random.Xoshiro(1234)
    for pnsystem ‚àà (rand(rng, BBH) for _ ‚àà 1:1_000)
        # We know that Larry's expression is old and inaccurate.  It may get more so as we
        # include newer PN terms, so this tolerance may need to be adjusted.  This is more
        # of a sanity check.
        @test drdt(pnsystem) ‚âà separation_dot(pnsystem) rtol = 0.03
    end
end
