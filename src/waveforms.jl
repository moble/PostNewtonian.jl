# Helper functions to get the `pnsystem` from either an ODESolution or the result of
# interpolating such a thing
_pnsystem(inspiral::SciMLBase.ODESolution) = inspiral.prob.p
_pnsystem(inspiral::SciMLBase.DiffEqArray) = inspiral.p


"""
    coorbital_waveform_computation_storage(inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])

Construct storage needed to compute waveforms in the co-orbital frame without allocations.

This returns the storage for the waveforms themselves and `PNSystem` used as temporary
storage.  The returned quantity can just be passed as the first argument to
[`coorbital_waveform!`](@ref) without being unpacked.

The meaning of the arguments is the same as in [`coorbital_waveform`](@ref).
"""
function coorbital_waveform_computation_storage(
    inspiral; ‚Ñì‚Çò·µ¢‚Çô=2, ‚Ñì‚Çò‚Çê‚Çì=8, PNOrder=pn_order(_pnsystem(inspiral))
)
    @assert 0 ‚â§ ‚Ñì‚Çò·µ¢‚Çô ‚â§ 2
    @assert ‚Ñì‚Çò·µ¢‚Çô ‚â§ ‚Ñì‚Çò‚Çê‚Çì
    p = _pnsystem(inspiral)
    PNSystemType = SciMLBase.parameterless_type(p)
    pnsystem = PNSystemType(
        copy(inspiral.u[1]);
        Œª‚ÇÅ=Œª‚ÇÅ(p),
        Œª‚ÇÇ=Œª‚ÇÇ(p),
        PNOrder
    )
    n_modes = (‚Ñì‚Çò‚Çê‚Çì+1)^2 - ‚Ñì‚Çò·µ¢‚Çô^2
    h = Array{Complex{eltype(inspiral)}}(undef, n_modes, length(inspiral))
    h, pnsystem
end

"""
    coorbital_waveform!(storage, inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])

Evaluate the post-Newtonian waveform mode weights in the co-orbital frame for the given
`inspiral` output by [`orbital_evolution`](@ref), using pre-allocated storage.

The storage is assumed to be the object returned from
[`coorbital_waveform_computation_storage`](@ref).  Other arguments are the same as in
[`coorbital_waveform`](@ref).
"""
function coorbital_waveform!(
    storage, inspiral; ‚Ñì‚Çò·µ¢‚Çô=2, ‚Ñì‚Çò‚Çê‚Çì=8, PNOrder=pn_order(storage[2])
)
    h, pnsystem = storage
    @assert length(pnsystem.state) == length(inspiral.u[1])
    @assert length(inspiral) == size(h, 2)
    @assert (‚Ñì‚Çò‚Çê‚Çì+1)^2 - ‚Ñì‚Çò·µ¢‚Çô^2 == size(h, 1)
    @inbounds @fastmath for i‚Çú ‚àà eachindex(inspiral)
        pnsystem.state .= inspiral.u[i‚Çú]
        h!(@view(h[:, i‚Çú]), pnsystem; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì)
    end
    h
end

"""
    coorbital_waveform(inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])

Evaluate the post-Newtonian waveform mode weights in the co-orbital frame for the given
`inspiral` output by [`orbital_evolution`](@ref).

The `PNOrder` defaults to the one used to compute `inspiral`, but may be changed by passing
the keyword argument.

See also [`inertial_waveform`](@ref) for the waveform in the inertial frame.

!!! tip
    If you need this waveform at a different set of times `t‚Ä≤` than is currently present in
    `inspiral.t`, you should use the built-in interpolation capabilities of `inspiral`
    *first*, as in `inspiral‚Ä≤ = inspiral(t‚Ä≤)`, rather than interpolating the results of this
    function.  Or, perhaps better yet, you could select the times when calling
    `orbital_evolution` by using the `saveat` or `saves_per_orbit` keyword argument to that
    function.  These approaches will be more accurate, faster, and require less memory than
    interpolating the result of this function.

The mode weights are given starting at `‚Ñì‚Çò·µ¢‚Çô` (which must satisfy `0 ‚â§ ‚Ñì‚Çò·µ¢‚Çô ‚â§ 2`) and
extending through `‚Ñì‚Çò‚Çê‚Çì`.  The waveform is returned as a 2-dimensional `Array`, in which the
first index varies over the mode index from `(‚Ñì, m) = (‚Ñì‚Çò·µ¢‚Çô, -‚Ñì‚Çò·µ¢‚Çô)` to `(‚Ñì, m) = (‚Ñì‚Çò‚Çê‚Çì,
‚Ñì‚Çò‚Çê‚Çì)`, with `m` varying most rapidly, and the second index varying over the time steps.

By default, the waveform is returned in the co-orbital frame ‚Äî which is somewhat like the
co-rotating frame.  In particular, the modes of non-precessing systems vary slowly, over
inspiral timescales; modes of precessing systems still vary on orbital timescales, though
even this variation could be factored out.  If `inertial=true` is passed, the waveform is
instead transformed to the inertial frame, resulting in the oscillatory behavior we usually
expect from a waveform.
"""
function coorbital_waveform(
    inspiral; ‚Ñì‚Çò·µ¢‚Çô=2, ‚Ñì‚Çò‚Çê‚Çì=8, PNOrder=pn_order(_pnsystem(inspiral))
)
    storage = coorbital_waveform_computation_storage(
        inspiral; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, PNOrder
    )
    coorbital_waveform!(
        storage, inspiral; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, PNOrder
    )
end


"""
    inertial_waveform_computation_storage(inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])

Construct storage needed to compute waveforms in the inertial frame without allocations.

This returns the storage for the waveforms themselves, storage used for computing the Wigner
ùîá matrices, and for "in-place" multiplication.  The returned quantity can just be passed as
the first argument to [`inertial_waveform!`](@ref) without being unpacked.

The meaning of the arguments is the same as in [`inertial_waveform`](@ref).
"""
function inertial_waveform_computation_storage(
    inspiral; ‚Ñì‚Çò·µ¢‚Çô=2, ‚Ñì‚Çò‚Çê‚Çì=8, PNOrder=pn_order(_pnsystem(inspiral))
)
    h, pnsystem = coorbital_waveform_computation_storage(inspiral; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, PNOrder)
    (D, H_rec_coeffs, e‚Å±·µê·µÖ, e‚Å±·µê·µû) = Dprep(‚Ñì‚Çò‚Çê‚Çì, eltype(inspiral))
    h·µ¢ = similar(h[:,1])
    h, pnsystem, D, H_rec_coeffs, e‚Å±·µê·µÖ, e‚Å±·µê·µû, h·µ¢
end

"""
    inertial_waveform!(storage, inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])

Evaluate the post-Newtonian waveform mode weights in the inertial frame for the given
`inspiral` output by [`orbital_evolution`](@ref), using pre-allocated storage.

The storage is assumed to be the object returned from
[`inertial_waveform_computation_storage`](@ref).  Other arguments are the same as in
[`inertial_waveform`](@ref).
"""
function inertial_waveform!(
    storage, inspiral; ‚Ñì‚Çò·µ¢‚Çô=2, ‚Ñì‚Çò‚Çê‚Çì=8, PNOrder=pn_order(storage[2])
)
    h, pnsystem, D, H_rec_coeffs, e‚Å±·µê·µÖ, e‚Å±·µê·µû, h·µ¢ = storage
    @assert length(pnsystem.state) == length(inspiral.u[1])
    @assert length(inspiral) == size(h, 2)
    @assert (‚Ñì‚Çò‚Çê‚Çì+1)^2 - ‚Ñì‚Çò·µ¢‚Çô^2 == size(h, 1)
    @inbounds @fastmath for i‚Çú ‚àà eachindex(inspiral)
        pnsystem.state .= inspiral.u[i‚Çú]
        h!(@view(h[:, i‚Çú]), pnsystem; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì)
        D!(D, R(pnsystem), ‚Ñì‚Çò‚Çê‚Çì, H_rec_coeffs, e‚Å±·µê·µÖ, e‚Å±·µê·µû)
        f‚Ä≤ = Yiterator(h·µ¢, ‚Ñì‚Çò‚Çê‚Çì, ‚Ñì‚Çò·µ¢‚Çô, 1)
        f = Yiterator(h[:, i‚Çú], ‚Ñì‚Çò‚Çê‚Çì, ‚Ñì‚Çò·µ¢‚Çô, 1)
        ùîá = Diterator(D, ‚Ñì‚Çò‚Çê‚Çì, ‚Ñì‚Çò·µ¢‚Çô)
        for (f‚Ä≤À°, fÀ°, ùîáÀ°) in zip(f‚Ä≤, f, ùîá)
            mul!(f‚Ä≤À°, ùîáÀ°, fÀ°)
        end
        h[:, i‚Çú] .= h·µ¢
    end
    h
end

"""
    inertial_waveform(inspiral, [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])

Evaluate the post-Newtonian waveform mode weights in the inertial frame for the given
`inspiral` output by [`orbital_evolution`](@ref).

The inertial frame is the one in which inertial observers are found, so this waveform is
more like one that actual observers would detect.  This function transforms the waveform
from the co-orbital frame ‚Äî which is the one in which PN expressions are provided.

See [`coorbital_waveform`](@ref) for details about the other arguments.
"""
function inertial_waveform(
    inspiral; ‚Ñì‚Çò·µ¢‚Çô=2, ‚Ñì‚Çò‚Çê‚Çì=8, PNOrder=pn_order(_pnsystem(inspiral))
)
    storage = inertial_waveform_computation_storage(
        inspiral; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, PNOrder
    )
    inertial_waveform!(
        storage, inspiral; ‚Ñì‚Çò·µ¢‚Çô, ‚Ñì‚Çò‚Çê‚Çì, PNOrder
    )
end
