@testset verbose=true "Orbital evolution" begin
    Random.seed!(1234)
    T = Float64
    M‚ÇÅ = T(5//8)
    M‚ÇÇ = T(3//8)
    œá‚Éó‚ÇÅ = normalize(randn(QuatVec{T})) * rand(T(0):T(1//1_000_000):T(1))
    œá‚Éó‚ÇÇ = normalize(randn(QuatVec{T})) * rand(T(0):T(1//1_000_000):T(1))
    Œ©·µ¢ = T(1//64)
    Œ©‚ÇÅ = Œ©·µ¢/2
    Œ©‚Çë = 1
    R·µ¢ = exp(normalize(randn(QuatVec{T})) * rand(T(0):T(1//1_000_000):T(1//1_000)))

    M‚Çú‚Çí‚Çú = M‚ÇÅ+M‚ÇÇ
    q = M‚ÇÅ/M‚ÇÇ
    v·µ¢ = PostNewtonian.v(Œ©=Œ©·µ¢,M=M‚ÇÅ+M‚ÇÇ)
    v‚ÇÅ = PostNewtonian.v(Œ©=Œ©‚ÇÅ,M=M‚ÇÅ+M‚ÇÇ)
    v‚Çë = min(PostNewtonian.v(Œ©=Œ©‚Çë, M=M‚ÇÅ+M‚ÇÇ), 1)

    u·µ¢ = [M‚ÇÅ; M‚ÇÇ; vec(œá‚Éó‚ÇÅ); vec(œá‚Éó‚ÇÇ); components(R·µ¢); v·µ¢; zero(T)]

    forwards_termination = (
        "Terminating forwards evolution because the PN parameter ùë£ "
        * "has reached ùë£‚Çë=$(v‚Çë).  This is ideal."
    )
    backwards_termination = (
        "Terminating backwards evolution because the PN parameter ùë£ "
        * "has reached ùë£‚ÇÅ=$(v‚ÇÅ).  This is ideal."
    )

    # Check for termination info
    sol1 = @test_logs (:info,forwards_termination) orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢, R·µ¢=R·µ¢, quiet=false)
    sol2 = @test_logs (:info,forwards_termination) (:info,backwards_termination) orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢, Œ©‚ÇÅ=Œ©·µ¢/2, R·µ¢=R·µ¢, quiet=false)

    # Check endpoint values
    @test sol1.retcode == SciMLBase.ReturnCode.Terminated
    @test sol1[:v, 1] == v·µ¢
    @test sol1[1] ‚âà u·µ¢
    @test sol1[:v, end] ‚âà v‚Çë

    @test sol2.retcode == SciMLBase.ReturnCode.Terminated
    @test sol2[:v, 1] ‚âà v‚ÇÅ
    i·µ¢ = argmin(abs.(sol2.t .- 0.0))  # Assuming u·µ¢ corresponds to t==0.0
    @test sol2[i·µ¢] ‚âà u·µ¢
    @test sol2[:v, end] ‚âà v‚Çë

    # Check various forms of interpolation with the forwards/backwards solution
    t = LinRange(sol1.t[1], sol1.t[2], 11)
    @test sol1(t[3], idxs=(:v)) == sol2(t[3], idxs=(:v))
    @test sol1(t, idxs=(:v)) == sol2(t, idxs=(:v))
    @test sol1(t[3], idxs=7:13) == sol2(t[3], idxs=7:13)
    @test sol1(t, idxs=7:13) == sol2(t, idxs=7:13)

    # Check that we can integrate orbital phase just as well
    sol3 = @test_logs min_level=Logging.Info orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢, Œ©‚ÇÅ=Œ©·µ¢/2, R·µ¢=R·µ¢, quiet=true)
    t‚ÇÅ, t‚Çë = extrema(sol3.t)
    t = sol2.t[t‚ÇÅ .< sol2.t .< t‚Çë]
    @test sol2(t) ‚âà sol3(t, idxs=1:length(sol3.u[1]))
    @test sol3(0.0, idxs=(:Œ¶)) ‚âà 0.0  # Initial phase should be ‚âà0
    @test minimum(diff(sol3[:Œ¶])) > 0  # Ensure that the phase is strictly increasing

    # Ensure that non-precessing systems don't precess
    R·µ¢ = Rotor(one(T))
    sol_np = orbital_evolution(M‚ÇÅ, M‚ÇÇ, QuatVec(0, 0, œá‚Éó‚ÇÅ.z), QuatVec(0, 0, œá‚Éó‚ÇÇ.z), Œ©·µ¢; Œ©‚ÇÅ, R·µ¢, quiet=true)
    for c ‚àà [:œá‚Éó‚ÇÅÀ£, :œá‚Éó‚ÇÅ ∏, :œá‚Éó‚ÇÇÀ£, :œá‚Éó‚ÇÇ ∏, :RÀ£, :R ∏]
        @test all(sol_np[c] .== 0)
    end

    # Test that non-precessing rotors evolve like orbital phase
    sincosŒ¶ = cat(map(Œ¶ -> [sincos(Œ¶/2)...], sol_np[:Œ¶])..., dims=2)
    Rwz = sol_np[[PostNewtonian.R·∂ªindex,PostNewtonian.R ∑index], :]
    @test sincosŒ¶ ‚âà Rwz atol=‚àöeps(T)

end
