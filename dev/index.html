<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home Â· PostNewtonian.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://moble.github.io/PostNewtonian.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PostNewtonian.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/moble/PostNewtonian.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PostNewtonian"><a class="docs-heading-anchor" href="#PostNewtonian">PostNewtonian</a><a id="PostNewtonian-1"></a><a class="docs-heading-anchor-permalink" href="#PostNewtonian" title="Permalink"></a></h1><p>This package computes orbital dynamics of and waveforms from binary black-hole systems, in the <a href="https://en.wikipedia.org/wiki/Post-Newtonian_expansion">post-Newtonian approximation</a>. Currently, there is no support for eccentric systems, but general precessing quasicircular systems are supported.</p><ul><li><a href="#PostNewtonian.apery"><code>PostNewtonian.apery</code></a></li><li><a href="#PostNewtonian.Î¶3"><code>PostNewtonian.Î¶3</code></a></li><li><a href="#PostNewtonian.S-NTuple{4, Any}"><code>PostNewtonian.S</code></a></li><li><a href="#PostNewtonian.aâ‚—-NTuple{13, Any}"><code>PostNewtonian.aâ‚—</code></a></li><li><a href="#PostNewtonian.combine_solutions-Tuple{Any, Any}"><code>PostNewtonian.combine_solutions</code></a></li><li><a href="#PostNewtonian.dtmin_terminator-Tuple{Any}"><code>PostNewtonian.dtmin_terminator</code></a></li><li><a href="#PostNewtonian.h!-NTuple{14, Any}"><code>PostNewtonian.h!</code></a></li><li><a href="#PostNewtonian.inspiral-NTuple{5, Any}"><code>PostNewtonian.inspiral</code></a></li><li><a href="#PostNewtonian.noneccentric_RHS!-NTuple{4, Any}"><code>PostNewtonian.noneccentric_RHS!</code></a></li><li><a href="#PostNewtonian.nonfinite_terminator-Tuple{}"><code>PostNewtonian.nonfinite_terminator</code></a></li><li><a href="#PostNewtonian.nÌ‚-Tuple{Any}"><code>PostNewtonian.nÌ‚</code></a></li><li><a href="#PostNewtonian.q-Tuple{Any, Any}"><code>PostNewtonian.q</code></a></li><li><a href="#PostNewtonian.recalculate!-Union{Tuple{T}, Tuple{PNOrder}, Tuple{Any, Any, TaylorT1{PNOrder, T}}} where {PNOrder, T}"><code>PostNewtonian.recalculate!</code></a></li><li><a href="#PostNewtonian.termination_backwards-Tuple{Any}"><code>PostNewtonian.termination_backwards</code></a></li><li><a href="#PostNewtonian.termination_forwards-Tuple{Any}"><code>PostNewtonian.termination_forwards</code></a></li><li><a href="#PostNewtonian.tidal_heating-NTuple{13, Any}"><code>PostNewtonian.tidal_heating</code></a></li><li><a href="#PostNewtonian.up_down_instability-NTuple{13, Any}"><code>PostNewtonian.up_down_instability</code></a></li><li><a href="#PostNewtonian.value-Tuple{Any}"><code>PostNewtonian.value</code></a></li><li><a href="#PostNewtonian.Î£-NTuple{4, Any}"><code>PostNewtonian.Î£</code></a></li><li><a href="#PostNewtonian.Î©âƒ—áµª-NTuple{6, Any}"><code>PostNewtonian.Î©âƒ—áµª</code></a></li><li><a href="#PostNewtonian.Î©âƒ—áµªâ‚-NTuple{13, Any}"><code>PostNewtonian.Î©âƒ—áµªâ‚</code></a></li><li><a href="#PostNewtonian.Î©âƒ—áµªâ‚‚-NTuple{13, Any}"><code>PostNewtonian.Î©âƒ—áµªâ‚‚</code></a></li><li><a href="#PostNewtonian.Î©âƒ—â‚š-NTuple{13, Any}"><code>PostNewtonian.Î©âƒ—â‚š</code></a></li><li><a href="#PostNewtonian.Î³-NTuple{13, Any}"><code>PostNewtonian.Î³</code></a></li><li><a href="#PostNewtonian.Î´-Tuple{Any, Any}"><code>PostNewtonian.Î´</code></a></li><li><a href="#PostNewtonian.Î»Ì‚-Tuple{Any}"><code>PostNewtonian.Î»Ì‚</code></a></li><li><a href="#PostNewtonian.Î¼-Tuple{Any, Any}"><code>PostNewtonian.Î¼</code></a></li><li><a href="#PostNewtonian.Î½-Tuple{Any, Any}"><code>PostNewtonian.Î½</code></a></li><li><a href="#PostNewtonian.Ï‡â‚-NTuple{4, Any}"><code>PostNewtonian.Ï‡â‚</code></a></li><li><a href="#PostNewtonian.Ï‡â‚›-NTuple{4, Any}"><code>PostNewtonian.Ï‡â‚›</code></a></li><li><a href="#PostNewtonian.Ï‡âƒ—-Tuple{Any, Any}"><code>PostNewtonian.Ï‡âƒ—</code></a></li><li><a href="#PostNewtonian.â„“Ì‚-Tuple{Any}"><code>PostNewtonian.â„“Ì‚</code></a></li><li><a href="#PostNewtonian.â„³-Tuple{Any, Any}"><code>PostNewtonian.â„³</code></a></li><li><a href="#PostNewtonian.ğ“”-NTuple{6, Any}"><code>PostNewtonian.ğ“”</code></a></li><li><a href="#PostNewtonian.ğ“”NS-NTuple{15, Any}"><code>PostNewtonian.ğ“”NS</code></a></li><li><a href="#PostNewtonian.ğ“”â€²-NTuple{13, Any}"><code>PostNewtonian.ğ“”â€²</code></a></li><li><a href="#PostNewtonian.ğ“•-NTuple{13, Any}"><code>PostNewtonian.ğ“•</code></a></li><li><a href="#PostNewtonian.ğ“•NS-NTuple{15, Any}"><code>PostNewtonian.ğ“•NS</code></a></li><li><a href="#PostNewtonian.ğ›¡-NTuple{13, Any}"><code>PostNewtonian.ğ›¡</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.apery" href="#PostNewtonian.apery"><code>PostNewtonian.apery</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Î¶3
apery</code></pre><p><a href="https://en.wikipedia.org/wiki/Ap%C3%A9ry%27s_constant">ApÃ©ry&#39;s constant</a> is defined as <span>$Î¶(3)$</span>, where <span>$Î¶$</span> is the Riemann zeta function.  It is OEIS sequence <a href="https://oeis.org/A002117">A002117</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/constants.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î¶3" href="#PostNewtonian.Î¶3"><code>PostNewtonian.Î¶3</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Î¶3
apery</code></pre><p><a href="https://en.wikipedia.org/wiki/Ap%C3%A9ry%27s_constant">ApÃ©ry&#39;s constant</a> is defined as <span>$Î¶(3)$</span>, where <span>$Î¶$</span> is the Riemann zeta function.  It is OEIS sequence <a href="https://oeis.org/A002117">A002117</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/constants.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.S-NTuple{4, Any}" href="#PostNewtonian.S-NTuple{4, Any}"><code>PostNewtonian.S</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚, Ï‡âƒ—â‚‚)</code></pre><p>Total spin vector <span>$Sâƒ—â‚+Sâƒ—â‚‚$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/spins.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.aâ‚—-NTuple{13, Any}" href="#PostNewtonian.aâ‚—-NTuple{13, Any}"><code>PostNewtonian.aâ‚—</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aâ‚—(u)
aâ‚—(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Eq. (4.4) of <a href="https://arxiv.org/abs/1212.5520">BohÃ© et al. (2013)</a>.  This term contributes to <a href="#PostNewtonian.ğ›¡-NTuple{13, Any}"><code>ğ›¡</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L168-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.combine_solutions-Tuple{Any, Any}" href="#PostNewtonian.combine_solutions-Tuple{Any, Any}"><code>PostNewtonian.combine_solutions</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine_solutions(solâ‚‹, solâ‚Š)</code></pre><p>Combine ODESolutions</p><p>This function is internal to this package.  It is not entirely general, but allows us to combine the backwards- and forwards-in-time solutions of the PN inspiral ODE equations into a single <code>ODESolution</code> object that should behave just as if it were the result of <code>solve</code>.  In particular, indexing, interpolation, and iterations should behave exactly as <a href="https://diffeq.sciml.ai/stable/basics/solution/">described in the <code>DifferentialEquations</code> docs</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/combine_solutions.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.dtmin_terminator-Tuple{Any}" href="#PostNewtonian.dtmin_terminator-Tuple{Any}"><code>PostNewtonian.dtmin_terminator</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dtmin_terminator(T)</code></pre><p>Construct termination criterion to terminate when <code>dt</code> drops below <code>âˆšeps(T)</code>.</p><p>Pass <code>force_dtmin=true</code> to <code>solve</code> when using this callback.  Otherwise, the time-step size may decrease too much <em>within</em> a single time step, so that the integrator itself will quit before reaching this callback, leading to a less graceful exit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L103-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.h!-NTuple{14, Any}" href="#PostNewtonian.h!-NTuple{14, Any}"><code>PostNewtonian.h!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h!(h, u; â„“min=0)
h!(h, Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v; â„“min=0)
mode_weights!(h, u; â„“min=0)
mode_weights!(h, Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v; â„“min=0)</code></pre><p>Compute mode weights of gravitational waves emitted by <code>pn</code> system, modifying <code>h</code> in place.</p><p>These modes are computed in the &quot;co-orbital&quot; frame, in which the larger object lies on the positive <span>$x$</span> axis, the smaller lies on the negative <span>$x$</span> axis, and the instantaneous angular velocity is in the positive <span>$z$</span> direction.</p><p>The modes are stored in <code>h</code> in order of increasing <span>$â„“$</span> and increasing <span>$m$</span>, with <span>$m$</span> iterating fastest, all the way up to the highest available mode, <span>$(8,8)$</span>.</p><p>Because gravitational waves have spin weight -2, the <span>$(â„“,m)=(0,0)$</span>, <span>$(1,-1)$</span>, <span>$(1,0)$</span>, and <span>$(1,1)$</span> modes are always 0.  By default, we assume that these modes are nonetheless included in <code>h</code>.  If that is not the case, set <code>â„“min</code> to the smallest <span>$â„“$</span> value that should be present in the output data â€” <code>â„“min=2</code> being the most reasonable alternative.</p><p>All non-spinning terms are taken from <a href="https://doi-org.proxy.library.cornell.edu/10.12942/lrr-2014-2">Blanchet (2014)</a>.  The 1PN spin-orbit term is from Eq. (3.22d) of <a href="https://link.aps.org/doi/10.1103/PhysRevD.52.821">Kidder (1995)</a>.  The 1.5PN spin-orbit term is from Eq. (3.22f) of Kidder (1995) and Eq. (F15b) of <a href="https://link.aps.org/doi/10.1103/PhysRevD.54.4813">Will and Wiseman (1996)</a>.  The 2PN spin-orbit term is from Eq. (4.13) of <a href="https://link.aps.org/doi/10.1103/PhysRevD.87.044009">Buonanno, Faye, Hinderer (2013)</a>, while the 2PN spin-spin term is from Eq. (4.15) of that reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/mode_weights.jl#L5-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.inspiral-NTuple{5, Any}" href="#PostNewtonian.inspiral-NTuple{5, Any}"><code>PostNewtonian.inspiral</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inspiral(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚, Ï‡âƒ—â‚‚, Î©áµ¢; kwargs...)</code></pre><p>Integrate the orbital dynamics of a non-eccentric compact binary.</p><p><strong>Keyword arguments</strong></p><ul><li><code>Î©â‚=Î©áµ¢</code>: First angular velocity in output data (see next section).</li><li><code>Î©â‚‘=1</code>: Final angular velocity at which to stop ODE integration.</li><li><code>Ráµ¢=Rotor(true)</code>: Initial orientation of binary.</li><li><code>PNSys=TaylorT1</code>: Currently the only possibility.</li><li><code>PNOrder=7//2</code>: Not actually used currently.</li><li><code>check_up_down_instability=true</code>: Warn if the <a href="@ref">Up-down instability</a> is likely to affect this system.</li><li><code>time_stepper=AutoVern9(Rodas5())</code>: Choice of solver in OrdinaryDiffEq to integrate ODE.</li><li><code>abstol=eps(T)^(11//16)</code>: Absolute tolerance of ODE solver, where <code>T</code> is the common type to which all the positional arguments are promoted.  This is the tolerance on local error estimates, not necessarily the global error.</li><li><code>reltol=eps(T)^(11//16)</code>: Relative tolerance of ODE solver.  (As above.)</li><li><code>termination_criteria_forwards=nothing</code>: Callbacks to <code>solve</code> for forwards-in-time evolution.  See below for discussion of the default value.</li><li><code>termination_criteria_backwards=nothing</code>: Callbacks to <code>solve</code> for backwards-in-time evolution.  See below for discussion of the default value.</li><li><code>force_dtmin=true</code>: If <code>dt</code> decreases below the integrator&#39;s own minimum, and this is false, the integrator will immediately raise an error, before the termination criteria have the chance to exit gracefully.  Note that a true value here is critical if the <code>dtmin_terminator</code> callback is to have any effect.</li></ul><p>All remaining keyword arguments are passed to the <a href="https://github.com/SciML/DiffEqBase.jl/blob/8e6173029c630f6908252f3fc28a69c1f0eab456/src/solve.jl#L393"><code>solve</code> function</a> of <code>DiffEqBase</code>.  See that function&#39;s documentation for details, including useful keyword arguments.  The most likely important ones are</p><ul><li><code>saveat</code>: Denotes specific times to save the solution at, during the solving phase.</li><li><code>dt</code>: Sets the <em>initial</em> stepsize. Defaults to an automatic choice if the method is adaptive.</li><li><code>dtmax</code>: Maximum dt for adaptive timestepping.</li><li><code>dtmin</code>: Minimum dt for adaptive timestepping.</li></ul><p>Note that if you want the solution to be output with specifically spaced time steps, you <em>don&#39;t</em> want <code>dt</code>, which is just the initial suggestion for adaptive systems; you want to set <code>saveat</code> to the desired spacing.  [The <code>saveat</code> argument could be a vector of specific times at which to save, but because we don&#39;t know when the PN evolution ends, this probably isn&#39;t useful.]</p><p>Also note that <code>callback</code> is already used by this function (in addition to the <code>abstol</code> and <code>reltol</code> mentioned above), which currently makes it impossible to modify the callbacks.  Hacking will be required to change that.  (Note: I think this may be easy, if we add the current callbacks to the <em>problem</em>, and just pass any input callbacks to <strong><code>solve</code></strong>.  I haven&#39;t tested it though.)</p><p><strong>Initial frequency vs. first frequency vs. end frequency</strong></p><p>Note the distinction between <code>Î©áµ¢</code> (with subscript <code>i</code>) and <code>Î©â‚</code> (with subscript <code>1</code>).  The first, <code>Î©áµ¢</code>, represents the angular velocity of the <em>initial condition</em> from which the ODE integrator will begin; the second, <code>Î©â‚</code>, represents the target angular velocity of the first element of the output data. That is, the ODE integration will run forwards in time from <code>Î©áµ¢</code> to the merger, and then come back to <code>Î©áµ¢</code> and run backwards in time to <code>Î©â‚</code>.  The output data will stitch these two together to be one continuous (forwards-in-time) data series.</p><p>For example, if you are trying to match to a numerical relativity (NR) simulation, you can read the masses and spins off of the NR data when the system is orbiting at angular velocity <code>Î©áµ¢</code>.  Integrating the post-Newtonian (PN) solution forwards in time from this point will allow you to compare the PN and NR waveforms.  However, you may want to know what the waveform was at <em>earlier</em> times than are present in the NR data.  For this, you also have to integrate backwards in time.  We parametrise the point to which you integrate backwards with <code>Î©â‚</code>.  In either case, element <code>1</code> of the output solution will have frequency <code>Î©â‚</code> â€” though by default it is equal to <code>Î©áµ¢</code>.</p><p>Similarly, the optional argument <code>Î©â‚‘=1</code> is the frequency of the <code>end</code> element of the solution â€” that is Julia&#39;s notation for the last element.  Note that this is automatically reduced if necessary so that the corresponding PN parameter <span>$v$</span> is no greater than 1, which may be the case whenever the total mass is greater than 1.</p><p><strong>Up-down instability</strong></p><p>Be aware that the <a href="http://arxiv.org/abs/1506.09116">up-down instability</a> (where the more massive black hole has spin aligned with the orbital angular velocity, and the less massive has spin anti-aligned) can cause systems with nearly zero precession at the initial time to evolve into a highly precessing system either at earlier or later times.  This is a real physical result, rather than a numerical issue.  If you want to simulate a truly non-precessing system, you should explicitly set the in-place components of spin to precisely 0.  By default, we check for this condition, and will issue a warning if it is likely to be encountered for systems with low initial precession.  The function used to compute the unstable region is <a href="#PostNewtonian.up_down_instability-NTuple{13, Any}"><code>up_down_instability</code></a>.</p><p><strong>Time-stepper algorithms</strong></p><p><code>Tsit5()</code> is a good default choice for time stepper when using <code>Float64</code> with medium-low tolerance.  If stiffness seems to be impacting the results, <code>AutoTsit5(Rosenbrock23())</code> will automatically switch when stiffness occurs. For tighter tolerances, especially when using <code>Double64</code>s, <code>Vern9()</code> or <code>AutoVern9(Rodas5())</code> are good choices.  For very loose tolerances, as when using <code>Float32</code>s, it might be better to use <code>OwrenZen3()</code>.</p><p><strong>Termination criteria</strong></p><p>The termination criteria are vital to efficiency of the integration and correctness of the solution.  The default values for forwards- and backwards-in-time evolution, respectively, are</p><pre><code class="language-julia hljs">CallbackSet(
    termination_forwards(v(Î©=Î©â‚‘, M=Mâ‚+Mâ‚‚)),
    dtmin_terminator(T),
    nonfinite_terminator()
)</code></pre><p>and</p><pre><code class="language-julia hljs">CallbackSet(
    termination_backwards(v(Î©=Î©â‚, M=Mâ‚+Mâ‚‚)),
    dtmin_terminator(T),
    nonfinite_terminator()
)</code></pre><p>where <code>T</code> is the common float type of the input arguments.  If any additional termination criteria are needed, they could be added as additional elements of the <code>CallbackSet</code>s.  See the <a href="https://diffeq.sciml.ai/stable/features/callback_functions/">callback documentation</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L159-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.noneccentric_RHS!-NTuple{4, Any}" href="#PostNewtonian.noneccentric_RHS!-NTuple{4, Any}"><code>PostNewtonian.noneccentric_RHS!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">noneccentric_RHS!(uÌ‡, u, p, t)</code></pre><p>Compute the right-hand side for the orbital evolution of a non-eccentric binary</p><p>Here, <code>u</code> is the ODE state vector, which can be unpacked with <a href="@ref"><code>PNDynamicalVariables</code></a>.  The parameter <code>p</code> is currently unused, but could be used to pass un-evolved parameters through.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L440-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.nonfinite_terminator-Tuple{}" href="#PostNewtonian.nonfinite_terminator-Tuple{}"><code>PostNewtonian.nonfinite_terminator</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonfinite_terminator()</code></pre><p>Construct termination criterion to terminate when any NaN or Inf is found in the data after an integration step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.nÌ‚-Tuple{Any}" href="#PostNewtonian.nÌ‚-Tuple{Any}"><code>PostNewtonian.nÌ‚</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nÌ‚(R)</code></pre><p>The unit vector pointing from object 2 to object 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/orbital_elements.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.q-Tuple{Any, Any}" href="#PostNewtonian.q-Tuple{Any, Any}"><code>PostNewtonian.q</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">q(Mâ‚, Mâ‚‚)
mass_ratio(Mâ‚, Mâ‚‚)</code></pre><p>Compute mass ratio <span>$Mâ‚/Mâ‚‚$</span>.</p><p>Note that we do not restrict to <code>Mâ‚ â‰¥ Mâ‚‚</code> or vice versa; if you prefer that <span>$q$</span> always be greater than or equal to 1 (or vice versa), you are responsible for ensuring that</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/masses.jl#L38-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.recalculate!-Union{Tuple{T}, Tuple{PNOrder}, Tuple{Any, Any, TaylorT1{PNOrder, T}}} where {PNOrder, T}" href="#PostNewtonian.recalculate!-Union{Tuple{T}, Tuple{PNOrder}, Tuple{Any, Any, TaylorT1{PNOrder, T}}} where {PNOrder, T}"><code>PostNewtonian.recalculate!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recalculate!(uÌ‡, u, pn)</code></pre><p>Calculate the new values of <code>uÌ‡</code> based on the values of <code>u</code>.  Note that this modifies both <code>uÌ‡</code> and <code>pn</code> in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/PNSystems.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.termination_backwards-Tuple{Any}" href="#PostNewtonian.termination_backwards-Tuple{Any}"><code>PostNewtonian.termination_backwards</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">termination_backwards(vâ‚)</code></pre><p>Construct termination criteria of solving PN evolution backwards in time</p><p>These criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at <code>vâ‚</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L59-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.termination_forwards-Tuple{Any}" href="#PostNewtonian.termination_forwards-Tuple{Any}"><code>PostNewtonian.termination_forwards</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">termination_forwards(vâ‚‘)</code></pre><p>Construct termination criteria of solving PN evolution forwards in time</p><p>These criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at <code>vâ‚‘</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.tidal_heating-NTuple{13, Any}" href="#PostNewtonian.tidal_heating-NTuple{13, Any}"><code>PostNewtonian.tidal_heating</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tidal_heating(u)
tidal_heating(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the rate of energy and angular-momentum absorption into each black hole in a binary.</p><p>The returned quantity is a tuple <code>(SÌ‡â‚, MÌ‡â‚, SÌ‡â‚‚, MÌ‡â‚‚)</code>, representing the corresponding rates of change of spin (magnitude) and mass on black holes 1 and</p><ol><li>These apply to general â€” possibly precessing â€” non-eccentric binaries.</li></ol><p>This collection of terms comes from <a href="http://link.aps.org/doi/10.1103/PhysRevD.64.104020">Alvi (2001)</a>.  It probably wouldn&#39;t be too hard to extend Alvi&#39;s analysis to eccentric systems.</p><p>Note that the validity of the result depends not only on the PN parameter <span>$v$</span>, but also on that angles of the spins relative to the separation vector <span>$nÌ‚$</span>: the smaller the angle, the lower the <span>$v$</span> at which the approximations should be expected to break down.</p><p>See also</p><ul><li><a href="http://arxiv.org/abs/gr-qc/9405062">Tagoshi and Sasaki (1994)</a></li><li><a href="https://arxiv.org/abs/gr-qc/9412027">Poisson and Sasaki (1995)</a></li><li><a href="https://arxiv.org/abs/gr-qc/9711072">Tagoshi et al. (1997)</a></li><li><a href="https://arxiv.org/abs/1211.1686">Chatziioannou et al. (2012)</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/tidal_heating.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.up_down_instability-NTuple{13, Any}" href="#PostNewtonian.up_down_instability-NTuple{13, Any}"><code>PostNewtonian.up_down_instability</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">up_down_instability(u)
up_down_instability(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the range of frequencies over which the system is unstable to increasing precession.</p><p>The returned value is a pair of dimensionless frequencies giving the lower and upper frequencies between which we can expect instability.  If there is no instability expected, the returned pair is just (1,1).</p><p>For compact binaries in which the spins are either aligned or anti-aligned with the orbital angular velocity, we do not expect any precession effects â€” simply by symmetry.  However, if the spin of the higher-mass object is aligned with the orbital angular velocity and the spin of the lower-mass object is anti-aligned, the binary is unstable to precession â€” meaning that any minuscule misalignment can grow rapidly into significant precession.  This was first reported by <a href="http://arxiv.org/abs/1506.09116">Gerosa et al. (2015)</a>, and the range over which the system is unstable is given by Eq. (2) of that reference. We use the lowest-order approximation to convert binary separation to frequency.  The result is also &quot;clamped&quot; between 0 and 1, because sometimes the PN approximations involved break down and return unphysical values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/up_down_instability.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.value-Tuple{Any}" href="#PostNewtonian.value-Tuple{Any}"><code>PostNewtonian.value</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(x)</code></pre><p>Return <code>x</code> or the value wrapped by the <code>Dual</code> number <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/inspiral.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î£-NTuple{4, Any}" href="#PostNewtonian.Î£-NTuple{4, Any}"><code>PostNewtonian.Î£</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î£(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚, Ï‡âƒ—â‚‚)</code></pre><p>Differential spin vector <span>$M(aâƒ—â‚‚-aâƒ—â‚)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/spins.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î©âƒ—áµª-NTuple{6, Any}" href="#PostNewtonian.Î©âƒ—áµª-NTuple{6, Any}"><code>PostNewtonian.Î©âƒ—áµª</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î©âƒ—áµª(Mâ±¼, Mâ‚–, Ï‡âƒ—â±¼, Ï‡âƒ—â‚–, R)</code></pre><p>Compute the angular velocity of precession of spin vector <code>Ï‡âƒ—â±¼</code>.</p><p>In the approximation that the spin <em>magnitude</em> is constant, the time derivative of <span>$Ï‡âƒ—â±¼$</span> is due to its rotation alone, and is given by <span>$Î©âƒ—áµª Ã— Ï‡âƒ—â±¼$</span>.</p><p>Note that this function is called by <a href="#PostNewtonian.Î©âƒ—áµªâ‚-NTuple{13, Any}"><code>Î©âƒ—áµªâ‚</code></a> and <a href="#PostNewtonian.Î©âƒ—áµªâ‚‚-NTuple{13, Any}"><code>Î©âƒ—áµªâ‚‚</code></a> with the appropriate parameters; you probably want to use those instead of this one.</p><p>The spin-spin term is given by Eq. (2.4) of <a href="http://link.aps.org/doi/10.1103/PhysRevD.52.821">Kidder (1995)</a>; the spin-orbit terms by Eq. (4.5) of <a href="http://arxiv.org/abs/1212.5520v2">BohÃ© et al. (2013)</a>; and the quadrupole-monopole term by Eq. (2.7) <a href="http://link.aps.org/doi/10.1103/PhysRevD.78.044021">Racine (2008)</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L64-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î©âƒ—áµªâ‚-NTuple{13, Any}" href="#PostNewtonian.Î©âƒ—áµªâ‚-NTuple{13, Any}"><code>PostNewtonian.Î©âƒ—áµªâ‚</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î©âƒ—áµªâ‚(u)
Î©âƒ—áµªâ‚(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the angular velocity of precession of Ï‡âƒ—â‚</p><p>In the approximation that the spin <em>magnitude</em> is constant, the time derivative of <span>$Ï‡âƒ—â‚$</span> is due to its rotation alone, and is given by <span>$Î©âƒ—áµªâ‚ Ã— Ï‡âƒ—â‚$</span>.</p><p>Note that this function simply calls <a href="#PostNewtonian.Î©âƒ—áµª-NTuple{6, Any}"><code>Î©âƒ—áµª</code></a> with the appropriate parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î©âƒ—áµªâ‚‚-NTuple{13, Any}" href="#PostNewtonian.Î©âƒ—áµªâ‚‚-NTuple{13, Any}"><code>PostNewtonian.Î©âƒ—áµªâ‚‚</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î©âƒ—áµªâ‚‚(u)
Î©âƒ—áµªâ‚‚(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the angular velocity of precession of Ï‡âƒ—â‚‚</p><p>In the approximation that the spin <em>magnitude</em> is constant, the time derivative of <span>$Ï‡âƒ—â‚‚$</span> is due to its rotation alone, and is given by <span>$Î©âƒ—áµªâ‚‚ Ã— Ï‡âƒ—â‚‚$</span>.</p><p>Note that this function simply calls <a href="#PostNewtonian.Î©âƒ—áµª-NTuple{6, Any}"><code>Î©âƒ—áµª</code></a> with the appropriate parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î©âƒ—â‚š-NTuple{13, Any}" href="#PostNewtonian.Î©âƒ—â‚š-NTuple{13, Any}"><code>PostNewtonian.Î©âƒ—â‚š</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î©âƒ—â‚š(u)
Î©âƒ—â‚š(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the angular velocity of orbital precession.</p><p>This is the angular velocity <em>of</em> the orbital angular velocity direction unit vector <span>$â„“Ì‚$</span>; the time derivative of that <em>unit</em> vector is <span>$Î©âƒ—â‚š Ã— â„“Ì‚$</span>.</p><p>At the moment, this is computed solely by expressions from <a href="https://arxiv.org/abs/1212.5520">BohÃ© et al. (2013)</a>.  See <a href="#PostNewtonian.ğ›¡-NTuple{13, Any}"><code>ğ›¡</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î³-NTuple{13, Any}" href="#PostNewtonian.Î³-NTuple{13, Any}"><code>PostNewtonian.Î³</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î³(u)
Î³(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Eq. (4.3) of <a href="https://arxiv.org/abs/1212.5520">BohÃ© et al. (2013)</a>.  This term contributes to <a href="#PostNewtonian.ğ›¡-NTuple{13, Any}"><code>ğ›¡</code></a>.</p><p>Note that there is a 3PN term of <span>$-22Î½\ln(r/râ‚€â€²)/3$</span> that is simply ignored here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L135-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î´-Tuple{Any, Any}" href="#PostNewtonian.Î´-Tuple{Any, Any}"><code>PostNewtonian.Î´</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î´(Mâ‚, Mâ‚‚)
mass_difference_ratio(Mâ‚, Mâ‚‚)</code></pre><p>Compute mass-difference ratio <span>$(Mâ‚-Mâ‚‚)/(Mâ‚+Mâ‚‚)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/masses.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î»Ì‚-Tuple{Any}" href="#PostNewtonian.Î»Ì‚-Tuple{Any}"><code>PostNewtonian.Î»Ì‚</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î»Ì‚(R)</code></pre><p>The unit vector pointing in the direction of the instantaneous velocity of object 1.  This also completes the right-handed triple of (â„“Ì‚, nÌ‚, Î»Ì‚).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/orbital_elements.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î¼-Tuple{Any, Any}" href="#PostNewtonian.Î¼-Tuple{Any, Any}"><code>PostNewtonian.Î¼</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î¼(Mâ‚, Mâ‚‚)
reduced_mass(Mâ‚, Mâ‚‚)</code></pre><p>Compute the reduced mass <span>$(Mâ‚ Mâ‚‚)/(Mâ‚+Mâ‚‚)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/masses.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Î½-Tuple{Any, Any}" href="#PostNewtonian.Î½-Tuple{Any, Any}"><code>PostNewtonian.Î½</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Î½(Mâ‚, Mâ‚‚)
reduced_mass_ratio(Mâ‚, Mâ‚‚)</code></pre><p>Compute the reduced mass ratio <span>$(Mâ‚ Mâ‚‚)/(Mâ‚+Mâ‚‚)^2$</span>.</p><p>Note that the denominator is squared, unlike in the reduced mass <a href="#PostNewtonian.Î¼-Tuple{Any, Any}"><code>Î¼</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/masses.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Ï‡â‚-NTuple{4, Any}" href="#PostNewtonian.Ï‡â‚-NTuple{4, Any}"><code>PostNewtonian.Ï‡â‚</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ï‡â‚(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚, Ï‡âƒ—â‚‚)</code></pre><p>Antisymmetric spin vector (Ï‡âƒ—â‚-Ï‡âƒ—â‚‚)/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/spins.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Ï‡â‚›-NTuple{4, Any}" href="#PostNewtonian.Ï‡â‚›-NTuple{4, Any}"><code>PostNewtonian.Ï‡â‚›</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ï‡â‚›(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚, Ï‡âƒ—â‚‚)</code></pre><p>Symmetric spin vector (Ï‡âƒ—â‚+Ï‡âƒ—â‚‚)/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/spins.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.Ï‡âƒ—-Tuple{Any, Any}" href="#PostNewtonian.Ï‡âƒ—-Tuple{Any, Any}"><code>PostNewtonian.Ï‡âƒ—</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ï‡âƒ—(Sâƒ—, M)</code></pre><p>Normalized spin vector <span>$Sâƒ—/MÂ²$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/spins.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.â„“Ì‚-Tuple{Any}" href="#PostNewtonian.â„“Ì‚-Tuple{Any}"><code>PostNewtonian.â„“Ì‚</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">â„“Ì‚(R)</code></pre><p>The unit vector pointing along the direction of orbital angular velocity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/orbital_elements.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.â„³-Tuple{Any, Any}" href="#PostNewtonian.â„³-Tuple{Any, Any}"><code>PostNewtonian.â„³</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">â„³(Mâ‚, Mâ‚‚)
chirp_mass(Mâ‚, Mâ‚‚)</code></pre><p>Compute the chirp mass â„³, which determines the leading-order orbital evolution of a binary system due to energy loss by gravitational-wave emission.</p><p>The chirp mass is defined as</p><p class="math-container">\[  \mathcal{M} = rac{(Mâ‚ Mâ‚‚)^{3/5}} {(Mâ‚ + Mâ‚‚)^{1/5}}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/masses.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.ğ“”-NTuple{6, Any}" href="#PostNewtonian.ğ“”-NTuple{6, Any}"><code>PostNewtonian.ğ“”</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğ“”(u)
ğ“”(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)
binding_energy(u)
binding_energy(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the binding energy of a compact binary.</p><p>Note that this may not be as useful as its derivative, <a href="#PostNewtonian.ğ“”â€²-NTuple{13, Any}"><code>ğ“”â€²</code></a>, which is used as part of the right-hand side for orbital evolutions.</p><p>The nonspinning orbital binding energy is known through 4pN.  The expressions through 3.5pN here come from Eq. (233) of <a href="https://doi.org/10.12942/lrr-2014-2">Blanchet (2014)</a>.</p><p>The 4pN term from Eq. (5.2d) of <a href="https://arxiv.org/abs/1303.3225v1">Jaranowski and SchÃ¤fer</a> is known exactly, now that the <span>$Î½$</span>-linear piece is given as Eq. (32) of <a href="https://arxiv.org/abs/1305.4884v1">Bini and Damour (2013a)</a>.  The remaining terms are not known exactly, but <a href="https://arxiv.org/abs/1312.2503v1">Bini and Damour (2013b)</a> have derived some terms, though there is incomplete information, which are noted as the constants in the following cell.  Note that, though the notation is confusing, Bini and Damour claim they did not calculate the coefficient they call <span>$a_6^{\ln 1}$</span>; but it seems to be given in their Eq. (64).</p><p>The spin-squared terms (by which I mean both spin-spin and spin-orbit squared terms) in the energy are known only at 2pN order (from <a href="https://link.aps.org/doi/10.1103/PhysRevD.52.821">Kidder (1995)</a> and <a href="https://link.aps.org/doi/10.1103/PhysRevD.54.4813">Will and Wiseman (1996)</a>).  They are most conveniently given in Eq. (C4) of <a href="https://arxiv.org/abs/0810.5336v3">Arun et al.</a></p><p>The spin-orbit terms in the energy are now complete to 4.0pN (the last term is zero).  These terms come from Eq. (4.6) of <a href="https://arxiv.org/abs/1212.5520v2">BohÃ© et al. (2012)</a>:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/binding_energy.jl#L10-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.ğ“”NS-NTuple{15, Any}" href="#PostNewtonian.ğ“”NS-NTuple{15, Any}"><code>PostNewtonian.ğ“”NS</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğ“”NS(u, Î»â‚, Î»â‚‚)
ğ“”NS(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v, Î»â‚, Î»â‚‚)
binding_energy_NS(u, Î»â‚, Î»â‚‚)
binding_energy_NS(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v, Î»â‚, Î»â‚‚)</code></pre><p>Compute tidal NS contribution to the gravitational binding energy</p><p>The tidal-coupling terms come in to the energy at relative 5pN order, and are known to 6pN order.  These terms come from Eq. (2.11) of <a href="https://prd.aps.org/abstract/PRD/v83/i8/e084051">Vines et al. (2011)</a>.  Note their unusual convention for mass ratios, where <span>$Ï‡â‚ = mâ‚/m$</span> in their notation; in particular, <span>$Ï‡$</span> is not a spin parameter.  Also note that <span>$Î»Ì‚ = Î»â‚‚ v^{10}/(mâ‚+mâ‚‚)^5$</span>, and we need to add the coupling terms again with <span>$1 â†” 2$</span>. Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/binding_energy.jl#L189-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.ğ“”â€²-NTuple{13, Any}" href="#PostNewtonian.ğ“”â€²-NTuple{13, Any}"><code>PostNewtonian.ğ“”â€²</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğ“”â€²(u)
ğ“”â€²(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)
binding_energy_deriv(u)
binding_energy_deriv(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the derivative with respect to <span>$v$</span> of the binding energy of a compact binary.</p><p>This is computed symbolically from <a href="#PostNewtonian.ğ“”-NTuple{6, Any}"><code>ğ“”</code></a>; see that function for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/binding_energy.jl#L163-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.ğ“•-NTuple{13, Any}" href="#PostNewtonian.ğ“•-NTuple{13, Any}"><code>PostNewtonian.ğ“•</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğ“•(u)
ğ“•(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)
gw_energy_flux(u)
gw_energy_flux(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the gravitational-wave energy flux to infinity</p><p>The nonspinning flux terms are complete to 3.5pN order.  These terms are given by Eq. (314) of <a href="https://doi.org/10.12942/lrr-2014-2">Blanchet (2014)</a>.</p><p>The spin-squared terms (by which I mean both spin-spin and spin-orbit squared terms) in the flux are known only at 2pN order (from <a href="https://link.aps.org/doi/10.1103/PhysRevD.52.821">Kidder (1995)</a> and <a href="https://link.aps.org/doi/10.1103/PhysRevD.54.4813">Will and Wiseman (1996)</a>).  They are most conveniently given in Eq. (C10) of <a href="https://arxiv.org/abs/0810.5336v3">Arun et al. (2008)</a></p><p>The spin-orbit terms in the flux are now known to 4.0pN.  These terms come from Eq. (4.9) of <a href="https://arxiv.org/abs/1307.6793v1">Marsat et al. (2013)</a></p><p>Beyond 3.5pN, terms other than the 4.0pN spin-orbit are only known in the extreme-mass-ratio limit.  These terms are given in Appendix A of <a href="https://arxiv.org/abs/1211.5535v1">Fujita (2012)</a>.  He computed them up to 22pN. That seems like overkill, so we&#39;ll just go up to 6pN.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/flux.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.ğ“•NS-NTuple{15, Any}" href="#PostNewtonian.ğ“•NS-NTuple{15, Any}"><code>PostNewtonian.ğ“•NS</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğ“•NS(u, Î»â‚, Î»â‚‚)
ğ“•NS(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v, Î»â‚, Î»â‚‚)
gw_energy_flux_NS(u, Î»â‚, Î»â‚‚)
gw_energy_flux_NS(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v, Î»â‚, Î»â‚‚)</code></pre><p>Compute tidal NS contribution to the gravitational-wave energy flux to infinity</p><p>For systems with matter, the tidal-coupling terms come in at relative 5pN order, and are known partially at 6pN order.  These terms come from Eq. (3.6) of <a href="https://prd.aps.org/abstract/PRD/v83/i8/e084051">Vines et al. (2011)</a>. Note their unusual convention for mass ratios, where <span>$Ï‡â‚ = mâ‚/m$</span> in their notation; in particular, <span>$Ï‡$</span> is not a spin parameter.  Also note that <span>$Î»Ì‚ = Î»â‚‚ v^{10}/(mâ‚+mâ‚‚)^5$</span>, and we need to add the coupling terms again with <span>$1 â†” 2$</span>.  Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/flux.jl#L121-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PostNewtonian.ğ›¡-NTuple{13, Any}" href="#PostNewtonian.ğ›¡-NTuple{13, Any}"><code>PostNewtonian.ğ›¡</code></a> â€” <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ğ›¡(u)
ğ›¡(Mâ‚, Mâ‚‚, Ï‡âƒ—â‚Ë£, Ï‡âƒ—â‚Ê¸, Ï‡âƒ—â‚á¶», Ï‡âƒ—â‚‚Ë£, Ï‡âƒ—â‚‚Ê¸, Ï‡âƒ—â‚‚á¶», RÊ·, RË£, RÊ¸, Rá¶», v)</code></pre><p>Compute the angular velocity of orbital precession according to BohÃ© et al.</p><p>As <a href="https://arxiv.org/abs/1212.5520">BohÃ© et al. (2013)</a> explain above their Eq. (4.1), the orbital precession is given by the time derivative of the orbital axis: <span>$ğ“µÌ‡ = ğ›¡ Ã— ğ“µ$</span>, where the angular velocity is along the separation vector <span>$ğ“·$</span>, so that <span>$ğ›¡ = Ï– ğ“·$</span>.  And in turn, they define <span>$aâ‚— â‰” r Ï‰ Ï–$</span>, where <span>$r$</span> is the separation and <span>$Ï‰$</span> is the orbital angular frequency. Then, they define the PN parameter <span>$Î³â‰”M/r$</span> and we have <span>$MÏ‰ = vÂ³$</span> so that <span>$Ï– = Î³ aâ‚— / vÂ³$</span>.  The parameters <span>$Î³$</span> and <span>$aâ‚—$</span> are given by Eqs. (4.3) and (4.4), and given here by the functions <a href="#PostNewtonian.Î³-NTuple{13, Any}"><code>Î³</code></a> and  <a href="#PostNewtonian.aâ‚—-NTuple{13, Any}"><code>aâ‚—</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/220ba86d05e35bb40184de62e8048dab60a59d39/src/pn_dynamics/precession.jl#L106-L121">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Wednesday 13 July 2022 22:45">Wednesday 13 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
