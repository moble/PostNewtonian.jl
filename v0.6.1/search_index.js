var documenterSearchIndex = {"docs":
[{"location":"interface/python/#Using-this-package-from-Python","page":"Python","title":"Using this package from Python","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"While not quite as natural as calling Python code from Julia, it is very easy to call Julia code from Python.  The process is essentially the same as using any other Python package, other than installing Julia itself and any dependencies within Julia that you may need (both of which are much easier than similar tasks in Python).","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"warning: Warning\nThis package uses Unicode internally and in many of the examples found in this documentation.  However, every effort is made to ensure that users of this package can always use plain ASCII.  For example, if keyword arguments are accepted as Unicode, ASCII equivalents are usually also accepted.  Some function names are similarly in Unicode, but have ASCII equivalents.  See the various functions' documentation for acceptable replacements.It can be dangerous to use Unicode in Python in particular.   Python only accepts a small subset of Unicode ‚Äî so that M‚ÇÅ for example is not valid input.  And what it does accept is automatically \"NFKC normalized\". For example, variable names M‚Çê, Ma, and M·µÉ are all treated identically by Python.  To illustrate this, consider the following python code:>>> M‚Çê = 1\n>>> M·µÉ = 2\n>>> Ma = 3\n>>> (M‚Çê, M·µÉ, Ma)\n(3, 3, 3)We might have expected three different values (1, 2, 3) in the output, but Python never even sees the variable names as different strings; it interprets these expressions as setting, resetting, and resetting again the value of Ma.If you find an example where ASCII substitutions are not possible, please file a bug report.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Note that the Julia packages are installed uniquely to your python environment ‚Äî preferably a conda env.  For example, if you use two different conda envs to call into Julia, you'll need to install the Julia packages for each env.  This has the great advantage of allowing you to use different packages or versions in each of the different environments.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Install Julia\nThere are several options here:\nIf you are already use conda to manage your python installation (which is generally the recommended approach in python), you can just add julia to the list of packages to install in step 2.\nThe juliaup installer has pretty broad support from some of the main Julia developers, and seems likely to be the main installation method in the not-too-distant future.\nOtherwise, the official method is to just download a binary from the official download page.\nWhichever method you choose, make sure that the julia executable is on your PATH.\nOptionally, create a conda[1] env just for this task\nconda create -n julia_pn python numpy matplotlib\nconda activate julia_pn\nAdd whatever other packages you use to that first line.\nInstall juliacall and PostNewtonian\npython -m pip install juliacall\npython -c 'from juliacall import Main as jl; jl.seval(\"\"\"using Pkg; Pkg.add(\"PostNewtonian\")\"\"\")'\n(Yes, you should use pip from inside a conda env.)  This will take a few minutes to compile all the necessary packages in Julia.\nTest the installation\nStart up a python session and run something like this:\n# Any python imports you need go here\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Start the Julia session\nfrom juliacall import Main as jl\n\n# Import `PostNewtonian` in the Julia session\njl.seval(\"using PostNewtonian\")\n\n# Declare some parameters\ndelta = 0.0\nchi1 = np.array([0.1, 0.2, 0.3])\nchi2 = np.array([-0.2, 0.1, -0.3])\nOmega_i = 0.01\n\n# Call into Julia to run some function\nw = jl.GWFrames.PNWaveform(\"TaylorT1\", delta, chi1, chi2, Omega_i)\n\n# Plot the magnitudes of all the modes as functions of time\nplt.semilogy(w.t, np.abs(w.data))\nThe second-to-last line above uses the GWFrames.PNWaveform function from this package, which is meant to emulate the original syntax from the GWFrames package.  The resulting w will have various fields, like t, data, and frame, similar to those attached to WaveformModes objects in the scri and sxs packages.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"In general, you can now call any Julia function by prepending jl. to the call you would make in Julia.  As a fallback, you can evaluate actual Julia code in the Julia session using jl.seval(\"<Julia code goes here>\").  This returns whatever the Julia code would return.  A simple example is x = jl.seval(\"1+2\").  See the documentation for juliacall here for more details.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Typically, the main stumbling block is converting Python lists to Julia Vectors when calling Julia functions.  Frequently, Julia code will have difficulty if you try to pass a Python list, because lists do not have any specific type that Julia can understand.  Instead, you should always convert a list to a numpy array with np.asarray.  It is still possible that numpy will not understand the type of the list, and you'll still get an error from Julia; in this case you need to figure out the dtype to tell numpy about..","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Fortunately, conversion back to Python objects is more automatic.  In particular, if Julia returns a Vector, Matrix, or more generally shaped Array, you can usually just use that quantity in calls to Python functions. If you really need a numpy array, the returned object will have a .to_numpy() method.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Of course, it is much simpler to call Python code from Julia, so if you find yourself using a lot of Julia code, you may want to consider flipping your approach.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"[1]: As general advice, you should run conda install -y mamba -n base -c   conda-forge, and then just use the command mamba wherever you would   have used conda; mamba is a complete drop-in replacement, but is much   faster because it's written in C instead of python.  For example, mamba   create -n julia_pn python numpy matplotlib will typically run faster than   the command given here.  This becomes a huge advantage when the env has   lots of dependencies.","category":"page"},{"location":"interface/symbolics/#Symbolic-manipulations","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"","category":"section"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"It can be useful to evaluate the post-Newtonian expressions with symbolic arguments.  To do so, we just need to create a PNSystem containing a state vector of symbols.  All of the variables defined in PostNewtonian.FundamentalVariables and PostNewtonian.DerivedVariables have methods defined automatically to generate symbols instead of values when called with a symbolic PNSystem.  In turn, any function modified by the @pn_expression macro should also be able to return a symbolic result, including all functions described in the \"PN expressions\" section.","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"For convenience, this package provides symbolic_pnsystem, which has all the fundamental variables stored as Symbolics.jl variables.  We can extract the symbols as usual:","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"julia> v = PostNewtonian.v(symbolic_pnsystem)\nv","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"More generally, we can obtain a symbolic expression for the binding energy as","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"julia> ùìî(symbolic_pnsystem)\n(-1//2)*M*ŒΩ*(1 + ((19//8)*ŒΩ - (27//8) - (1//24)*(ŒΩ^2))*(v^4) + (ŒΩ*(œá‚ÇÅ‚ÇÇ + 6(œá‚Çê‚Çó^2)) + [...]","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"In fact, this is how the derivative-of-binding-energy function ùìî‚Ä≤ is constructed, essentially as","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"julia> ‚àÇ·µ• = Differential(v);\n\njulia> expand_derivatives(‚àÇ·µ•(ùìî(symbolic_pnsystem)))\n(-1//2)*M*ŒΩ*((-90(v^9)*((M‚ÇÇ*Œª‚ÇÅ) / M‚ÇÅ + (M‚ÇÅ*Œª‚ÇÇ) / M‚ÇÇ)) / (M^5) + [...]","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"Note that special care is taken to preserve the types of Irrationals and the arguments of certain functions like sqrt and log.  Ordinarily, Julia will evaluate these as Float64s; to ensure that they remain symbolic, we have to wrap them in a function that Symbolics.jl will know not to bother expanding: PostNewtonian.hold.  While manipulating these expressions symbolically, you'll probably want to leave those hold calls as they are.  If you convert the expressions to code, Julia will compile them away easily, so you don't need to do anything more.  However, you can remove them using PostNewtonian.unhold if the code is in Expr form.","category":"page"},{"location":"internals/derived_variables/#Derived-variables","page":"Derived variables","title":"Derived variables","text":"","category":"section"},{"location":"internals/derived_variables/#Orbital-elements","page":"Derived variables","title":"Orbital elements","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"nÃÇ\nŒªÃÇ\n‚ÑìÃÇ\nŒ©","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.nÃÇ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.nÃÇ","text":"nÃÇ(pnsystem)\nnÃÇ(R)\nn_hat(pnsystem)\nn_hat(R)\n\nThe unit vector pointing from object 2 to object 1, when the frame is given by the rotor R.  This is equal to\n\nn(R) = R x R\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ŒªÃÇ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ŒªÃÇ","text":"ŒªÃÇ(pnsystem)\nŒªÃÇ(R)\nlambda_hat(pnsystem)\nlambda_hat(R)\n\nThe unit vector pointing in the direction of the instantaneous velocity of object 1, when the frame is given by the rotor R.  This is equal to\n\nŒª(R) = R y R\n\nThis also completes the right-handed triple of (n Œª ‚Ñì).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.‚ÑìÃÇ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.‚ÑìÃÇ","text":"‚ÑìÃÇ(pnsystem)\n‚ÑìÃÇ(R)\nell_hat(pnsystem)\nell_hat(R)\n\nThe unit vector pointing along the direction of orbital angular velocity, when the frame is given by the rotor R.  This is equal to\n\n‚Ñì(R) = R z R\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Œ©","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Œ©","text":"Œ©(pnsystem)\nŒ©(;v, M=1)\nOmega(pnsystem)\nOmega(;v, M=1)\n\nOrbital angular frequency.\n\nThe parameter v is the PN velocity parameter, and must be passed as a keyword argument ‚Äî as in Œ©(v=0.1).  The parameter M is the total mass of the binary.  They are related by definition as\n\nOmega colonequals fracv^3M\n\nSee also v.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#Mass-combinations","page":"Derived variables","title":"Mass combinations","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"PostNewtonian.M\nPostNewtonian.Œº\nPostNewtonian.ŒΩ\nPostNewtonian.Œ¥\nPostNewtonian.q\nPostNewtonian.‚Ñ≥","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.M","page":"Derived variables","title":"PostNewtonian.DerivedVariables.M","text":"M(pnsystem)\nM(M‚ÇÅ, M‚ÇÇ)\ntotal_mass(pnsystem)\ntotal_mass(M1, M2)\n\nCompute the total mass M‚ÇÅ+M‚ÇÇ.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Œº","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Œº","text":"Œº(pnsystem)\nŒº(M‚ÇÅ, M‚ÇÇ)\nreduced_mass(pnsystem)\nreduced_mass(M1, M2)\n\nCompute the reduced mass (M‚ÇÅ M‚ÇÇ)(M‚ÇÅ+M‚ÇÇ).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ŒΩ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ŒΩ","text":"ŒΩ(pnsystem)\nŒΩ(M‚ÇÅ, M‚ÇÇ)\nreduced_mass_ratio(pnsystem)\nreduced_mass_ratio(M1, M2)\n\nCompute the reduced mass ratio (M‚ÇÅ M‚ÇÇ)(M‚ÇÅ+M‚ÇÇ)^2.\n\nNote that the denominator is squared, unlike in the reduced mass Œº.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Œ¥","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Œ¥","text":"Œ¥(pnsystem)\nŒ¥(M‚ÇÅ, M‚ÇÇ)\nmass_difference_ratio(pnsystem)\nmass_difference_ratio(M1, M2)\n\nCompute mass-difference ratio (M‚ÇÅ-M‚ÇÇ)(M‚ÇÅ+M‚ÇÇ).\n\nNote that we do not restrict to M‚ÇÅ  M‚ÇÇ or vice versa; if you prefer that Œ¥ always be positive (or always negative), you are responsible for ensuring that.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.q","page":"Derived variables","title":"PostNewtonian.DerivedVariables.q","text":"q(pnsystem)\nq(M‚ÇÅ, M‚ÇÇ)\nmass_ratio(pnsystem)\nmass_ratio(M1, M2)\n\nCompute mass ratio M‚ÇÅM‚ÇÇ.\n\nNote that we do not restrict to M‚ÇÅ  M‚ÇÇ or vice versa; if you prefer that q always be greater than or equal to 1 (or vice versa), you are responsible for ensuring that.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.‚Ñ≥","page":"Derived variables","title":"PostNewtonian.DerivedVariables.‚Ñ≥","text":"‚Ñ≥(pnsystem)\n‚Ñ≥(M‚ÇÅ, M‚ÇÇ)\nchirp_mass(pnsystem)\nchirp_mass(M1, M2)\n\nCompute the chirp mass ‚Ñ≥, which determines the leading-order orbital evolution of a binary system due to energy loss by gravitational-wave emission.\n\nThe chirp mass is defined as\n\n  mathcalM = frac(M_1 M_2)^35 (M_1 + M_2)^15\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#Spin-combinations","page":"Derived variables","title":"Spin combinations","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"S‚Éó‚ÇÅ\nS‚Éó‚ÇÇ\nS‚Éó\nŒ£‚Éó\nœá‚Éó\nœá‚Éó‚Çõ\nœá‚Éó‚Çê\nœá‚Çë\nœá‚Çö","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S‚Éó‚ÇÅ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S‚Éó‚ÇÅ","text":"S‚Éó‚ÇÅ(pnsystem)\n\nDimensionful spin vector of object 1.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S‚Éó‚ÇÇ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S‚Éó‚ÇÇ","text":"S‚Éó‚ÇÇ(pnsystem)\n\nDimensionful spin vector of object 2.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S‚Éó","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S‚Éó","text":"S‚Éó(pnsystem)\nS‚Éó(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ)\n\nTotal (dimensionful) spin vector S‚ÇÅ+S‚ÇÇ.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Œ£‚Éó","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Œ£‚Éó","text":"Œ£‚Éó(pnsystem)\nŒ£‚Éó(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ)\n\nDifferential spin vector M(a‚ÇÇ-a‚ÇÅ).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.œá‚Éó","page":"Derived variables","title":"PostNewtonian.DerivedVariables.œá‚Éó","text":"œá‚Éó(pnsystem)\nœá‚Éó(S‚Éó, M)\n\nNormalized spin vector SM¬≤.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.œá‚Éó‚Çõ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.œá‚Éó‚Çõ","text":"œá‚Éó‚Çõ(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ)\n\nSymmetric spin vector (œá‚ÇÅ+œá‚ÇÇ)2.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.œá‚Éó‚Çê","page":"Derived variables","title":"PostNewtonian.DerivedVariables.œá‚Éó‚Çê","text":"œá‚Éó‚Çê(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ)\n\nAntisymmetric spin vector (œá‚ÇÅ-œá‚ÇÇ)2.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.œá‚Çë","page":"Derived variables","title":"PostNewtonian.DerivedVariables.œá‚Çë","text":"œá‚Çë(s)\nchi_eff(s)\n\nEffective spin parameter of the system.\n\nDefined as\n\nchi_mathrmeff\ncolonequals fraccG left(\n    fracmathbfS_1M_1 + fracmathbfS_2M_2\nright) cdot frachatmathbfL_mathrmN M\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.œá‚Çö","page":"Derived variables","title":"PostNewtonian.DerivedVariables.œá‚Çö","text":"œá‚Çö(s)\nchi_p(s)\n\nEffective precession spin parameter of the system.\n\nNote that there are two different definitions of this quantity found in the literature. The original definition (converted to the convention where M_1 geq M_2) is\n\nbegingathered\nA_1 = 2 + frac3M_22M_1 \nA_2 = 2 + frac3M_12M_2 \nchi_mathrmp colonequals frac1A_1 M_1^2\nmathrmmaxleft(A_1 S_1perp A_2 S_2perp right)\nendgathered\n\nIn a paper from early in the detection era, the LIGO collaboration used this definition.\n\nHowever, a more recent paper redefines this essentially as M_1^2 times that quantity.  Using the convention that q = M_2M_1 leq 1, the definition may be more compactly written as\n\nchi_mathrmp colonequals mathrmmax left(\n    chi_1perp chi_2perp q frac4q+34+3q\nright)\n\nAgain, a more recent paper by LIGO/Virgo/KAGRA uses this convention.\n\nBecause it seems to be the trend, this function uses the latter definition.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Additionally, there are numerous convenience functions to give certain components of the spins.  They take a single pnsystem argument and are not exported.  Given the definitions above, they are all fairly self explanatory ‚Äî such as œá‚ÇÅ¬≤, which gives œá‚Éó‚ÇÅ ‚ãÖ œá‚Éó‚ÇÅ; or œá‚ÇÅ‚ÇÇ = œá‚Éó‚ÇÅ ‚ãÖ œá‚Éó‚ÇÇ; or S‚Çô = S‚Éó ‚ãÖ nÃÇ. Like all the other fundamental and derived variables, these can be used directly in PN expressions modified by the @pn_expression macro.","category":"page"},{"location":"internals/code_structure/#Structure-of-this-package's-code","page":"Code structure","title":"Structure of this package's code","text":"","category":"section"},{"location":"internals/code_structure/","page":"Code structure","title":"Code structure","text":"There is a fairly simple hierarchy to the code.  Beyond some basic utilities, which are related to how we write the code, rather than post-Newtonian calculations per se, we have the following:","category":"page"},{"location":"internals/code_structure/","page":"Code structure","title":"Code structure","text":"System and state\nObjects of type PNSystem represent the PN system itself and some information about it, including:\nThe Binary type ‚Äî¬†BBH, BHNS, or NSNS\nThe float type T ‚Äî¬†Float64, etc.\nThe PN expansion order PNOrder ‚Äî a Rational\nThe current state of the system, including the fundamental variables\nThe first of these is represented as the type itself, the last is stored as a vector inside the object, and the rest are represented as type parameters.\nNote that basically everything below will be written as a function of such an object, which we will denote pnsystem.\nFundamental variables \nThis consists of the basic variables describing the system such as M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, R, v.  For systems with matter, this may also include tidal deformability for each star, Œª‚ÇÅ and Œª‚ÇÇ.\nIt's important to note that these should all be accessed through functions like M‚ÇÅ(pnsystem) rather than directly like pnsystem.M‚ÇÅ.  This allows Julia's type system to get involved, enabling important optimizations.\nAlso, these variables can be automatically computed in functions that need them with the @pn_expression macro.  For example, you can directly use the symbols M‚ÇÅ, M‚ÇÇ, etc., in a function that is wrapped in that macro, without any qualifiers to specify where those variables are coming from, and the macro will automatically and efficiently evaluate them for you because they are defined in the PostNewtonian.FundamentalVariables module.\nDerived variables\nThese are variables that are frequently used in PN expressions that can be computed from the fundamental variables, and are defined in terms of them. For example, the total mass M ‚âî M‚ÇÅ+M‚ÇÇ, the antisymmetric spin vector œá‚Éó‚Çê ‚âî (œá‚Éó‚ÇÅ-œá‚Éó‚ÇÇ)/2, or the orbital separation vector nÃÇ ‚âî R xÃÇ RÃÑ.  While none of these are strictly necessary, it is helpful to be able to write the same variables used in articles providing the PN expressions in the code itself.\nBecause they are defined solely in terms of fundamental variables, which can be computed from an PNSystem alone, these are all written as functions of such an object ‚Äî such as M(pnsystem), œá‚Éó‚Çê(pnsystem), and nÃÇ(pnsystem).\nAgain, these quantities will be automatically computed for you in any function wrapped in the @pn_expression macro because they are defined in the PostNewtonian.DerivedVariables module.\nPN expressions\nUnlike derived variables, these are not defined in terms of the fundamental variables, but they can be calculated in terms of both fundamental and derived variables.  These are generally the result of post-Newtonian expansions ‚Äî the most important examples being the flux ùìï, binding energy ùìî, and the waveform mode weights h! themselves.\nDynamics\nThis is where the ODE integration actually occurs, to evolve the orbital dynamics of the system.\nEvaluation\nFinally, we construct the waveforms themselves.  This level contains the main interface that will usually be used from Julia code, and should be restricted to fairly high-level functions like PNWaveform(M‚ÇÅ, M‚ÇÇ, ...), while still handling the full range of options that will be present in \"Dynamics\", for example.\nCompatibility layers\nThis is an optional level of abstraction that allows us to wrap the evaluation layer in functions that are designed to look and act more like other packages' functions.  As of this writing, the only such layer is for GWFrames compatibility, but similar wrappers could certainly be added.","category":"page"},{"location":"internals/systems/#PN-systems","page":"PN systems","title":"PN systems","text":"","category":"section"},{"location":"internals/systems/","page":"PN systems","title":"PN systems","text":"PNSystem\nBBH\nBHNS\nNSNS\nSymbolicPNSystem\nsymbolic_pnsystem","category":"page"},{"location":"internals/systems/#PostNewtonian.PNSystem","page":"PN systems","title":"PostNewtonian.PNSystem","text":"PNSystem{T, PNOrder}\n\nBase type for all PN systems, such as BBH, BHNS, and NSNS.\n\nThese objects encode all essential properties of the binary, including its current state. As such, they can be used as inputs to the various fundamental and derived variables, as well as PN expressions and dynamics functions.\n\nAll subtypes should contain a state vector holding all of the fundamental variables for the given type of system.  The parameter T is the type of the state vector ‚Äî for example, Vector{Float64}.  PNOrder is a Rational giving the order to which PN expansions should be carried.\n\n\n\n\n\n","category":"type"},{"location":"internals/systems/#PostNewtonian.BBH","page":"PN systems","title":"PostNewtonian.BBH","text":"BBH{T, PNOrder}\n\nThe PNSystem subtype describing a binary black hole system.\n\nThe state vector here holds the fundamental variables M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, R, v, with the spins unpacked into three components each, and R unpacked into four ‚Äî for a total of 13 elements.\n\nOptionally, Œ¶ may also be tracked as the 14th element of the state vector.  This is just the integral of the orbital angular frequency Œ©, and holds little interest for general systems beyond a convenient description of how \"far\" the system has evolved.\n\n\n\n\n\n","category":"type"},{"location":"internals/systems/#PostNewtonian.BHNS","page":"PN systems","title":"PostNewtonian.BHNS","text":"BHNS{T, PNOrder}\n\nThe PNSystem subtype describing a black-hole‚Äîneutron-star binary system.\n\nThe state vector is the same as for a BBH.  There is an additional field Œª‚ÇÇ holding the (constant) tidal-coupling parameter of the neutron star.\n\nNote that the neutron star is always object 2 ‚Äî meaning that M‚ÇÇ, œá‚Éó‚ÇÇ, and Œª‚ÇÇ always refer to it; M‚ÇÅ and œá‚Éó‚ÇÅ always refer to the black hole.  See also NSNS.\n\n\n\n\n\n","category":"type"},{"location":"internals/systems/#PostNewtonian.NSNS","page":"PN systems","title":"PostNewtonian.NSNS","text":"NSNS{T, PNOrder}\n\nThe PNSystem subtype describing a neutron-star‚Äîneutron-star binary system.\n\nThe state vector is the same as for a BBH.  There are two additional fields Œª‚ÇÅ and Œª‚ÇÇ holding the (constant) tidal-coupling parameters of the neutron stars.  See also BHNS.\n\n\n\n\n\n","category":"type"},{"location":"internals/systems/#PostNewtonian.SymbolicPNSystem","page":"PN systems","title":"PostNewtonian.SymbolicPNSystem","text":"SymbolicPNSystem{T, PNOrder}(state, Œª‚ÇÅ, Œª‚ÇÇ)\n\nA PNSystem that contains information as variables from Symbolics.jl.\n\nSee also symbolic_pnsystem for a particular general instance of this type.\n\n\n\n\n\n","category":"type"},{"location":"internals/systems/#PostNewtonian.symbolic_pnsystem","page":"PN systems","title":"PostNewtonian.symbolic_pnsystem","text":"symbolic_pnsystem\n\nA symbolic PNSystem that contains symbolic information for all types of PNSystems.\n\nIn particular, note that this object has an (essentially) infinite PNOrder, uses the TaylorT1 approximant, and has nonzero values for quantities like Œª‚ÇÅ and Œª‚ÇÇ.  If you want different choices, you may need to call SymbolicPNSystem yourself, or even construct a different specialized subtype of PNSystem (it's not hard).\n\nExamples\n\njulia> using PostNewtonian: M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ\n\njulia> M‚ÇÅ(symbolic_pnsystem), M‚ÇÇ(symbolic_pnsystem)\n(M‚ÇÅ, M‚ÇÇ)\n\njulia> œá‚Éó‚ÇÅ(symbolic_pnsystem)\n + œá‚Éó‚ÇÅÀ£ùê¢ + œá‚Éó‚ÇÅ ∏ùê£ + œá‚Éó‚ÇÅ·∂ªùê§\n\njulia> œá‚Éó‚ÇÇ(symbolic_pnsystem)\n + œá‚Éó‚ÇÇÀ£ùê¢ + œá‚Éó‚ÇÇ ∏ùê£ + œá‚Éó‚ÇÇ·∂ªùê§\n\n\n\n\n\n","category":"constant"},{"location":"internals/fundamental_variables/","page":"Fundamental variables","title":"Fundamental variables","text":"CurrentModule = PostNewtonian.FundamentalVariables","category":"page"},{"location":"internals/fundamental_variables/#Fundamental-variables","page":"Fundamental variables","title":"Fundamental variables","text":"","category":"section"},{"location":"internals/fundamental_variables/","page":"Fundamental variables","title":"Fundamental variables","text":"These constitute the basic quantities needed to fully describe a PN binary system at any instant.  All other variables ‚Äî and ultimately all PN expressions ‚Äî may be expressed as functions of these.  In the docstrings below, pnsystem is an object of any type that subtypes PNSystem.","category":"page"},{"location":"internals/fundamental_variables/","page":"Fundamental variables","title":"Fundamental variables","text":"PostNewtonian.M‚ÇÅ\nPostNewtonian.M‚ÇÇ\nPostNewtonian.œá‚Éó‚ÇÅ\nPostNewtonian.œá‚Éó‚ÇÇ\nPostNewtonian.R\nPostNewtonian.v\nPostNewtonian.Œ¶\nPostNewtonian.Œª‚ÇÅ\nPostNewtonian.Œª‚ÇÇ","category":"page"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.M‚ÇÅ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.M‚ÇÅ","text":"M‚ÇÅ(pnsystem)\nM1(pnsystem)\n\nMass of object 1 in this system.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.M‚ÇÇ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.M‚ÇÇ","text":"M‚ÇÇ(pnsystem)\nM2(pnsystem)\n\nMass of object 2 in this system.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.œá‚Éó‚ÇÅ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.œá‚Éó‚ÇÅ","text":"œá‚Éó‚ÇÅ(pnsystem)\nchi1(pnsystem)\n\nDimensionless spin vector of object 1 in this system, as a QuatVec.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.œá‚Éó‚ÇÇ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.œá‚Éó‚ÇÇ","text":"œá‚Éó‚ÇÇ(pnsystem)\nchi2(pnsystem)\n\nDimensionless spin vector of object 2 in this system, as a QuatVec.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.R","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.R","text":"R(pnsystem)\n\nOrientation of the binary, as a Rotor.  This Rotor will rotate the zÃÇ vector to be along the orbital angular velocity vector and the xÃÇ vector to be along the separation vector pointing from object 2 to object 1.\n\nSee also nÃÇ, ŒªÃÇ, ‚ÑìÃÇ.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.v","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.v","text":"v(pnsystem)\nv(;Œ©, M=1)\n\nPost-Newtonian velocity parameter.  This is related to the orbital angular frequency Omega as\n\nv colonequals (MOmega)^13\n\nwhere M is the total mass of the binary.\n\nNote that if you want to pass the value Œ© (rather than a PNSystem), you must pass it as a keyword argument ‚Äî as in v(Œ©=0.1).\n\nSee also Œ©.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.Œ¶","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.Œ¶","text":"Œ¶(pnsystem)\nPhi(pnsystem)\n\nIntegrated orbital phase of the system.  It is computed as the integral of Œ©.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.Œª‚ÇÅ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.Œª‚ÇÅ","text":"Œª‚ÇÅ(pnsystem)\nlambda1(pnsystem)\n\nTidal coupling parameter of object 1 in this system.\n\nThis is related to the Love number k_2 and the star's radius R as\n\nlambda_1 = frac23 k_2 R^5\n\nThere is another common parameter denoted\n\nLambda_1 = frac32 fracM_1M_2 lambda_1\n\nNote that ‚Äî as of this writing ‚Äî only NSNS systems can have a nonzero value for this quantity.  All other types return 0, which Julia can use to eliminate code that would then be 0.  Thus, it is safe and efficient to use this quantity in any PN expression that specializes on the type of pnsystem.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.Œª‚ÇÇ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.Œª‚ÇÇ","text":"Œª‚ÇÇ(pnsystem)\nlambda2(pnsystem)\n\nTidal coupling parameter of object 2 in this system.\n\nThis is related to the Love number k_2 and the star's radius R as\n\nlambda_2 = frac23 k_2 R^5\n\nThere is another common parameter denoted\n\nLambda_2 = frac32 fracM_2M_1 lambda_2\n\nNote that ‚Äî as of this writing ‚Äî only BHNS and NSNS systems can have a nonzero value for this quantity.  All other types return 0, which Julia can use to eliminate code that would then be 0.  Thus, it is safe and efficient to use this quantity in any PN expression that specializes on the type of pnsystem.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#Computing-the-waveform","page":"Waveforms","title":"Computing the waveform","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"Once you have computed the orbital evolution, and selected the time steps on which you want to evaluate the waveform, you can do so with one of the functions documented below.","category":"page"},{"location":"internals/waveforms/#Precise-definition-of-waveforms","page":"Waveforms","title":"Precise definition of waveforms","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"The waveform returned by these functions is essentially the complex strain h colonequals h_+ - ih_times.  However, this quantity decays as 1r, where r is the radius at which the strain is measured.  Therefore, as is conventional, the returned quantity is actually","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"H colonequals lim_rtoinfty h fracrM fracc^2G","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"where M is the total mass of the two objects in the binary.  Note that both h and H are dimensionless, but only H is scale invariant.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"Binaries are usually modeled in relativity as being isolated systems in otherwise empty asymptotically flat spacetimes ‚Äî or even more specifically, in asymptotically Minkowski spacetimes.  In this case, r is just the asymptotic areal radius.  The equivalent expression in an FLRW spacetime requires a simple reinterpretation of M as the redshifted mass M_z colonequals M(1+z) and r as the luminosity distance d_L[1]  Thus, to obtain the strain as it would be measured (in the asymptotic approximation) by an actual observer in an asymptotically flat universe or in our universe, we just need to invert the previous equation:","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"h approx H fracMr fracGc^2\nqquad mathrmor qquad\nh approx H fracM_zd_L fracGc^2","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"[1]: Note that we use \"luminosity distance\" as it is understood in   contemporary cosmology, which is   unfortunately different from its meaning in older cosmology literature,   and even some of the gravitational-wave astronomy literature from before   2015 or so.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"Furthermore, H is a function of coordinates (t theta phi).  The dependence on t will be discretely sampled at the times t_i that are present in the inspiral arguments to the functions below.  To handle the angular dependence, we provide the waveform decomposed as mode weights in a spin-weighted spherical-harmonic decomposition, so that the actual quantity returned will be","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"H_ellm(t_i)\ncolonequals\nint H(t theta phi) _-2barY_ellm(theta phi)\nsintheta dtheta dphi","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"The output array is a two-dimensional complex array.  The first dimension varies over (ellm) values, with m varying most rapidly ‚Äî as in","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"[(‚Ñì,m) for ‚Ñì ‚àà ‚Ñì‚Çò·µ¢‚Çô:‚Ñì‚Çò‚Çê‚Çì for m ‚àà -‚Ñì:‚Ñì]","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"The second dimension of the array indexes the time.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"See Example 2 on the \"Units\" page for a complete example of converting this package's output to standard units in our universe.","category":"page"},{"location":"internals/waveforms/#Evaluation-of-waveforms","page":"Waveforms","title":"Evaluation of waveforms","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"coorbital_waveform\ninertial_waveform","category":"page"},{"location":"internals/waveforms/#PostNewtonian.coorbital_waveform","page":"Waveforms","title":"PostNewtonian.coorbital_waveform","text":"coorbital_waveform(inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])\ncoorbital_waveform(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the co-orbital frame for the given inspiral output by orbital_evolution.\n\nSee also inertial_waveform for the waveform in the inertial frame.\n\nFor a detailed description of the format and physical interpretation of the returned quantity, see the \"Waveforms\" section of the manual.\n\nThe PNOrder defaults to the one used to compute inspiral, but may be changed by passing the keyword argument.\n\ntip: Tip\nIf you need this waveform at a different set of times t‚Ä≤ than is currently present in inspiral.t, you should use the built-in interpolation capabilities of inspiral first, as in inspiral‚Ä≤ = inspiral(t‚Ä≤), rather than interpolating the results of this function.  Or, perhaps better yet, you could select the times when calling orbital_evolution by using the saves_per_orbit or saveat keyword argument to that function.  These approaches will be more accurate, faster, and require less memory than interpolating the result of this function.  If using saves_per_orbit, you probably want to set it to at least 2‚Ñì‚Çò‚Çê‚Çì, or preferably 4‚Ñì‚Çò‚Çê‚Çì.\n\nThe mode weights are given starting at ‚Ñì‚Çò·µ¢‚Çô (which must satisfy 0 ‚â§ ‚Ñì‚Çò·µ¢‚Çô ‚â§ 2) and extending through ‚Ñì‚Çò‚Çê‚Çì.  The waveform is returned as a 2-dimensional Array, in which the first index varies over the mode index from (‚Ñì, m) = (‚Ñì‚Çò·µ¢‚Çô, -‚Ñì‚Çò·µ¢‚Çô) to (‚Ñì, m) = (‚Ñì‚Çò‚Çê‚Çì, ‚Ñì‚Çò‚Çê‚Çì), with m varying most rapidly, and the second index varying over the time steps.\n\nIn this function, the waveform is returned in the co-orbital frame ‚Äî which is somewhat like the co-rotating frame.  In particular, the modes of non-precessing systems vary slowly, over inspiral timescales; modes of precessing systems still vary on orbital timescales, though even this variation could be factored out.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.inertial_waveform","page":"Waveforms","title":"PostNewtonian.inertial_waveform","text":"inertial_waveform(inspiral, [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])\ninertial_waveform(inspiral, [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the inertial frame for the given inspiral output by orbital_evolution.\n\nThe inertial frame is the one in which inertial observers are found, so this waveform is more like one that actual observers would detect.  This function transforms the waveform from the co-orbital frame ‚Äî which is the one in which PN expressions are provided.\n\nSee coorbital_waveform for details about the other arguments and returned quantity.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#In-place-evaluation-of-waveforms","page":"Waveforms","title":"In-place evaluation of waveforms","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"This is likely to be an uncommon scenario, but if you happen to need to evaluate the waveform repeatedly on the same set (or at least same number) of time steps and same range of ell values, then you can pre-allocate the storage needed in this process, and re-use that storage.  To do so, pre-allocate using either coorbital_waveform_computation_storage or inertial_waveform_computation_storage, and then pass the result as the first argument to either coorbital_waveform! or inertial_waveform!.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"note: Note\nThe h array returned by either coorbital_waveform! or inertial_waveform! is part of the pre-allocated storage.  You need to use its values before you call either of those functions again, or those values will just be overwritten.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"coorbital_waveform_computation_storage\ninertial_waveform_computation_storage\ncoorbital_waveform!\ninertial_waveform!","category":"page"},{"location":"internals/waveforms/#PostNewtonian.coorbital_waveform_computation_storage","page":"Waveforms","title":"PostNewtonian.coorbital_waveform_computation_storage","text":"coorbital_waveform_computation_storage(inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])\ncoorbital_waveform_computation_storage(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nConstruct storage needed to compute waveforms in the co-orbital frame without allocations.\n\nThis returns the storage for the waveforms themselves and PNSystem used as temporary storage.  The returned quantity can just be passed as the first argument to coorbital_waveform! without being unpacked.\n\nThe meaning of the arguments is the same as in coorbital_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.inertial_waveform_computation_storage","page":"Waveforms","title":"PostNewtonian.inertial_waveform_computation_storage","text":"inertial_waveform_computation_storage(inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])\ninertial_waveform_computation_storage(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nConstruct storage needed to compute waveforms in the inertial frame without allocations.\n\nThis returns the storage for the waveforms themselves, storage used for computing the Wigner ùîá matrices, and for \"in-place\" multiplication.  The returned quantity can just be passed as the first argument to inertial_waveform! without being unpacked.\n\nThe meaning of the arguments is the same as in inertial_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.coorbital_waveform!","page":"Waveforms","title":"PostNewtonian.coorbital_waveform!","text":"coorbital_waveform!(storage, inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])\ncoorbital_waveform!(storage, inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the co-orbital frame for the given inspiral output by orbital_evolution, using pre-allocated storage.\n\nThe storage is assumed to be the object returned from coorbital_waveform_computation_storage.  Other arguments are the same as in coorbital_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.inertial_waveform!","page":"Waveforms","title":"PostNewtonian.inertial_waveform!","text":"inertial_waveform!(storage, inspiral; [‚Ñì‚Çò·µ¢‚Çô=2], [‚Ñì‚Çò‚Çê‚Çì=8], [PNOrder])\ninertial_waveform!(storage, inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the inertial frame for the given inspiral output by orbital_evolution, using pre-allocated storage.\n\nThe storage is assumed to be the object returned from inertial_waveform_computation_storage.  Other arguments are the same as in inertial_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/pn_expressions/#PN-expressions","page":"PN expressions","title":"PN expressions","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"These are collected from numerous sources in the literature.  The docstrings below provide the relevant citations.","category":"page"},{"location":"internals/pn_expressions/#Binding-energy","page":"PN expressions","title":"Binding energy","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/binding_energy.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.ùìî-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.ùìî","text":"ùìî(pnsystem)\nbinding_energy(pnsystem)\n\nCompute the gravitational binding energy of a compact binary.\n\nNote that this may not be as useful as its derivative, ùìî‚Ä≤, which is used as part of the right-hand side for orbital evolutions.\n\nThe nonspinning orbital binding energy is known through 4pN.  The expressions through 3.5pN here come from Eq. (233) of Blanchet (2014).\n\nThe 4pN term from Eq. (5.2d) of Jaranowski and Sch√§fer is known exactly, now that the ŒΩ-linear piece is given as Eq. (32) of Bini and Damour (2013a).  The remaining terms are not known exactly, but Bini and Damour (2013b) have derived some terms, though there is incomplete information, which are noted as the constants in this code.\n\nThe spin-squared terms (by which I mean both spin-spin and spin-orbit squared terms) in the energy are known only at 2pN order (from Kidder (1995) and Will and Wiseman (1996)).  They are most conveniently given in Eq. (C4) of Arun et al.\n\nThe spin-orbit terms in the energy are now complete to 4.0pN (the last term is zero).  These terms come from Eq. (4.6) of Boh√© et al. (2012).\n\nThe tidal-coupling terms come in to the binding energy at relative 5pN order, and are known to 6pN order.  These terms come from Eq. (2.11) of Vines et al. (2011).  Note their unusual convention for mass ratios, where œá‚ÇÅ = m‚ÇÅm in their notation; in particular, œá is not a spin parameter.  Also note that Œª = Œª‚ÇÇ v^10(m‚ÇÅ+m‚ÇÇ)^5, and we need to add the coupling terms again with 1  2.  Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.ùìî‚Ä≤","page":"PN expressions","title":"PostNewtonian.ùìî‚Ä≤","text":"ùìî‚Ä≤(pnsystem)\nbinding_energy_deriv(pnsystem)\n\nCompute the derivative with respect to v of the binding energy of a compact binary.\n\nThis is computed symbolically from ùìî; see that function for details.\n\n\n\n\n\n","category":"function"},{"location":"internals/pn_expressions/#Flux","page":"PN expressions","title":"Flux","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/flux.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.ùìï-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.ùìï","text":"ùìï(pnsystem)\ngw_energy_flux(pnsystem)\n\nCompute the gravitational-wave energy flux to infinity\n\nThe nonspinning flux terms are complete to 3.5pN order.  These terms are given by Eq. (314) of Blanchet (2014).\n\nThe spin-squared terms (by which I mean both spin-spin and spin-orbit squared terms) in the flux are known only at 2pN order (from Kidder (1995) and Will and Wiseman (1996)).  They are most conveniently given in Eq. (C10) of Arun et al. (2008)\n\nThe spin-orbit terms in the flux are now known to 4.0pN.  These terms come from Eq. (4.9) of Marsat et al. (2013)\n\nBeyond 3.5pN, terms other than the 4.0pN spin-orbit are only known in the extreme-mass-ratio limit.  These terms are given in Appendix A of Fujita (2012).  He computed them up to 22pN.  That seems like overkill, so we'll just go up to 6pN.\n\nFor systems with matter, the tidal-heating terms come in at relative 5pN order, and are known partially at 6pN order.  These terms come from Eq. (3.6) of Vines et al. (2011).  Note their unusual convention for mass ratios, where œá‚ÇÅ = m‚ÇÅm in their notation; in particular, œá is not a spin parameter.  Also note that Œª = Œª‚ÇÇ v^10(m‚ÇÅ+m‚ÇÇ)^5, and we need to add the coupling terms again with 1  2.  Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Tidal-heating","page":"PN expressions","title":"Tidal heating","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/tidal_heating.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.tidal_heating-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.tidal_heating","text":"tidal_heating(pnsystem)\n\nCompute the rate of energy and angular-momentum absorption into each black hole in a binary.\n\nThe returned quantity is a tuple (SÃá‚ÇÅ, MÃá‚ÇÅ, SÃá‚ÇÇ, MÃá‚ÇÇ), representing the corresponding rates of change of spin (magnitude) and mass on black hole 1 and black hole 2.  These apply to general ‚Äî possibly precessing ‚Äî non-eccentric binaries.  This collection of terms comes from Alvi (2001).  It probably wouldn't be too hard to extend Alvi's analysis to eccentric systems.\n\nNote that the validity of the result depends not only on the PN parameter v, but also on the angles of the spins relative to the separation vector n: the smaller the angle, the lower the v at which the approximations should be expected to break down.\n\nSee also\n\nTagoshi and Sasaki (1994)\nPoisson and Sasaki (1995)\nTagoshi et al. (1997)\nChatziioannou et al. (2012)\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Precession","page":"PN expressions","title":"Precession","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/precession.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.a‚Çó-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.a‚Çó","text":"a‚Çó(pnsystem)\n\nEq. (4.4) of Boh√© et al. (2013).  This term contributes to ùõ°.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Œ©‚Éó·µ™-NTuple{7, Any}","page":"PN expressions","title":"PostNewtonian.Œ©‚Éó·µ™","text":"Œ©‚Éó·µ™(M‚±º, M‚Çñ, œá‚Éó‚±º, œá‚Éó‚Çñ, R)\n\nCompute the angular velocity of precession of spin vector œá‚Éó‚±º.\n\nIn the approximation that the spin magnitude is constant, the time derivative of œá‚±º is due to its rotation alone, and is given by Œ©·µ™  œá‚±º.\n\nNote that this function is called by Œ©‚Éó·µ™‚ÇÅ and Œ©‚Éó·µ™‚ÇÇ with the appropriate parameters; you probably want to use those instead of this one.\n\nThe spin-spin term is given by Eq. (2.4) of Kidder (1995); the spin-orbit terms by Eq. (4.5) of Boh√© et al. (2013); and the quadrupole-monopole term by Eq. (2.7) Racine (2008).\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Œ©‚Éó·µ™‚ÇÅ-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.Œ©‚Éó·µ™‚ÇÅ","text":"Œ©‚Éó·µ™‚ÇÅ(pnsystem)\n\nCompute the angular velocity of precession of œá‚Éó‚ÇÅ\n\nIn the approximation that the spin magnitude is constant, the time derivative of œá‚ÇÅ is due to its rotation alone, and is given by Œ©·µ™‚ÇÅ  œá‚ÇÅ.\n\nNote that this function simply calls Œ©‚Éó·µ™ with the appropriate parameters.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Œ©‚Éó·µ™‚ÇÇ-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.Œ©‚Éó·µ™‚ÇÇ","text":"Œ©‚Éó·µ™‚ÇÇ(pnsystem)\n\nCompute the angular velocity of precession of œá‚Éó‚ÇÇ\n\nIn the approximation that the spin magnitude is constant, the time derivative of œá‚ÇÇ is due to its rotation alone, and is given by Œ©·µ™‚ÇÇ  œá‚ÇÇ.\n\nNote that this function simply calls Œ©‚Éó·µ™ with the appropriate parameters.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Œ©‚Éó‚Çö-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.Œ©‚Éó‚Çö","text":"Œ©‚Éó‚Çö(pnsystem)\n\nCompute the angular velocity of orbital precession.\n\nThis is the angular velocity of the orbital angular velocity direction unit vector ‚Ñì; the time derivative of that unit vector is Œ©‚Çö  ‚Ñì.\n\nAt the moment, this is computed solely by expressions from Boh√© et al. (2013).  See ùõ° for details.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Œ≥‚Çö-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.Œ≥‚Çö","text":"Œ≥‚Çö(pnsystem)\n\nEq. (4.3) of Boh√© et al. (2013).  This term contributes to ùõ°.\n\nNote that there is a 3PN term of -22ŒΩln(rr‚ÇÄ)3 that is simply ignored here.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.ùõ°-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.ùõ°","text":"ùõ°(pnsystem)\n\nCompute the angular velocity of orbital precession according to Boh√© et al.\n\nAs Boh√© et al. (2013) explain above their Eq. (4.1), the orbital precession is given by the time derivative of the orbital axis: ùìµÃá = ùõ° √ó ùìµ, where the angular velocity is along the separation vector ùì∑, so that ùõ° = œñ ùì∑.  And in turn, they define a‚Çó ‚âî r œâ œñ, where r is the separation and œâ is the orbital angular frequency. Then, they define the PN parameter Œ≥‚Çö‚âîM/r and we have Mœâ = v¬≥ so that œñ = Œ≥‚Çö a‚Çó / v¬≥.  The parameters Œ≥‚Çö and a‚Çó are given by Eqs. (4.3) and (4.4), and given here by the functions Œ≥‚Çö and a‚Çó.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Mode-weights","page":"PN expressions","title":"Mode weights","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/mode_weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.h!-Tuple{Any, Any}","page":"PN expressions","title":"PostNewtonian.h!","text":"h!(h, pnsystem; ‚Ñì‚Çò·µ¢‚Çô=0, ‚Ñì‚Çò‚Çê‚Çì=typemax(Int))\nmode_weights!(h, pnsystem; ‚Ñì‚Çò·µ¢‚Çô=0, ‚Ñì‚Çò‚Çê‚Çì=typemax(Int))\n\nCompute mode weights of gravitational waves emitted by pn system, modifying h in place.\n\nnote: Note\nThis is a low-level function; you probably don't want to use this directly.  See coorbital_waveform or inertial_waveform for more user-friendly functions.\n\nThese modes are computed in the \"co-orbital\" frame, in which the larger object lies on the positive x axis, the smaller lies on the negative x axis, and the instantaneous angular velocity is in the positive z direction.\n\nThe modes are stored in h in order of increasing ‚Ñì and increasing m, with m iterating fastest, all the way up to the highest available mode, (88).\n\nBecause gravitational waves have spin weight -2, the (‚Ñìm)=(00), (1-1), (10), and (11) modes are always 0.  By default, we assume that these modes are nonetheless included in h.  If that is not the case, set ‚Ñì‚Çò·µ¢‚Çô to the smallest ‚Ñì value that should be present in the output data ‚Äî ‚Ñì‚Çò·µ¢‚Çô=2 being the most reasonable alternative.\n\nAll non-spinning terms are taken from Blanchet (2014).  The 1PN spin-orbit term is from Eq. (3.22d) of Kidder (1995).  The 1.5PN spin-orbit term is from Eq. (3.22f) of Kidder (1995) and Eq. (F15b) of Will and Wiseman (1996).  The 2PN spin-orbit term is from Eq. (4.13) of Buonanno, Faye, Hinderer (2013), while the 2PN spin-spin term is from Eq. (4.15) of that reference.\n\n\n\n\n\n","category":"method"},{"location":"interface/differentiation/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"interface/differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"While symbolic differentiation can be useful in many important scenarios, it is not very helpful for providing derivatives of general evolved waveforms, because waveforms require integration of ODEs.  However, Julia is quite capable of automatically differentiating even through an ODE integration ‚Äî both gradients and Hessians ‚Äî with respect to any or all of the initial conditions.","category":"page"},{"location":"interface/differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"There are many automatic differentiation packages in Julia.  Zygote will most likely be the best in the not-too-distant future, but at the time of writing, the simplest approach is to use ForwardDiff.jl.  A simple wrapper function that takes only the arguments to be differentiated may be needed.  The returned quantity will be a vector of waveforms corresponding to the derivative in the waveform at each instant with respect to the desired parameters.","category":"page"},{"location":"interface/differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"More broadly, it can also be helpful to differentiate a function of a waveform.  For example, if we are trying to minimize the difference between a waveform and a PN waveform, we may have a cost function that takes (some or all of) the PN parameters integrates the L^2 norm of the difference between them.  This cost function should be easily differentiable as well.","category":"page"},{"location":"interface/high-level/#High-level-interface","page":"High-level interface","title":"High-level interface","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"The typical workflow for users of this package will involve two or three steps:","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Integrate the orbital dynamics of a black-hole binary using the orbital_evolution function.\n(Optional) If not specified in step 1, choose the time steps on which you want the waveform.\nCompute the waveform as a function of the orbital dynamics using the inertial_waveform (or coorbital_waveform) function.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Here, we'll work through an example, and provide some more details.","category":"page"},{"location":"interface/high-level/#.-Integrate-orbital-dynamics","page":"High-level interface","title":"1. Integrate orbital dynamics","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"First, we have to specify the initial masses, spins, and orbital angular frequency.  Let's arbitrarily choose something close to a hangup-kick configuration.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"using PostNewtonian\n\n# Initial values of the masses, spins, and orbital angular frequency\nM‚ÇÅ = 0.6\nM‚ÇÇ = 0.4\nœá‚Éó‚ÇÅ = [0.7, 0.1, 0.7]\nœá‚Éó‚ÇÇ = [-0.7, 0.1, 0.7]\nŒ©·µ¢ = 0.01\n\ninspiral = orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢)\nnothing;  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"There are also numerous optional keyword arguments to orbital_evolution, controlling things like the range of frequencies over which to integrate (including possibly both forwards and backwards from the initial values), accuracy of the ODE integration, the PN order at which to compute the evolution equations, and so on.  See that function's documentation for details.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"The returned object named inspiral here is an ODESolution with many features, like high-order interpolation (using dense output from the ODE integrator).  The time steps at which the solution was saved are available as inspiral.t, and the evolved variables are available as inspiral.u, or by their names as in inspiral[:v] or inspiral[:Œ¶].  For example, we can plot the components of the spin of object 1 like this:","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"using Plots  # Requires also installing `Plots` in your project\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=2, leg=:top)  # hide\n\nplot(inspiral.t, inspiral[:œá‚Éó‚ÇÅÀ£], label=raw\"$\\vec{\\chi}_1^x$\")\nplot!(inspiral.t, inspiral[:œá‚Éó‚ÇÅ ∏], label=raw\"$\\vec{\\chi}_1^y$\")\nplot!(inspiral.t, inspiral[:œá‚Éó‚ÇÅ·∂ª], label=raw\"$\\vec{\\chi}_1^z$\")\nplot!(xlabel=\"Time (ùëÄ)\", ylabel=\"Dimensionless spin components\")\nsavefig(\"inspiral_spins.html\"); nothing  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"<iframe src=\"inspiral_spins.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"As expected, we see significant precession of the spin on long time scales, as well as smaller nutations on orbital time scales visible mostly at later times.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"The evolved variables, in order, are","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"join(stdout, PostNewtonian.pnsystem_symbols, \", \")  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"They can be accessed by their symbols, like the spins above, or by their number in this list.  To access the ith variable at time step j, use sol[i, j]. You can also use colons: sol[i, :] is a vector of the ith variable at all times, and sol[:, j] is a vector of all the data at time step j.  For example, inspiral[:œá‚Éó‚ÇÅÀ£] could also be written as inspiral[3, :].","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"By default, the output of orbital_evolution is just the time steps to which the adaptive ODE integrator happened to step.  If you know that you want the solution on a set of uniform time steps separated by dt ‚Äî such as when you need to FFT the waveform ‚Äî you can pass the option saveat=dt.  Or, if you somehow know the specific set of times t at which you want the solution, you can pass saveat=t.  Finally, if you want the solution ‚Äî say ‚Äî 32 times per orbit, you can pass the option saves_per_orbit=32, which calls uniform_in_phase as needed.","category":"page"},{"location":"interface/high-level/#.-(Optional)-Choose-time-steps","page":"High-level interface","title":"2. (Optional) Choose time steps","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"If you did not pass the saveat or saves_per_orbit arguments to orbital_evolution (as described in the previous paragraph), the output will usually be on a fairly coarse set of times ‚Äî possibly many times the orbital period for non-precessing systems.  However, in this case the solution will come with \"dense output\", which lets us quickly and accurately interpolate the solution to a new set of times.  This is important if you want the waveform to be sampled at the \"local\" Nyquist rate; anything less and the waveform will be distorted by aliasing.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"For instance, suppose we want to plot the results every 05M for the last 5000M of the data.  We could define the new set of times as","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"t‚Ä≤ = inspiral.t[end]-5_000 : 0.5 : inspiral.t[end]\nnothing;  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"and then interpolate to this new set of times as","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"inspiral = inspiral(t‚Ä≤)\nnothing  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"We couldn't have achieved quite the same effect with the saveat argument mentioned above because in this case, we wanted to know the point at which we were 5000M before the end of the inspiral.  In general, if you need the results of orbital_evolution before you can decide what you want t‚Ä≤ to be, this is the approach you'll have to take.","category":"page"},{"location":"interface/high-level/#.-Compute-the-waveform","page":"High-level interface","title":"3. Compute the waveform","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Usually, we will also want the actual waveform from this system.  We can just call inertial_waveform (or coorbital_waveform for the waveform in a rotating frame in which the binary is stationary).","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"h = inertial_waveform(inspiral)\nnothing;  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Again, we can plot the result:","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"plot(inspiral.t, real.(h[1, :]), label=raw\"$\\Re\\left\\{h_{2,2}\\right\\}$\")\nplot!(inspiral.t, imag.(h[1, :]), label=raw\"$\\Im\\left\\{h_{2,2}\\right\\}$\")\nplot!(inspiral.t, abs.(h[1, :]), label=raw\"$\\left|h_{2,2}\\right|$\", linewidth=3)\nplot!(xlabel=\"Time (ùëÄ)\", ylabel=\"Mode weights\", ylim=(-0.5,0.5))\nsavefig(\"waveform.html\"); nothing  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"<iframe src=\"waveform.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"We see oscillations in the amplitude of the h_22 mode on the orbital timescale, which is to be expected in a hangup-kick scenario as the system alternates between beaming power preferentially along the +z and -z directions.","category":"page"},{"location":"interface/interface/#High-level-functions","page":"High-level functions","title":"High-level functions","text":"","category":"section"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"Most users will just want to evaluate the PN orbital evolution and/or the waveform.  Though these were both touched on briefly in the \"Quick start\" section and are extensively documented in their corresponding docstrings, we highlight some of the more useful features here.","category":"page"},{"location":"interface/interface/#Orbital-evolution","page":"High-level functions","title":"Orbital evolution","text":"","category":"section"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"A post-Newtonian inspiral is computed by the orbital_evolution function.","category":"page"},{"location":"interface/interface/#Orbital_evolution_Input_arguments","page":"High-level functions","title":"Input arguments","text":"","category":"section"},{"location":"interface/interface/#Time-steps","page":"High-level functions","title":"Time steps","text":"","category":"section"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"The default output contains just the times to which the ODE integrator stepped, which can be very coarsely sampled.  In particular, if you evaluate the inertial-frame waveform on these time steps, it will almost surely be sampled far below the Nyquist limit, which will generally render the waveform useless.","category":"page"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"There are three useful approaches to deal with this:","category":"page"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"Do nothing on input, but interpolate the output inspiral object to some desired time steps using its built-in interpolation capabilities.  This uses the \"dense output\" results of the ODE integrator, which produces very efficient and accurate results.  This is a very good option if the following two are not applicable, especially if you need to know the PN evolution before you can decide on the time steps you want.  See the \"Output\" section below for details.\nIf you want to ensure that each orbit is sampled a certain number of times, you can pass the saves_per_orbit option to orbital_evolution.\nIf you want the results with some fixed uniform time step dt, you can just pass the option saveat=dt to orbital_evolution.\nIf you happen to know specific times t at which you want the result, you can pass the option saveat=t to orbital_evolution.  This may be relevant, for example, when comparing the PN waveform to an existing waveform.  Note that the inspiral may end earlier than your last t value, in which case the output will just be shorter than requested.","category":"page"},{"location":"interface/interface/#When-to-stop","page":"High-level functions","title":"When to stop","text":"","category":"section"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"Once the equations have been entered correctly, the hardest part about PN orbital evolution is deciding when to stop.  We know that PN approximations fail somewhere below v=1.  In practice, especially at higher orders, the equations frequently for v approx 05, and can fail as early as v approx 04.  The breakdown point typically depends on many factors, such as the masses and spins of the binary, the PN order at which expressions are truncated, and the approximant used to integrate the orbit.","category":"page"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"But wherever this breakdown lies, as the ODE integrator approaches the breakdown, it works harder to maintain accurate evolution of the equations it has been given ‚Äî even though the equations themselves are no longer trustworthy.  In fact, a majority of the ODE integrator's time may be spent trying to evolve the last fraction of an orbit as the integrator takes smaller and smaller time steps to maintain accuracy in a regime where we shouldn't believe PN itself.  Loosening the abstol and/or reltol requirements would make the rest of the inspiral less accurate, but still wouldn't improve this situation very much.","category":"page"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"Ideally, you should pick some frequency below the default value (which corresponds to v=1) to let the ODE integration stop before it gets too close to the breakdown point.  You can pass this lower value as the Œ©‚Çë argument to orbital_evolution.  For example, a value corresponding to v=03 would be unlikely to run into problems ‚Äî except perhaps in very obscure corners of parameter space.","category":"page"},{"location":"interface/interface/#Orbital_evolution_Output","page":"High-level functions","title":"Output","text":"","category":"section"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"inspiral","category":"page"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"inspiral.t\ninspiral[:, j]\ninspiral[i, j]\ninspiral[i, :]\ninspiral(t‚Ä≤)\ninspiral(t‚Ä≤, Val{1})  # Up to Val{4}\ninspiral(t‚Ä≤, Val{1}, idxs=[:M‚ÇÅ, :M‚ÇÇ])\ninspiral[:v]\ninspiral[[:v, :Œ¶], :] Note that there is no translation for this in Python (because of Unicode and because of the Symbol syntax), but we can use the following from Python:\nPNVariable.(inspiral.u)","category":"page"},{"location":"interface/interface/#Waveform","page":"High-level functions","title":"Waveform","text":"","category":"section"},{"location":"interface/interface/","page":"High-level functions","title":"High-level functions","text":"coorbital_waveform / inertial_waveform","category":"page"},{"location":"interface/interface/#Waveform_Input_arguments","page":"High-level functions","title":"Input arguments","text":"","category":"section"},{"location":"interface/interface/#Waveform_Output","page":"High-level functions","title":"Output","text":"","category":"section"},{"location":"adding_terms/#Adding-new-PN-terms-or-expressions","page":"Adding terms","title":"Adding new PN terms or expressions","text":"","category":"section"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"danger: Cite your sources!\nRemember that it is absolutely crucial to record the source of any expressions in the relevant docstrings, including a link to the relevant paper.  If the terms or expressions in a given function come from more than one source, use comments inside the code itself to clarify exactly which parts come from which source.","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"The first step in actually adding new information is to decide where it fits in the hierarchy described in the \"Code structure\" page.  Most likely, you will want to add new terms to existing PN expressions, and possibly simple functions in PostNewtonian.DerivedVariables.","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"Existing code should be a good guide on how to do this.  However, it may appear as if some magic is happening in the various PN expressions, whereby variables like M‚ÇÅ, œá‚Éó‚ÇÇ, ŒΩ, ŒªÃÇ, etc., can be used without being defined.  These are automatically computed by way of the @pn_expression macro.  Also note that to correctly truncate a PN expansion at the desired order, the @pn_expansion macro must be used.","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"To make it easier to compare code to original sources, we also want to keep the code looking as similar as possible to equations as given in those sources, so try to keep variable names the same, and order things in the same ways as in the sources.  (Don't worry about rewriting expressions to optimize evaluation; Julia will probably do a better job automatically anyway.)  There are, however, a few important exceptions to this rule:","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"We use a PN-expansion parameter v, instead of x.  Consistency with this is important to simplify our treatment of PN expressions symbolically.  This isn't too difficult, because v ‚Üî ‚àöx is easy to do visually.  Just remember that ln(x) = 2ln(v).\nIt should be possible to evaluate PN expressions using different precisions.  To ensure this, enter fractions as Irrationals ‚Äî e.g., 3//2 instead of 3/2.  The latter would be immediately converted to the 64-bit float 1.5, which would poison other values.  Note that if you are multiplying by something else that already has general float type, as in 3œÄ/2, you don't need to use Irrational; in this case, 3œÄ is evaluated first and achieves full precision, and is then divided by the exact integer 2, so that it retains full precision.\nA slight caveat to the above is that an expression like 3Œª/2 could still be converted to Float64 if Œª is defined at compile time to be 0.  For type-stability reasons, Julia will always treat 0/2 just like it would treat 7/2, which is converted to Float64.  Thus, it is probably safest to write expressions like 3//2 * Œª.\nIf you happen to use any other math functions, similarly ensure that their arguments are converted appropriately to retain precision.  For unary functions, this can be done automatically by including the function name in the unary_funcs list used by @pn_expression.","category":"page"},{"location":"interface/units/#A-note-about-units","page":"Units","title":"A note about units","text":"","category":"section"},{"location":"interface/units/","page":"Units","title":"Units","text":"note: TL;DR:\nThis package uses geometric units with G=c=1.  Units are essentially determined by the values you input.  Masses and frequencies in particular must have inverse units.  For example, if frequency is measured in Hertz, mass should be measured in seconds.  The common relativist's convention of measuring in units of \"total mass\" (whatever that means to you) is also perfectly fine.Output time is in units of the total mass; to get the time in seconds, multiply by the total mass as measured in seconds.  Waveforms are output as the asymptotic quantity rhM; to get an observable strain, multiply by the total mass and divide by the distance to the source.You may want to skip to Example 2 for a complete example using astrophysical units.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The units of measurement used in this package are implicitly established by the input.  Specifically, the arguments M‚ÇÅ, M‚ÇÇ, and Œ©·µ¢ in the call","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral = orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"are inherently dimensionful, and the units are effectively determined by the values entered.  For example, if we enter 0.4 as M‚ÇÅ, we have established the units as ‚Äî quite simply ‚Äî those units in which M‚ÇÅ has the value 0.4.  The only real requirement on the units of the input arguments is that they must be consistent.  In particular, the quantity (M‚ÇÅ+M‚ÇÇ)*Œ©·µ¢ should be dimensionless.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"It must also be noted that this package uses geometric units where G=c=1; in fact, G and c never appear in the code at all.  This means that you must input values in geometric units, and interpret the output as being in geometric units.  This does not completely constrain the units, however.  There is still a freedom to scale the units however you wish.  For example, it is most common to describe all quantities in units of some mass M ‚Äî such as the sum of the input masses M‚ÇÅ+M‚ÇÇ or the Solar mass M_odot.  The input arguments would then all be given in units of that mass, or more likely some product of that mass with G and c.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The complete set of (required or optional) dimensionful arguments to orbital_evolution is","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"M‚ÇÅ, M‚ÇÇ, Œ©·µ¢, Œª‚ÇÅ, Œª‚ÇÇ, Œ©‚ÇÅ, Œ©‚Çë, abstol, saveat","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"If we scale the values by some œÉ, then to maintain the same physical meaning we should transform all the arguments as","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"M‚ÇÅ ‚Ü¶ M‚ÇÅ * œÉ\nM‚ÇÇ ‚Ü¶ M‚ÇÇ * œÉ\nŒ©·µ¢ ‚Ü¶ Œ©·µ¢ / œÉ\nŒª‚ÇÅ ‚Ü¶ Œª‚ÇÅ * œÉ^5\nŒª‚ÇÇ ‚Ü¶ Œª‚ÇÇ * œÉ^5\nŒ©‚ÇÅ ‚Ü¶ Œ©‚ÇÅ / œÉ\nŒ©‚Çë ‚Ü¶ Œ©‚Çë / œÉ\nabstol ‚Ü¶ [abstol[1:2] * œÉ; abstol[3:end]]\nsaveat ‚Ü¶ saveat * œÉ","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Note that the scaling happens automatically for default values of the parameters; you would only need to rescale them if you were actually setting them.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"When the scaled arguments are provided to orbital_evolution, the resulting inspiral is affected as","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral.t ‚Ü¶ inspiral.t * œÉ\ninspiral[:M‚ÇÅ] ‚Ü¶ inspiral[:M‚ÇÅ] * œÉ\ninspiral[:M‚ÇÇ] ‚Ü¶ inspiral[:M‚ÇÇ] * œÉ","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"All other evolved variables are dimensionless, and so are unaffected by the scaling.  In particular, if the initial conditions are entered with values of M‚ÇÅ and M‚ÇÇ in their desired final units, no change needs to be made.  On the other hand, if the values are entered so that M‚ÇÅ+M‚ÇÇ=1, we can rescale any BBH system to any desired total mass M‚Çú‚Çí‚Çú using","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral.t ‚Ü¶ inspiral.t * M‚Çú‚Çí‚Çú * G / c^3","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Furthermore, if M‚ÇÅ and M‚ÇÇ represent the source-frame mass, and we need to apply a cosmological redshift z, we simply apply","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral.t ‚Ü¶ inspiral.t * (1+z)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The waveform H returned by either coorbital_waveform or inertial_waveform is the rescaled asymptotic limit of the strain.  The observable strain is","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"h approx H fracMr fracGc^2\nqquad mathrmor qquad\nh approx H fracM_zd_mathrmL fracGc^2","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"(The equality is only approximate because we assume that terms in 1r^2 can be ignored, which is almost certainly true of any detection in the foreseeable future.)  Here, r is the radius of the observer in asymptotically Minkowski coordinates centered on the source and M is the total mass of the binary; alternatively, M_z=M(1+z) is the redshifted mass and d_mathrmL is the luminosity distance between the source and observer.  For more complete description, see here.","category":"page"},{"location":"interface/units/#Example-1:-Scale-dependence","page":"Units","title":"Example 1: Scale dependence","text":"","category":"section"},{"location":"interface/units/","page":"Units","title":"Units","text":"It's important to check that the claims above are actually true.  Here, we put them to the test with a very large scale factor.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"using PostNewtonian, Plots  # hide\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=3, leg=:top, legendfontsize=11)  # hide\nœÉ = 10^10  # Scale factor\n\nM‚ÇÅ = 0.4\nM‚ÇÇ = 0.6\nœá‚Éó‚ÇÅ = [0.0, 0.5, 0.8]\nœá‚Éó‚ÇÇ = [0.8, 0.0, 0.5]\nŒ©·µ¢ = 0.01\nŒ©‚ÇÅ = 3Œ©·µ¢/4\nŒ©‚Çë = 0.9\ndt = 5\n\ninspiral1 = orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢, Œ©‚ÇÅ=Œ©‚ÇÅ, Œ©‚Çë=Œ©‚Çë, saveat=dt)\ninspiral2 = orbital_evolution(M‚ÇÅ*œÉ, M‚ÇÇ*œÉ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢/œÉ, Œ©‚ÇÅ=Œ©‚ÇÅ/œÉ, Œ©‚Çë=Œ©‚Çë/œÉ, saveat=dt*œÉ)\n\nplot(inspiral1.t, inspiral1[:v], label=\"Original\")\nplot!(inspiral2.t/œÉ, inspiral2[:v], label=\"Scaled\", linewidth=4, ls=:dot)\nplot!(xlabel=\"Time\", ylabel=\"PN parameter ùë£\")\nsavefig(\"units1.html\"); nothing  # hide\n\n# Check that the evolved `v` parameters are nearly equal (when interpolating\n# the second to *exactly* the same times as the first)\ninspiral1[:v] ‚âà inspiral2(inspiral1.t*œÉ, idxs=:v)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"<iframe src=\"../units1.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The fact that these curves are on top of each other, and the final expression returned true shows that this system does indeed depend on scale as suggested above.","category":"page"},{"location":"interface/units/#Units-example-2","page":"Units","title":"Example 2: Astrophysical units","text":"","category":"section"},{"location":"interface/units/","page":"Units","title":"Units","text":"Suppose we want to construct a system consistent with GW150914, having source-frame masses 356M_odot and 300M_odot, as it would be observed from a distance of 440mathrmMpc with an initial frequency in the dominant (ellm)=(2pm 2) modes of f_i approx 20mathrmHz.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Because the masses and frequencies must be in inverse units, we arbitrarily choose to measure frequencies in their natural unit of Hertz, and therefore masses are measured in seconds ‚Äî multiplying the masses by Gc^3 for geometric units.  The distance to the source d_mathrmL will also be converted to seconds by dividing by c, so that we can simply multiply the waveform by M_zd_mathrmL to get the observed strain.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The frequency f_i is the observed initial frequency of the (22) mode. We will need the corresponding angular orbital frequency in the frame.  Recall that, by definition of redshift z, we have","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"fracf_mathrmsource f_mathrmobserver = 1+z\nqquad\ntextand\nqquad\nfracDelta t_mathrmobserverDelta t_mathrmsource = 1+z","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Thus, the initial source-frame orbital angular frequency Omega_i is related to the observer-frame (22) temporal frequency f_i by[1]","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Omega_i = 2pi f_mathrmsource^(22)  2 qquad f_i = f_mathrmobserver^(22)\nqquad\nfracf_mathrmsource^(22) f_mathrmobserver^(22) = \nfracOmega_ipi f_i = 1+z\nqquad\nOmega_i = pi f_i (1+z)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"[1]: Here, we have approximated the frequency of the (ellm)=(2pm 2) modes as being twice the orbital frequency.  In the post-Newtonian approximation, waveform mode H_ellm is frequently written as A_ellm exp-i m Phi, where Phi is the orbital phase that varies in time with dPhidt = Omega.  Just looking at the exponential, we might expect the frequency of H_ellm to be m Omega.  However, the \"amplitude\" term A_ellm is not an amplitude in the usual sense; it is actually complex, with a slowly varying phase. This means that the frequency of H_ellm is not precisely m Omega ‚Äî though this is a reasonable approximation for systems with reasonably low frequency.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"using Quaternionic\nusing SphericalFunctions\nusing PostNewtonian\nusing Plots\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=3, leg=:top, legendfontsize=11)  # hide\n\n# Useful astronomical constants\nc = float(299_792_458)   # meters/second\nGM‚Çõ·µ§‚Çô = 1.32712440041e20  # meters¬≥/second¬≤\nau = float(149_597_870_700)  # meters\npc = 1au / (œÄ / 648_000)  # meters\nMpc = 1_000_000pc  # meters\n\n# Approximate maximum a posteriori spins (via SXS:BBH:0308)\nœá‚Éó‚ÇÅ = [0.0, 0.0, 0.3224]\nœá‚Éó‚ÇÇ = [0.2663, 0.2134, -0.5761]\n\n# Parameters of this system (arXiv:1606.01210)\nM‚ÇÅ = 35.6GM‚Çõ·µ§‚Çô / c^3  # seconds\nM‚ÇÇ = 30.0GM‚Çõ·µ§‚Çô / c^3  # seconds\ndL = 440Mpc / c  # seconds\nz = 0.094\nf·µ¢ = 20  # Hertz\nŒît‚Çí = 1/2048  # seconds\n\n# Conversions\nMz = (M‚ÇÅ+M‚ÇÇ) * (1+z)  # seconds\nŒ©·µ¢ = œÄ * f·µ¢ * (1+z)  # Hertz\nŒît‚Çõ = Œît‚Çí / (1+z)  # seconds\n\n# Evaluate waveform and convert to observer's frame and units\ninspiral = orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢, saveat=Œît‚Çõ)\nt‚Çí = (1+z) * inspiral.t\nH‚Çó‚Çò = inertial_waveform(inspiral)\nh‚Çó‚Çò = H‚Çó‚Çò * Mz / dL\n\n# Evaluate waveform at a point; see Scri.jl for simpler methods\nR = Quaternionic.from_spherical_coordinates(2.856, 0.0)\n‚Çã‚ÇÇY‚Çó‚Çò = SphericalFunctions.‚Çõùêò(-2, 8, Float64, [R])[1, :]\nh = (‚Çã‚ÇÇY‚Çó‚Çò' * h‚Çó‚Çò)[1,:]\n\n# Plot the results\nplot(t‚Çí, real.(h), label=\"‚Ñé‚Çä\")\nplot!(t‚Çí, -imag.(h), label=\"‚Ñé‚Çì\")\nplot!(xlabel=\"Time (seconds)\", ylabel=\"Strain (dimensionless)\", ylim=(-1.5e-21,1.5e-21))\nplot!(title=\"Observer-frame waveform\", legend=(0.205, 0.9))\nsavefig(\"units2.html\"); nothing  # hide","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"<iframe src=\"../units2.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/assorted_binaries/#Assorted-binaries","page":"Assorted binaries","title":"Assorted binaries","text":"","category":"section"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"For convenience, an assortment of constructors is provided for relevant classes of physical scenarios, as well as the ability to construct random systems across a broad range of reasonable physical parameters.","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"In each case, the returned object is a PNSystem, which can be used as input to most functions in this package ‚Äî most notably the orbital_evolution function. For example, to integrate the inspiral of a binary black-hole system in \"superkick\" configuration, we could write","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"inspiral = orbital_evolution(superkick())","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"This implicitly provides the M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢, R·µ¢, and PNOrder arguments (along with Œª‚ÇÅ and/or Œª‚ÇÇ for BHNS or NSNS systems) to orbital_evolution; other keyword arguments to that function can be provided after superkick().","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"Modules = [PostNewtonian]\nPages   = [\"assorted_binaries/examples.jl\"]","category":"page"},{"location":"interface/assorted_binaries/#PostNewtonian.hangup_kick-Tuple{}","page":"Assorted binaries","title":"PostNewtonian.hangup_kick","text":"hangup_kick(;v=0.2, œá=0.99, Œ∏=deg2rad(50.98), œï=deg2rad(30.0), PNOrder=typemax(Int))\nhangup_kick(;v=0.2, chi=0.99, theta=deg2rad(50.98), phi=deg2rad(30.0), PNOrder=typemax(Int))\n\nConstruct a black-hole binary in hangup-kick configuration.\n\nThe spin magnitudes are both equal to œá.  The direction of vecchi_1 is given by the spherical coordinates (Œ∏, œï).  vecchi_2 is the same, except that its projection into the orbital plane is opposite to that of vecchi_1.\n\nSee also superkick for the original systems, which can't actually achieve recoil kicks as large as those achieved by \"hangup-kick\" systems.\n\nThe physical mechanism here is similar to the one described in superkick, with an additional \"hangup\" due to the fact that the spins have components parallel to the orbital angular velocity.  The physical interpretation of that part is that any system with such spin components will not merge as quickly because the remnant black hole must have total dimensionless spin less than 1, so excess angular momentum must be radiated away.  This gives the hangup-kick configuration more time to develop a large recoil.\n\nExamples\n\njulia> pnsystem = hangup_kick(v=0.1)\nBBH{Vector{Float64}, 9223372036854775805//2}([0.5, 0.5, 0.3845784887294712, 0.6661094819774992, 0.6232957115416596, -0.3845784887294712, -0.6661094819774992, 0.6232957115416596, 1.0, 0.0, 0.0, 0.0, 0.1, 0.0])\n\njulia> inspiral = orbital_evolution(pnsystem);\n\njulia> inspiral[:v, 1]\n0.1\n\njulia> absvec(PostNewtonian.œá‚Éó‚ÇÅ(inspiral[1]))\n0.99\n\n\n\n\n\n","category":"method"},{"location":"interface/assorted_binaries/#PostNewtonian.superkick-Tuple{}","page":"Assorted binaries","title":"PostNewtonian.superkick","text":"superkick(;v=0.2, œá=0.99, PNOrder=typemax(Int))\nsuperkick(;v=0.2, chi=0.99, PNOrder=typemax(Int))\n\nConstruct a black-hole binary in \"superkick\" configuration.\n\nThis is the scenario first published by Campanelli et al. (2007), which has equal-mass black holes with spins of equal magnitude oriented in opposite directions in the orbital plane.  This configuration produces large asymmetrical emission of gravitational-wave linear momentum along the +z or -z directions, depending on which part of the orbit the binary is in.  Depending on when the system mergers, the remnant may then acquire a huge recoil velocity.\n\n(That recoil velocity, of course, depends on details of the merger, which post-Newtonian approximations cannot describe.  Therefore, we cannot actually use PN methods to derive any useful information about the remnant.)\n\nSee also hangup_kick for systems that can achieve even larger recoil velocities.\n\nExamples\n\njulia> pnsystem = superkick(v=0.1)\nBBH{Vector{Float64}, 9223372036854775805//2}([0.5, 0.5, 0.99, 0.0, 0.0, -0.99, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.1, 0.0])\n\njulia> inspiral = orbital_evolution(pnsystem);\n\njulia> inspiral[:v, 1]\n0.1\n\njulia> absvec(PostNewtonian.œá‚Éó‚ÇÅ(inspiral[1]))\n0.99\n\n\n\n\n\n","category":"method"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"rand(pnclass::PNSystem; v, PNOrder)","category":"page"},{"location":"interface/assorted_binaries/#Base.rand-Tuple{PNSystem}","page":"Assorted binaries","title":"Base.rand","text":"rand([rng=GLOBAL_RNG], pnclass; [v=0.01], [PNOrder=typemax(Int)])\n\nGenerate a random PNSystem, specifically of class pnclass (one of BBH, BHNS, or NSNS), with parameters chosen to be consistent with typical LIGO/Virgo/KAGRA searches as of this writing.\n\nExamples\n\njulia> pnsystem = rand(BBH);\n\njulia> inspiral = orbital_evolution(pnsystem);\n\n\nParameter ranges\n\nChoosing the space of parameters from which to randomly select values is nontrivial.  The most relevant numbers are of two types from LIGO/Virgo/KAGRA: (1) the range of parameters over which systems are searched for, and (2) the range of parameters used as priors in parameter estimation.\n\nAppendix B1 of LIGO's GWTC-1 catalog paper says that the \"spin vectors are assumed to be isotropic on the sphere and uniform in spin magnitude\", with two choices of uniform magnitude: a_i leq 089 and a_i leq 005.  The dimensionless tidal deformabilities Lambda_i of each NS are assumed to be jointly uniform within 0 leq Lambda_i leq 5000.\n\nThe more current GWTC-3 paper searches with the following:\n\nThe PyCBC-BBH analysis focuses on a region ranging in primary component mass from 5M to 350M, with mass ratios from 1/3 to 1, and effective spins ranging from chi_mathrmeff = 0998 to 0998.\n\nThat paper's parameter estimation uses uniform priors over spin magnitudes and redshifted component masses; isotropic spin orientation, sky location and binary orientation; mass-ratio q in 005 1 (sometimes extending down to q=002).  It seems that the actual ranges of the spin magnitudes and masses are restricted based on initial guesses, which may be expanded to ensure that the posteriors lie entirely within the priors.  The distance priors are uniform in D_mathrmL^2, with some adjustments due to cosmology.\n\nFor the purposes of this package, we're not too interested in absolute scales ‚Äî specifically distance or total mass ‚Äî so we'll just choose the total mass to be 1 at the initial frequency, then sample based on mass ratio and spin magnitudes.\n\nGiven these, it seems like the current state of the art would be well covered by choosing a random q ‚àà [0.05, 1], œá·µ¢ ‚àà [0, 0.998], and Œª·µ¢ ‚àà [0, 5000], with isotropic choices for orientations.\n\n\n\n\n\n","category":"method"},{"location":"interface/gwframes/#GWFrames-compatibility-layer","page":"GWFrames","title":"GWFrames compatibility layer","text":"","category":"section"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"GWFrames is an old python package that was too hard to upgrade to python 3, and therefore became impossible to maintain.  Many of its capabilities have been superseded by the scri and sxs packages, but not the post-Newtonian capabilities.  This package now supersedes the latter.  For convenience, the PostNewtonian.GWFrames submodule provides a simple function to mimic the arguments used with the original GWFrames package to obtain a PN waveform (with a couple extra arguments).  We won't bother to provide a return type that can fully mimic the object returned by the original GWFrames package, though it should be similar to the ones used by scri and sxs.","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"Modules = [PostNewtonian.GWFrames]\nPages   = [\"gwframes.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"interface/gwframes/#PostNewtonian.GWFrames.PNWaveform","page":"GWFrames","title":"PostNewtonian.GWFrames.PNWaveform","text":"PNWaveform(Approximant, delta, chi1_i, chi2_i, Omega_orb_i; kwargs...)\n\nCompute a PN waveform, with the same call signature as GWFrames.PNWaveform\n\nThis is essentially a compatibility layer for the corresponding function in the original GWFrames Python package, with several additional optional arguments: inertial, dt, quiet, ell_min, ell_max, lambda1, and lambda2 (see below).  Also, this function accepts optional arguments either as positional arguments (which the original GWFrames requires) or as keyword arguments.\n\nwarning: Warning\nWe do not expect the result of this function to be identical to the result from the GWFrames Python package.  In particular, this package uses more general expressions for the tidal-heating terms, fixes an error in the 2PN quadratic-spin terms for the waveform modes, uses more accurate (and efficient) ODE integration, and uses a more accurate method to compute the number of steps per orbit (by default).Also note that there are differences in the order of operations for computing intermediate variables.  Cancellation and roundoff error caused by these differences can have surprisingly large effects on the orbital evolution in many cases ‚Äî particularly for precessing systems.  Results from the two packages have been painstakingly analyzed, leading to the conclusion that all differences are caused by such errors or the differences in formulations mentioned above.\n\nThe Julia interface is more detailed, flexible, and efficient than the simple GWFrames interface that this function emulates.  In particular, orbital_evolution takes essentially all the same arguments that DifferentialEquations.solve takes, and returns a solution that provides dense output and more details about the ODE solution itself.  For example, one reason this function is more efficient than GWFrames is that we can use dense output to solve with fewer timesteps, while accurately and efficiently interpolating to the requested timesteps.  While orbital_evolution solves for the dynamics, coorbital_waveform or inertial_waveform provides the actual waveform; both are returned by this function.\n\nRequired arguments\n\nApproximant: Currently, only \"TaylorT1\" is supported.\ndelta: Fractional mass difference (M‚ÇÅ-M‚ÇÇ)(M‚ÇÅ+M‚ÇÇ)\nchi1_i: Normalized spin vector S‚ÇÅM‚ÇÅ¬≤\nchi2_i: Normalized spin vector S‚ÇÇM‚ÇÇ¬≤\nOmega_orb_i: Orbital angular frequency at initial instant\n\nOptional arguments\n\nAs mentioned above, the following may be given either as positional arguments in this order (though any number of them may be omitted from the end), or as keyword arguments.\n\nOmega_orb_0=Omega_orb_i: Orbital angular frequency at first instant found in data.  If this is less than Omega_orb_i, the system is integrated backwards in time from the latter value to this value.\nR_frame_i=Rotor(1): Initial orientation of the frame.\nMinStepsPerOrbit=32: Number of time steps in the output data per orbit.  Because the waveform modes go as high as m=8, this number should be at least 16 to avoid Nyquist aliasing in those modes.  Note that this value may be overridden by dt (see below).\nPNWaveformModeOrder=4.0: Maximum PN order of terms in the waveform formulas.\nPNOrbitalEvolutionOrder=4.0: Maximum PN order of terms in the orbital-evolution formulas.\ninertial=false: If true, transform waveform to the inertial frame; otherwise, the waveform will be in the co-orbital frame.\ndt=0: Uniform time step size of the output.  If this is not a strictly positive number, MinStepsPerOrbit will be used instead.\nquiet=true: If false, show informational messages about the reasons for terminating the ODE integration.  In either case, warnings will still be issued if terminating for bad or suspicious reasons.  See the documentation of orbital_evolution for an example of how to filter warnings also.\nell_min=2: The lowest ‚Ñì value in the output waveform.\nell_max=8: The highest ‚Ñì value in the output waveform.\nlambda1=0: Tidal-coupling parameter of object 1.\nlambda2=0: Tidal-coupling parameter of object 2.\n\nReturned values\n\nThis function returns a NamedTuple with the following keys:\n\nt: The vector of time steps at which the data are evaluated.  The time t=0 corresponds to the initial values that are arguments to this function.\ndata: Matrix of complex values of the mode weights.  The shape is length(t) x 77.  The first dimension enumerates the values at each instant of time.  The second dimension enumerates the modes, starting with (2-2), then (2-1), up to (22), followed by (3-3), and so on up to (88).  This is the opposite ordering as results from GWFrames, but the same as the ordering used by the sxs and scri packages.  However, also note that certain conversions between Julia and Python may transpose matrices, because Julia is Fortran-ordered by default, whereas numpy is C-ordered.  It is best to check the shape manually to be sure which dimension is which.\nframe: Matrix of shape length(t) x 4 representing the frame-orientation quaternion as a function of time t.\nM1, M2: Vectors of the respective masses as functions of time t.  Note that only at the time corresponding to Omega_orb_i will the total mass be precisely 1. Generally, tidal heating will lead to time-dependent masses.\nchi1, chi2: Matrices of shape length(t) x 3 representing the spins as functions of time t.\nv: PN velocity parameter as a function of time t.\nPhi: Orbital phase as a function of time t.\n\nBecause this is a NamedTuple, the fields can be accessed much like the fields of a WaveformModes object in the scri or sxs Python packages ‚Äî as in w.t and w.data, where w is the object returned by this function.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"internals/utilities/#Macros","page":"Utilities","title":"Macros","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Some of the most useful features of this package are the macros allowing us to write PN expressions in fairly natural form, without worrying about calculating all the variables needed for each expression, or manually accounting for the various PN orders to which we may need to truncate PN expansions.  To achieve this, we rely primarily on two macros.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/macros.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.extract_var_factor-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.extract_var_factor","text":"extract_var_factor(term, var)\n\nExtract a factor of var from the product term.\n\nThis is a helper function for var_collect.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.hold-Tuple{Any}","page":"Utilities","title":"PostNewtonian.hold","text":"hold(x)\n\nDelay evaluation of the argument in Symbolics expressions.\n\nThis is just a helper function that acts trivially ‚Äî like the identity function ‚Äî but also gets registered with Symbolics to avoid evaluation of the argument.  For example, we can preserve expressions like œÄ^2, which Julia would normally convert directly to a Float64.\n\nNote that you probably don't want to use this function directly; this will probably be done for you by @pn_expression or similar.  If you do want to use this directly, you probably want another layer of indirection to construct something like Symbolics.Num(SymbolicUtils.Term(hold, [x])) so that you can use the result in a symbolic expression.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.type_converter-Union{Tuple{T}, Tuple{PNSystem{T}, Any}} where T<:Vector{Symbolics.Num}","page":"Utilities","title":"PostNewtonian.type_converter","text":"type_converter(pnsystem, x)\n\nConvert x to a type appropriate for the float type of pnsystem.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.unhold-Tuple{Any}","page":"Utilities","title":"PostNewtonian.unhold","text":"unhold(expr)\n\nRemove occurrences of hold from an Expr.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.var_collect-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.var_collect","text":"var_collect(expr, var)\n\nCollect coefficients in expr of various powers of the variable var.\n\nThe inputs should be an Expr and a single Symbol to be found in that Expr.\n\nThe return value is an Int representing the highest power of v in the expression, and an Expr representing a Tuple of values corresponding to the coefficients of var to various powers.  For example,\n\njulia> PostNewtonian.var_collect(:(1 + a*v + b*v^2 + c*v^4), :v)\n4, :((1, a, b, 0, c))\n\n(Note that there was no factor in v^3.)  This result is convenient for passing to evalpoly, for example.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.@pn_expansion-Tuple{Any, Any, Any}","page":"Utilities","title":"PostNewtonian.@pn_expansion","text":"@pn_expansion [[offset] pnsystem] expansion\n\nGather terms in expansion by the powers of v involved, the choose on the powers chosen by the pnsystem's PNOrder parameter, and evaluate efficiently in Horner form.\n\nNote that the pnsystem argument can be inserted automatically by @pn_expression. For simplicity of presentation, we will assume that this is done in the examples below.\n\nA \"PN expansion\" is a polynomial in v for which ln(v) factors may be present in coefficients of v^k for k1.  The input may involve multiple terms with the same power of v.  (I.e., the expansion does not have to be simplified or collected in sympy parlance.)\n\nHowever, note that the sum must appear together ‚Äî as part of the same :+ expression ‚Äî rather than, say, factored into two sums that multiply each other.\n\n\n\n\n\n","category":"macro"},{"location":"internals/utilities/#PostNewtonian.@pn_expression-Tuple{Any}","page":"Utilities","title":"PostNewtonian.@pn_expression","text":"@pn_expression [arg_index=1] func\n\nThis macro takes the function func, looks for various symbols inside that function, and if present defines them appropriately inside that function.\n\nThe first argument to this macro is arg_index, which just tells us which argument to the function func is a PNSystem.  For example, the variables defined in PostNewtonian.FundamentalVariables all take a single argument of pnsystem, which is used to compute the values for those variables; this macro just needs to know where to find pnsystem.\n\nOnce it has this information, there are four types of transformations it will make:\n\nFor every fundamental or derived variable, the name of that variable used in the body of func will be replaced by its value when called with pnsystem.  For example, you can simply use the symbols M‚ÇÅ or Œº in your code, rather than calling them as M‚ÇÅ(pnsystem) or Œº(pnsystem) every time they appear.\nEvery Irrational defined in Base.MathConstants or PostNewtonian.MathConstants will be transformed to the eltype of pnsystem.  This lets you naturally use such constants in expressions like 2œÄ/3 without automatically converting to Float64.\nEach of a short list of functions given by unary_funcs in utilities/macros.jl will first convert their arguments to the eltype of pnsystem.  In particular, you can use expressions like ‚àö10 or ln(2) without the result being converted to a Float64.\nInsert the pnsystem argument as the first argument to each occurrence of @pn_expansion that needs it.\n\nTo be more explicit, the first three are achieved by defining the relevant quantities in a let block placed around the body of func, so that the values may be used efficiently without recomputation.\n\nIf you need to use one of the fundamental- or derived-variable functions as arguments of values other than those encapsulated in pnsystem, you'll need to address them explicitly with the module name ‚Äî as in PostNewtonian.v(;Œ©, M).\n\n\n\n\n\n","category":"macro"},{"location":"internals/utilities/#Manipulating-ODE-solutions","page":"Utilities","title":"Manipulating ODE solutions","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/combine_solutions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.combine_solutions-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.combine_solutions","text":"combine_solutions(sol‚Çã, sol‚Çä)\n\nCombine ODESolutions\n\nThis function is internal to this package.  It is not entirely general, but allows us to combine the backwards- and forwards-in-time solutions of the PN orbital-evolution ODE equations into a single ODESolution object that should behave just as if it were the result of solve.  In particular, indexing, interpolation, and iterations should behave exactly as described in the DifferentialEquations docs.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#Termination-criteria","page":"Utilities","title":"Termination criteria","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Hopefully, it should not be necessary to directly use these termination criteria.  They are used by default in the orbital_evolution function. But certain particularly extreme physical parameters may lead ODEs that are difficult to integrate ‚Äî especially if new PN systems or terms are introduced. These, or similar functions may be helpful examples of \"callbacks\" that can be passed to the ODE integrator.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Note that several of these will issue warnings if the evolution has to be terminated for particularly bad or suspicious reasons, even if the quiet flag is set to true.  See the documentation of the quiet argument to the orbital_evolution function for an example of how to use Logging to quiet even the warnings.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/termination_criteria.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.decreasing_v_terminator","page":"Utilities","title":"PostNewtonian.decreasing_v_terminator","text":"decreasing_v_terminator([quiet])\n\nConstruct termination criterion to stop integration when v is decreasing.\n\nNote that some systems may truly have decreasing v as physical solutions ‚Äî including eccentric systems and possibly precessing systems.  You may prefer to implement another solution, like detecting when v decreases below some threshold, or detecting when v is decreasing too quickly.  See this function's source code for a simple\n\nIf this terminator is triggered while v is less than 1/2, a warning will always be issued; otherwise an info message will be issued only if the quiet flag is set to false.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.dtmin_terminator","page":"Utilities","title":"PostNewtonian.dtmin_terminator","text":"dtmin_terminator(T, [quiet])\n\nConstruct termination criterion to terminate when dt drops below ‚àöeps(T).\n\nPass force_dtmin=true to solve when using this callback.  Otherwise, the time-step size may decrease too much within a single time step, so that the integrator itself will quit before reaching this callback, leading to a less graceful exit.\n\nIf this terminator is triggered while v is less than 1/2, a warning will always be issued; otherwise an info message will be issued only if the quiet flag is set to false.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.nonfinite_terminator-Tuple{}","page":"Utilities","title":"PostNewtonian.nonfinite_terminator","text":"nonfinite_terminator()\n\nConstruct termination criterion to stop integration when any NaN or Inf is found in the data after an integration step.\n\nIf this terminator is triggered, a warning will always be issued.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.termination_backwards","page":"Utilities","title":"PostNewtonian.termination_backwards","text":"termination_backwards(v‚ÇÅ, [quiet])\n\nConstruct termination criteria of solving PN evolution backwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at v‚ÇÅ.\n\nThe optional quiet argument will silence informational messages about reaching the target value of v‚ÇÅ if set to true, but warnings will still be issued when terminating for other reasons.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.termination_forwards","page":"Utilities","title":"PostNewtonian.termination_forwards","text":"termination_forwards(v‚Çë, [quiet])\n\nConstruct termination criteria of solving PN evolution forwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at v‚Çë.\n\nThe optional quiet argument will silence informational messages about reaching the target value of v‚Çë if set to true, but warnings will still be issued when terminating for other reasons.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#Irrational-constants","page":"Utilities","title":"Irrational constants","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"These quantities are constants that appear in PN expressions, so they are not exported, but can be used by importing them explicitly or by using the fully qualified names.  They are defined here as Irrationals.  This means that Julia can convert them to float types as necessary.  Unfortunately, by default Julia converts to Float64.  For example, BigFloat(2Œ∂3) will be a BigFloat, but will only have the precision of a Float64, because 2Œ∂3 is converted first. To get full precision, you'll need to do things like 2BigFloat(Œ∂3).","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"One approach to avoiding this is to explicitly redefine these constants as floats of the desired precision, using let to essentially overwrite the name:","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"function foo(x)\n    let Œ∂3=oftype(x, Œ∂3)\n        2Œ∂3 + x\n    end\nend","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Inside the let block, Œ∂3 is no longer an Irrational; it has been converted to whatever number type x is.  Thus, when multiplying by 2, it is not converted to a Float64; its precision matches that of x.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"This can be quite awkward, so the macro PostNewtonian.@pn_expression is provided to (among other things) automatically search for all Irrationals and replace them with the appropriate float values.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"PostNewtonian.Œ≥‚Çë\nPostNewtonian.Œ∂3\nPostNewtonian.ln2\nPostNewtonian.ln3\nPostNewtonian.ln5\nPostNewtonian.ln¬≥‚ï±‚ÇÇ\nPostNewtonian.ln‚Åµ‚ï±‚ÇÇ","category":"page"},{"location":"internals/utilities/#PostNewtonian.MathConstants.Œ≥‚Çë","page":"Utilities","title":"PostNewtonian.MathConstants.Œ≥‚Çë","text":"Œ≥‚Çë\n\nEuler's constant (also known as the Euler‚ÄìMascheroni constant) is defined as the limit as n to infty of the difference between the nth partial sum of the harmonic series and log(n).  This is OEIS sequence A001620.\n\njulia> PostNewtonian.Œ≥‚Çë\nŒ≥‚Çë = 0.5772156649015...\n\njulia> n=10_000_000; sum(1 ./ (1:n))-log(n)\n0.5772157149015307\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.Œ∂3","page":"Utilities","title":"PostNewtonian.MathConstants.Œ∂3","text":"Œ∂3\napery\n\nAp√©ry's constant is defined as Œ∂(3), where Œ∂ is the Riemann zeta function.  This is OEIS sequence A002117.\n\njulia> PostNewtonian.apery\nŒ∂3 = 1.2020569031595...\n\njulia> PostNewtonian.Œ∂3\nŒ∂3 = 1.2020569031595...\n\njulia> sum((1:10_000_000).^-3)\n1.2020569031595896\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln2","page":"Utilities","title":"PostNewtonian.MathConstants.ln2","text":"ln2\nlog2\n\nThe natural logarithm of 2.  This is OEIS sequence A002162.\n\njulia> PostNewtonian.ln2\nln2 = 0.6931471805599...\n\njulia> exp(PostNewtonian.ln2)\n2.0\n\njulia> exp(big(PostNewtonian.ln2))\n2.0\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln3","page":"Utilities","title":"PostNewtonian.MathConstants.ln3","text":"ln3\nlog3\n\nThe natural logarithm of 3.  This is OEIS sequence A002391.\n\njulia> PostNewtonian.ln3\nln3 = 1.0986122886681...\n\njulia> exp(PostNewtonian.ln3)\n3.0000000000000004\n\njulia> exp(big(PostNewtonian.ln3))\n3.0\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln5","page":"Utilities","title":"PostNewtonian.MathConstants.ln5","text":"ln5\nlog5\n\nThe natural logarithm of 5.  This is OEIS sequence A016628.\n\njulia> PostNewtonian.ln5\nln5 = 1.6094379124341...\n\njulia> exp(PostNewtonian.ln5)\n4.999999999999999\n\njulia> exp(big(PostNewtonian.ln5))\n5.0\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln¬≥‚ï±‚ÇÇ","page":"Utilities","title":"PostNewtonian.MathConstants.ln¬≥‚ï±‚ÇÇ","text":"ln¬≥‚ï±‚ÇÇ\nlog¬≥‚ï±‚ÇÇ\nlog3halves\n\nThe natural logarithm of 3//2.  This is OEIS sequence A016578.\n\njulia> PostNewtonian.ln¬≥‚ï±‚ÇÇ\nln¬≥‚ï±‚ÇÇ = 0.4054651081081...\n\njulia> exp(PostNewtonian.ln¬≥‚ï±‚ÇÇ)\n1.5\n\njulia> exp(big(PostNewtonian.ln¬≥‚ï±‚ÇÇ))\n1.5\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln‚Åµ‚ï±‚ÇÇ","page":"Utilities","title":"PostNewtonian.MathConstants.ln‚Åµ‚ï±‚ÇÇ","text":"ln‚Åµ‚ï±‚ÇÇ\nlog‚Åµ‚ï±‚ÇÇ\nlog5halves\n\nThe natural logarithm of 5//2.  This is OEIS sequence A016579.\n\njulia> PostNewtonian.ln‚Åµ‚ï±‚ÇÇ\nln‚Åµ‚ï±‚ÇÇ = 0.9162907318741...\n\njulia> exp(PostNewtonian.ln‚Åµ‚ï±‚ÇÇ)\n2.5\n\njulia> exp(big(PostNewtonian.ln‚Åµ‚ï±‚ÇÇ))\n2.5\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#Miscellaneous","page":"Utilities","title":"Miscellaneous","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/misc.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.apply_to_first_add!-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.apply_to_first_add!","text":"apply_to_first_add!(expr, func)\n\nApply func to the first sub-expression found in a \"prewalk\"-traversal of expr that satisfies isadd.  If func acts in place, so does this function.  In either case, the expression should be returned.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.find_symbols_of_type-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.find_symbols_of_type","text":"find_symbols_of_type(mod, T)\n\nGiven a module mod (not just its name, but the actual imported module), find all objects inside that module that are instances of the given type T.  The returned quantity is a vector of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.flatten_binary!-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.flatten_binary!","text":"flatten_binary!(expr, symbols)\n\nFlatten nested binary operations ‚Äî that is, apply associativity repeatedly.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.isadd-Tuple{Any}","page":"Utilities","title":"PostNewtonian.isadd","text":"isadd(x)\n\nReturn true if the Expr x is a call to (+) or :+.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.iscall-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.iscall","text":"iscall(x, symbols)\n\nReturn true if the Expr x is a call to any element of symbols.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.ismul-Tuple{Any}","page":"Utilities","title":"PostNewtonian.ismul","text":"ismul(x)\n\nReturn true if the Expr x is a call to (*) or :*.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.value-Tuple{Any}","page":"Utilities","title":"PostNewtonian.value","text":"value(x)\n\nReturn x or the value wrapped by the Dual number x\n\n\n\n\n\n","category":"method"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = PostNewtonian","category":"page"},{"location":"#PostNewtonian","page":"Introduction","title":"PostNewtonian","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package computes orbital dynamics of and waveforms from binary black-hole systems, in the post-Newtonian approximation. Currently, general precessing quasispherical systems are supported, but support for eccentric systems is still upcoming.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you intend to use this package via Python, see this page for installation instructions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is recommended to use this package with Julia version 1.9 or greater, because of that version's improved pre-compilation caching.  If you find it very slow the first time you use functions from this package in a new Julia session, that is most likely because Julia has to compile a lot of code.  Version 1.9 does a better job of caching that compiled code, which speeds up your first-time usage.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you haven't installed Julia yet, you probably want to use juliaup to do so.  You'll probably also want to use a Julia \"project environment\" specifically for using this package.  An easy way to do this is to create a directory, cd into that directory, and then run julia as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia --project=.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then, installation of this package involves the usual commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"PostNewtonian\")","category":"page"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An example with slightly more explanation is given under \"High-level interface\", and of course the rest of this documentation goes into far more detail.  Here we see a simple example to start things off.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nYou don't have to use cool Unicode names for your variables if you don't want to.  For example, chi1 works just as well as œá‚Éó‚ÇÅ.  Similarly, many functions in this package have Unicode names or take optional Unicode keyword arguments.  But every such name or argument will also have an ASCII equivalent; see the documentation of those functions for the appropriate substitutions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using PostNewtonian\n\n# Initial values of the masses, spins, and orbital angular frequency\nM‚ÇÅ = 0.4\nM‚ÇÇ = 0.6\nœá‚Éó‚ÇÅ = [0.0, 0.5, 0.8]\nœá‚Éó‚ÇÇ = [0.8, 0.0, 0.5]\nŒ©·µ¢ = 0.01\n\n# Integrate the orbital dynamics\ninspiral = orbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢)\n\n# Interpolate for nicer plotting\nt‚Ä≤ = inspiral.t[end]-6_000 : 0.5 : inspiral.t[end]\ninspiral = inspiral(t‚Ä≤)\n\n# Compute the waveform in the inertial frame\nh = inertial_waveform(inspiral)\nnothing  # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can plot the result like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Plots  # Requires also installing `Plots` in your project\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=2, leg=:top, legendfontsize=11)  # hide\ndefault(extra_plot_kwargs = KW(:include_mathjax => \"cdn\"))  # hide\n\nplot(inspiral.t, real.(h[1, :]), label=raw\"$\\Re\\left\\{h_{2,2}\\right\\}$\")\nplot!(inspiral.t, imag.(h[1, :]), label=raw\"$\\Im\\left\\{h_{2,2}\\right\\}$\")\nplot!(inspiral.t, abs.(h[1, :]), label=raw\"$\\left|h_{2,2}\\right|$\", linewidth=3)\nplot!(inspiral.t, abs.(h[5, :]), label=raw\"$\\left|h_{2,-2}\\right|$\")\nplot!(xlabel=raw\"$\\text{Time }(M)$\", ylabel=\"Mode weights\", ylim=(-0.45,0.45))\n\nsavefig(\"waveform.html\"); nothing  # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<iframe src=\"waveform.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We see various features to be expected of a precessing system like this, including slow modulations of the modes on the precession timescale, as well as faster oscillations in the amplitudes and asymmetry between the m=pm 2 modes on the orbital timescale.","category":"page"},{"location":"internals/dynamics/#Dynamics","page":"Dynamics","title":"Dynamics","text":"","category":"section"},{"location":"internals/dynamics/#Integrating-orbital-evolution","page":"Dynamics","title":"Integrating orbital evolution","text":"","category":"section"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"orbital_evolution\nuniform_in_phase\nestimated_time_to_merger\nfISCO\nŒ©ISCO","category":"page"},{"location":"internals/dynamics/#PostNewtonian.orbital_evolution","page":"Dynamics","title":"PostNewtonian.orbital_evolution","text":"orbital_evolution(pnsystem; kwargs...)\norbital_evolution(M‚ÇÅ, M‚ÇÇ, œá‚Éó‚ÇÅ, œá‚Éó‚ÇÇ, Œ©·µ¢; kwargs...)\n\nIntegrate the orbital dynamics of an inspiraling non-eccentric compact binary.\n\nRequired arguments\n\nThe first argument to this function may be a single PNSystem that encodes these required arguments (as well as R·µ¢, Œª‚ÇÅ, and Œª‚ÇÇ among the keyword arguments), or the following may be given explicitly:\n\nM‚ÇÅ: Initial mass of object 1\nM‚ÇÇ: Initial mass of object 2\nœá‚Éó‚ÇÅ: Initial dimensionless spin of object 1, S‚Éó‚ÇÅ/M‚ÇÅ¬≤\nœá‚Éó‚ÇÇ: Initial dimensionless spin of object 2, S‚Éó‚ÇÇ/M‚ÇÇ¬≤\nŒ©·µ¢: Initial orbital angular frequency\n\n(Note that the explicit inputs require Œ©·µ¢, whereas PNSystems require v·µ¢ as input.)\n\nThese parameters all describe the \"initial\" conditions.  See below for an explanation of the different meanings of \"initial\" and \"first\" in this context.  Note that the masses change in time as a result of tidal heating ‚Äî though the changes are quite small throughout most of the inspiral.  The spins change direction due to precession, but also change in magnitude due to tidal heating.  Therefore, the values passed here are only precisely as given precisely at the moment of the initial data corresponding to the frequency Œ©·µ¢.\n\nKeyword arguments\n\nNote that several of these keywords are given as Unicode but can also be given as the ASCII string noted.  For example, Œª‚ÇÅ may be input as lambda1 equivalently; the default values are the same, regardless.\n\nŒª‚ÇÅ=0 or lambda1: Tidal-coupling parameter of object 1.\nŒª‚ÇÇ=0 or lambda2: Tidal-coupling parameter of object 2.\nŒ©‚ÇÅ=Œ©·µ¢ or Omega_1: First angular frequency in output data.  This may be less than Œ©·µ¢, in which case we integrate backwards to this point, and combine the backwards and forwards solutions into one seamless output.  (See next section.)\nŒ©‚Çë=Œ©(v=1,M=M‚ÇÅ+M‚ÇÇ) or Omega_e: Final angular frequency at which to stop ODE integration.  Note that integration may stop before the system reaches this frequency, if we detect that PN has broken down irretrievably ‚Äî for example, if one of the masses is no longer strictly positive, if a spin is super-extremal, or the PN velocity parameter v is decreasing, or is no longer in the range (0,1).  Warnings will usually only be issued if v < 1//2, but if quiet=true informational messages will be issued.\nR·µ¢=Rotor(1) or R_i: Initial orientation of binary.\napproximant=\"TaylorT1\": Method of evaluating the right-hand side of the evolution equations.\nPNOrder=typemax(Int): Order to which to retain powers of v^2 in PN expansions. The default is to include all available terms in each PN expression.\ncheck_up_down_instability=true: Warn if the \"up-down instability\" (see below) is likely to affect this system.\ntime_stepper=AutoVern9(Rodas5P()): Choice of solver in OrdinaryDiffEq to integrate ODE.\nabstol=eps(T)^(11//16): Absolute tolerance of ODE solver, where T is the common type to which all the positional arguments are promoted.  This is the tolerance on local error estimates, not necessarily the global error.  Note that 11//16 is just chosen to suggest that we will have roughly 11 digits of accuracy (locally) for Float64 computations, and a similar accuracy for other float types relative to that type's epsilon.\nreltol=eps(T)^(11//16): Relative tolerance of ODE solver.  (As above.)\ntermination_criteria_forwards=nothing: Callbacks to use for forwards-in-time evolution.  See below for discussion of the default value.\ntermination_criteria_backwards=nothing: Callbacks to use for backwards-in-time evolution.  See below for discussion of the default value.\nforce_dtmin=true: If dt decreases below the integrator's own minimum, and this is false, the integrator will immediately raise an error, before the termination criteria have the chance to exit gracefully.  Note that a true value here is critical if the dtmin_terminator callback is to have any effect.\nquiet=true: If set to false, informational messages about successful terminations of the ODE integrations (which occur when the target v is reached in either direction) will be provided.  Warnings will still be issued when terminating for other reasons; if you wish to silence them too, you should do something like\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\nsaves_per_orbit=0: If greater than 0, the output will be interpolated so that there are saves_per_orbit time steps in the output for each orbit.  Note that this conflicts with the saveat option noted below.\n\nAll remaining keyword arguments are passed to the solve function of DiffEqBase.  See that function's documentation for details, including useful keyword arguments.  The most likely important one is\n\nsaveat: Denotes specific times to save the solution at, during the solving phase ‚Äî either a time step or a vector of specific times.\n\nIn particular, if you want the solution to be output at uniform time steps Œ¥t, you want to pass something like saveat=Œ¥t; you don't want the solve keyword dt, which is just the initial suggestion for adaptive systems.  It is not permitted to pass this option and the saves_per_orbit option.\n\nAlso note that callback can be used, and is combined with the callbacks generated by the termination_criteria_* arguments above.  That is, you can use the default ones and your own by passing arguments to callback.  See the documentation for more details, but note that if you want to make your own callbacks, you will need to add OrdinaryDiffEq to your project ‚Äî or possibly even DifferentialEquations for some of the fancier built-in callbacks.\n\nODE system\n\nThe evolved variables, in order, are\n\nM‚ÇÅ: Mass of black hole 1\nM‚ÇÇ: Mass of black hole 2\nœá‚Éó‚ÇÅÀ£: x component of dimensionless spin of black hole 1\nœá‚Éó‚ÇÅ ∏: y component...\nœá‚Éó‚ÇÅ·∂ª: z component...\nœá‚Éó‚ÇÇÀ£: x component of dimensionless spin of black hole 2\nœá‚Éó‚ÇÇ ∏: y component...\nœá‚Éó‚ÇÇ·∂ª: z component...\nR ∑: Scalar component of frame rotor\nRÀ£: x component...\nR ∏: y component...\nR·∂ª: z component...\nv: PN \"velocity\" parameter related to the total mass M and orbital angular frequency Œ© by v = (M Œ©)^13\nŒ¶: Orbital phase given by integrating Œ©\n\nThe masses and spin magnitudes evolve according to tidal_heating.  The spin directions evolve according to Œ©‚Éó·µ™‚ÇÅ and Œ©‚Éó·µ™‚ÇÇ.  The frame precesses with angular velocity Œ©‚Éó‚Çö, while also rotating with angular frequency Œ© about the Newtonian orbital angular velocity direction.  The frame rotor R is given by integrating the sum of these angular velocities as described in Boyle (2016).  And finally, the PN parameter v evolves according to something like\n\ndotv = - fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nwhere ùìï is the flux of gravitational-wave energy out of the system, dotM_1 and dotM_2 are due to tidal coupling as computed by tidal_heating, and ùìî‚Ä≤ is the derivative of the binding energy with respect to v.  For \"TaylorT1\", the right-hand side of this equation is evaluated as given; for \"TaylorT4\", the right-hand side is first expanded as a Taylor series in v and then truncated at some desired order; for \"TaylorT5\", the inverse of the right-hand side is expanded as a Taylor series in v, truncated at some desired order, and then inverted to obtain an expression in terms of v.\n\nReturned solution\n\nThe returned quantity is an ODESolution object, which has various features for extracting and interpolating the data.  We'll call this object sol.\n\nnote: Note\nThe solution comes with data at the time points the ODE integrator happened to step to.  However, it also comes with dense output (unless you manually turn it off when calling orbital_evolution).  This means that you can interpolate the solution to any other set of time points you want simply by calling it as sol(t) for some vector of time points t.  The quantity returned by that will have all the features described below, much like the original solution.  Note that if you only want some of the data, you can provide the optional keyword argument idxs to specify which of the elements described below you want to interpolate.  For example, if you only want to interpolate the values of M‚ÇÅ and M‚ÇÇ, you can use sol(t, idxs=[1,2]).\n\nThe field sol.t is the set of time points at which the solution is given.  To access the ith variable at time step j, use sol[i, j].[1] You can also use colons.  For example, sol[:, j] is a vector of all the data at time step j, and sol[i, :] is a vector of the ith variable at all times.\n\n[1]: Here, the ith variable just refers to which number it has in the list of evolved   variables in the ODE system, as described under \"ODE system\".\n\nFor convenience, you can also access the individual variables with their symbols.  For example, sol[:v] returns a vector of the PN velocity parameter at each time step.  Note the colon in :v, which is Julia's notation for a Symbol.\n\nInitial frequency vs. first frequency vs. end frequency\n\nNote the distinction between Œ©·µ¢ (with subscript i) and Œ©‚ÇÅ (with subscript 1).  The first, Œ©·µ¢, represents the angular frequency of the initial condition from which the ODE integrator will begin; the second, Œ©‚ÇÅ, represents the target angular frequency of the first element of the output data.  That is, the ODE integration will run forwards in time from Œ©·µ¢ to the merger, and then ‚Äî if Œ©·µ¢>Œ©‚ÇÅ ‚Äî come back to Œ©·µ¢ and run backwards in time to Œ©‚ÇÅ.  The output data will stitch these two together to be one continuous (forwards-in-time) data series.\n\nFor example, if you are trying to match to a numerical relativity (NR) simulation, you can read the masses and spins off of the NR data when the system is orbiting at angular frequency Œ©·µ¢.  Integrating the post-Newtonian (PN) solution forwards in time from this point will allow you to compare the PN and NR waveforms.  However, you may want to know what the waveform was at earlier times than are present in the NR data.  For this, you also have to integrate backwards in time.  We parameterize the point to which you integrate backwards with Œ©‚ÇÅ.  In either case, element 1 of the output solution will have frequency Œ©‚ÇÅ ‚Äî though by default it is equal to Œ©·µ¢.\n\nSimilarly, the optional argument Œ©‚Çë=1 is the frequency of the end element of the solution ‚Äî that is Julia's notation for the last element.  Note that this is automatically reduced if necessary so that the corresponding PN parameter v is no greater than 1, which may be the case whenever the total mass is greater than 1.\n\nUp-down instability\n\nBe aware that the up-down instability (where the more massive black hole has spin aligned with the orbital angular velocity, and the less massive has spin anti-aligned) can cause systems with nearly zero precession at the initial time to evolve into a highly precessing system either at earlier or later times.  This is a real physical result, rather than a numerical issue.  If you want to simulate a truly non-precessing system, you should explicitly set the in-place components of spin to precisely 0.  By default, we check for this condition, and will issue a warning if it is likely to be encountered for systems with low initial precession.  The function used to compute the unstable region is up_down_instability.\n\nTime-stepper algorithms\n\nTsit5() is a good default choice for time stepper when using Float64 with medium-low tolerance.  If stiffness seems to be impacting the results, AutoTsit5(Rosenbrock23()) will automatically switch when stiffness occurs.  For tighter tolerances, especially when using Double64s, Vern9() or AutoVern9(Rodas5P()) are good choices.  For very loose tolerances, as when using Float32s, it might be better to use OwrenZen3().\n\nTermination criteria\n\nThe termination criteria are vital to efficiency of the integration and correctness of the solution.  The default values for forwards- and backwards-in-time evolution, respectively, are\n\nCallbackSet(\n    termination_forwards(v(Œ©=Œ©‚Çë, M=M‚ÇÅ+M‚ÇÇ)),\n    dtmin_terminator(T),\n    decreasing_v_terminator(),\n    nonfinite_terminator()\n)\n\nand\n\nCallbackSet(\n    termination_backwards(v(Œ©=Œ©‚ÇÅ, M=M‚ÇÅ+M‚ÇÇ)),\n    dtmin_terminator(T),\n    nonfinite_terminator()\n)\n\nwhere T is the common float type of the input arguments.  If any additional termination criteria are needed, they could be added as additional elements of the CallbackSets.  See the callback documentation for details.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.uniform_in_phase","page":"Dynamics","title":"PostNewtonian.uniform_in_phase","text":"uniform_in_phase(solution, saves_per_orbit)\n\nInterpolate solution to uniform steps in phase.\n\nBy default, the solution returned by orbital_evolution may be sampled very sparsely ‚Äî too sparsely to satisfy the Nyquist limit of the waveform.  If the waveform extends to ell_mathrmmax, there will be modes varying slightly more rapidly than expleft(pm i ell_mathrmmax Phi right), where Phi is the orbital phase.  If the frequency were constant, this would require at least 2ell_mathrmmax samples per orbit.  To incorporate a safety factor, 4ell_mathrmmax seems to work fairly reliably.\n\nSee also the saves_per_orbit and saveat arguments to orbital_evolution, as well as interpolation-in-time capabilities of the result of that function.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.estimated_time_to_merger","page":"Dynamics","title":"PostNewtonian.estimated_time_to_merger","text":"estimated_time_to_merger(M, ŒΩ, v)\nestimated_time_to_merger(pnsystem)\n\nCompute the lowest-order PN approximation for the time to merger, starting from PN velocity parameter v.\n\nThis is used internally as a convenient way to estimate how long the inspiral integration should run for; we don't want it to integrate forever if PN has broken down.  However, it can be a very poor approximation, especially close to merger, and doubly so if the spins or eccentricity are significant.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.fISCO","page":"Dynamics","title":"PostNewtonian.fISCO","text":"fISCO(q, M)\nfISCO(pnsystem)\n\nCompute the \"BKL\" approximation for the ISCO (Innermost Stable Circular Orbit) frequency.\n\nThis is taken from Eq. (5) of Hanna et al. (2008).  Note that this does not account for the spins of the objects in the binary, so that this returns a very crude estimate of a frequency of interest.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.Œ©ISCO","page":"Dynamics","title":"PostNewtonian.Œ©ISCO","text":"Œ©ISCO(q,M)\nŒ©ISCO(pnsystem)\n\n2œÄ times fISCO.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#Detecting-the-up-down-instability","page":"Dynamics","title":"Detecting the up-down instability","text":"","category":"section"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Modules = [PostNewtonian]\nPages   = [\"dynamics/up_down_instability.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/dynamics/#PostNewtonian.up_down_instability-Tuple{Any}","page":"Dynamics","title":"PostNewtonian.up_down_instability","text":"up_down_instability(pnsystem)\n\nCompute the range of frequencies over which the system is unstable to increasing precession.\n\nThe returned value is a pair of dimensionless frequencies giving the lower and upper frequencies between which we can expect instability.  If there is no instability expected, the returned pair is just (1M 1M) ‚Äî where M is the total mass of the system, and 1M is the upper limit of physically reasonable frequencies.\n\nFor compact binaries in which the spins are either aligned or anti-aligned with the orbital angular velocity, we do not expect any precession effects ‚Äî simply by symmetry.  However, if the spin of the higher-mass object is aligned with the orbital angular velocity and the spin of the lower-mass object is anti-aligned, the binary is unstable to precession ‚Äî meaning that any minuscule misalignment can grow rapidly into significant precession.  This was first reported by Gerosa et al. (2015), and the range over which the system is unstable is given by Eq. (2) of that reference.  We use the lowest-order approximation to convert binary separation to frequency.  The result is also \"clamped\" between 0 and 1M, because sometimes the PN approximations involved break down and return values outside of those physically plausible limits.\n\nNote that Gerosa et al. use the convention that q = M_2M_1 ‚Äî which is opposite to the convention used in this package; which we account for internally in this function. They also assume that M_1 geq M_2, which we deal with by automatically swapping the relevant quantities.  Neither of these requires any adjustment by users of this function.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.up_down_instability_warn","page":"Dynamics","title":"PostNewtonian.up_down_instability_warn","text":"function up_down_instability_warn(pnsystem, v‚ÇÅ, v‚Çë, v‚Çó·µ¢‚Çò·µ¢‚Çú=1//2)\n\nIf this system is likely to encounter the up-down instability, log a warning with details.\n\nThis function issues the warning if the system is reasonably non-precessing (chi_perp leq 10^-2) in its current configuration (as given by pnsystem), and the range of frequencies (v‚ÇÅ, v‚Çë) over which it will be integrated is likely to encounter the up-down instability ‚Äî except that frequencies above v‚Çó·µ¢‚Çò·µ¢‚Çú will be ignored, as PN is likely to have broken down anyway.\n\nSee up_down_instability for details of the calculation of the unstable region.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#Approximants","page":"Dynamics","title":"Approximants","text":"","category":"section"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"These compute the right-hand sides for the ODE integration of PN orbital evolutions.  They only differ in how they compute the time dependence of the fundamental PN variable v.  Fundamentally, we have","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"fracdvdt = -fracmathcalF + dotM_1 + dotM_2 mathcalE","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"as the essential expression.  The various approximants differ simply in how they expand this expression.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Note that TaylorT2 and TaylorT3 can also be found in the literature, and are used to derive analytical expressions for the orbital evolution.[2]  Unfortunately, this can only be accomplished for non-precessing systems, so we don't bother to implement them in this package.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"[2]: The second T in the TaylorTn names refers to the fact that these calculations provide the dynamics in the time domain.  In a manner following TaylorT2, it is also possible to use the stationary-phase approximation to derive the dynamics in the frequency domain, thus resulting in the TaylorF2 approximant. Finally, it should be noted that approximants named TaylorK1, TaylorK2, and TaylorEt have also been introduced. None of these other approximants have been implemented in this package.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Modules = [PostNewtonian]\nPages   = [\"dynamics/right_hand_sides.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/dynamics/#PostNewtonian.TaylorT1!-Tuple{Any, Any}","page":"Dynamics","title":"PostNewtonian.TaylorT1!","text":"TaylorT1!(uÃá, pnsystem)\n\nCompute the right-hand side for the orbital evolution of a non-eccentric binary in the \"TaylorT1\" approximant.\n\nThis approximant is the simplest, in which the time derivative dotv is given directly by\n\ndotv = -fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nand the PN expression for each term on the right-hand side is evaluated numerically before insertion directly in this expression.  Compare TaylorT4! and TaylorT5!.\n\nHere, uÃá is the time-derivative of the state vector, which is stored in the PNSystem object p.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.TaylorT4!-Tuple{Any, Any}","page":"Dynamics","title":"PostNewtonian.TaylorT4!","text":"TaylorT4!(uÃá, pnsystem)\n\nCompute the right-hand side for the orbital evolution of a non-eccentric binary in the \"TaylorT4\" approximant.\n\nIn this approximant, we compute dotv by expanding the right-hand side of\n\ndotv = -fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nas a series in v, truncating again at the specified PN order, and only then is the result evaluated.  Compare TaylorT1! and TaylorT5!.\n\nHere, u is the ODE state vector, which should just refer to the state vector stored in the PNSystem object p.  The parameter t represents the time, and will surely always be unused in this package, but is part of the DifferentialEquations API.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.TaylorT5!-Tuple{Any, Any}","page":"Dynamics","title":"PostNewtonian.TaylorT5!","text":"TaylorT5!(uÃá, pnsystem)\n\nCompute the right-hand side for the orbital evolution of a non-eccentric binary in the \"TaylorT5\" approximant.\n\nIn this approximant, we compute dotv by expanding the right-hand side of the inverse of the usual expression\n\nfrac1dotv=fracdtdv = -fracmathcalE mathcalF + dotM_1 + dotM_2\n\nas a series in v, truncating again at the specified PN order, evaluating the result, and then taking the inverse.  This approximant was introduced by Ajith (2011).  Compare TaylorT1! and TaylorT5!.\n\nHere, u is the ODE state vector, which should just refer to the state vector stored in the PNSystem object p.  The parameter t represents the time, and will surely always be unused in this package, but is part of the DifferentialEquations API.\n\n\n\n\n\n","category":"method"}]
}
