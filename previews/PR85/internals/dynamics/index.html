<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamics · PostNewtonian.jl</title><meta name="title" content="Dynamics · PostNewtonian.jl"/><meta property="og:title" content="Dynamics · PostNewtonian.jl"/><meta property="twitter:title" content="Dynamics · PostNewtonian.jl"/><meta name="description" content="Documentation for PostNewtonian.jl."/><meta property="og:description" content="Documentation for PostNewtonian.jl."/><meta property="twitter:description" content="Documentation for PostNewtonian.jl."/><meta property="og:url" content="https://moble.github.io/PostNewtonian.jl/stable/internals/dynamics/"/><meta property="twitter:url" content="https://moble.github.io/PostNewtonian.jl/stable/internals/dynamics/"/><link rel="canonical" href="https://moble.github.io/PostNewtonian.jl/stable/internals/dynamics/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PostNewtonian.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Interface</span><ul><li><a class="tocitem" href="../../interface/high-level/">High-level interface</a></li><li><a class="tocitem" href="../../interface/units/">Units</a></li><li><a class="tocitem" href="../../interface/differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../../interface/assorted_binaries/">Assorted binaries</a></li><li><a class="tocitem" href="../../interface/python/">Python</a></li><li><a class="tocitem" href="../../interface/gwframes/">GWFrames</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../code_structure/">Code structure</a></li><li><a class="tocitem" href="../pn_systems/">PN systems</a></li><li><a class="tocitem" href="../fundamental_variables/">Fundamental variables</a></li><li><a class="tocitem" href="../derived_variables/">Derived variables</a></li><li><a class="tocitem" href="../pn_expressions/">PN expressions</a></li><li class="is-active"><a class="tocitem" href>Dynamics</a><ul class="internal"><li><a class="tocitem" href="#Integrating-orbital-evolution"><span>Integrating orbital evolution</span></a></li><li><a class="tocitem" href="#Detecting-the-up-down-instability"><span>Detecting the up-down instability</span></a></li><li><a class="tocitem" href="#Approximants"><span>Approximants</span></a></li></ul></li><li><a class="tocitem" href="../waveforms/">Waveforms</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li><li><a class="tocitem" href="../../adding_terms/">Adding terms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Dynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dynamics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/PostNewtonian.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/PostNewtonian.jl/blob/main/docs/src/internals/dynamics.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Dynamics"><a class="docs-heading-anchor" href="#Dynamics">Dynamics</a><a id="Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamics" title="Permalink"></a></h1><h2 id="Integrating-orbital-evolution"><a class="docs-heading-anchor" href="#Integrating-orbital-evolution">Integrating orbital evolution</a><a id="Integrating-orbital-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Integrating-orbital-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.orbital_evolution" href="#PostNewtonian.orbital_evolution"><code>PostNewtonian.orbital_evolution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orbital_evolution(pnsystem; kwargs...)
orbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ; kwargs...)</code></pre><p>Integrate the orbital dynamics of an inspiraling non-eccentric compact binary.</p><p><strong>Required arguments</strong></p><p>The first argument to this function may be a single <code>PNSystem</code> that encodes these required arguments (as well as <code>Rᵢ</code>, <code>Λ₁</code>, and <code>Λ₂</code> among the keyword arguments), or the following may be given explicitly:</p><ul><li><code>M₁</code>: Initial mass of object 1</li><li><code>M₂</code>: Initial mass of object 2</li><li><code>χ⃗₁</code>: Initial dimensionless spin of object 1, <code>S⃗₁/M₁²</code></li><li><code>χ⃗₂</code>: Initial dimensionless spin of object 2, <code>S⃗₂/M₂²</code></li><li><code>Ωᵢ</code>: Initial orbital angular frequency</li></ul><p>(Note that the explicit inputs require <code>Ωᵢ</code>, whereas <code>PNSystem</code>s require <code>vᵢ</code> as input.)</p><p>These parameters all describe the &quot;initial&quot; conditions.  See below for an explanation of the different meanings of &quot;initial&quot; and &quot;first&quot; in this context.  Note that the masses change in time as a result of tidal heating — though the changes are quite small throughout most of the inspiral.  The spins change direction due to precession, but also change in magnitude due to tidal heating.  Therefore, the values passed here are only precisely as given <em>precisely at</em> the moment of the initial data corresponding to the frequency <code>Ωᵢ</code>.</p><p><strong>Keyword arguments</strong></p><p>Note that several of these keywords are given as Unicode but can also be given as the ASCII string noted.  For example, <code>Λ₁</code> may be input as <code>Lambda1</code> equivalently; the default values are the same, regardless.</p><ul><li><code>Λ₁=0</code> or <code>Lambda1</code>: Tidal-coupling parameter of object 1.</li><li><code>Λ₂=0</code> or <code>Lambda2</code>: Tidal-coupling parameter of object 2.</li><li><code>Ω₁=Ωᵢ</code> or <code>Omega_1</code>: First angular frequency in output data.  This may be less than <code>Ωᵢ</code>, in which case we integrate backwards to this point, and combine the backwards and forwards solutions into one seamless output.  (See next section.)</li><li><code>Ωₑ=Ω(v=1,M=M₁+M₂)</code> or <code>Omega_e</code>: Final angular frequency at which to stop ODE integration.  Note that integration may stop before the system reaches this frequency, if we detect that PN has broken down irretrievably — for example, if one of the masses is no longer strictly positive, if a spin is super-extremal, or the PN velocity parameter <code>v</code> is decreasing, or is no longer in the range <code>(0,1)</code>.  Warnings will usually only be issued if <code>v &lt; 0.35</code>, but if <code>quiet=true</code> informational messages will be issued.</li><li><code>Rᵢ=Rotor(1)</code> or <code>R_i</code>: Initial orientation of binary.</li><li><code>approximant=&quot;TaylorT1&quot;</code>: Method of evaluating the right-hand side of the evolution equations.  Other possibilities are <a href="#PostNewtonian.TaylorT4!-Tuple{Any, Any}"><code>&quot;TaylorT4&quot;</code></a> and <a href="#PostNewtonian.TaylorT5!-Tuple{Any, Any}"><code>&quot;TaylorT5&quot;</code></a>.  See the documentation of <a href="#PostNewtonian.TaylorT1!-Tuple{Any, Any}"><code>TaylorT1!</code></a> for more details.</li><li><code>PNOrder=typemax(Int)</code>: Order to which to retain powers of <span>$v^2$</span> in PN expansions. The default is to include all available terms in each PN expression.</li><li><code>check_up_down_instability=true</code>: Warn if the &quot;up-down instability&quot; (see below) is likely to affect this system.</li><li><code>time_stepper=Vern9()</code>: Choice of solver in OrdinaryDiffEq to integrate ODE.</li><li><code>abstol=eps(T)^(11//16)</code>: Absolute tolerance of ODE solver, where <code>T</code> is the common type to which all the positional arguments are promoted.  This is the tolerance on local error estimates, not necessarily the global error.  Note that <code>11//16</code> is just chosen to suggest that we will have roughly 11 digits of accuracy (locally) for <code>Float64</code> computations, and a similar accuracy for other float types <em>relative to</em> that type&#39;s epsilon.</li><li><code>reltol=eps(T)^(11//16)</code>: Relative tolerance of ODE solver.  (As above.)</li><li><code>termination_criteria_forwards=nothing</code>: Callbacks to use for forwards-in-time evolution.  See below for discussion of the default value.</li><li><code>termination_criteria_backwards=nothing</code>: Callbacks to use for backwards-in-time evolution.  See below for discussion of the default value.</li><li><code>force_dtmin=true</code>: If <code>dt</code> decreases below the integrator&#39;s own minimum, and this is false, the integrator will immediately raise an error, before the termination criteria have the chance to exit gracefully.  Note that a true value here is critical if the <code>dtmin_terminator</code> callback is to have any effect.</li><li><code>quiet=true</code>: If set to <code>false</code>, informational messages about successful terminations of the ODE integrations (which occur when the target <span>$v$</span> is reached in either direction) will be provided.  Warnings will still be issued when terminating for other reasons; if you wish to silence them too, you should do something like<pre><code class="language-julia hljs">using Logging
with_logger(SimpleLogger(Logging.Error)) do
    &lt;your code goes here&gt;
end</code></pre></li><li><code>saves_per_orbit=0</code>: If greater than 0, the output will be interpolated so that there are <code>saves_per_orbit</code> time steps in the output for each orbit.  Note that this conflicts with the <code>saveat</code> option noted below.</li></ul><p>All remaining keyword arguments are passed to the <a href="https://github.com/SciML/DiffEqBase.jl/blob/8e6173029c630f6908252f3fc28a69c1f0eab456/src/solve.jl#L393"><code>solve</code> function</a> of <code>DiffEqBase</code>.  See that function&#39;s documentation for details, including useful keyword arguments.  The most likely important one is</p><ul><li><code>saveat</code>: Denotes specific times to save the solution at, during the solving phase — either a time step or a vector of specific times.</li></ul><p>In particular, if you want the solution to be output at uniform time steps <code>δt</code>, you want to pass something like <code>saveat=δt</code>; you <em>don&#39;t want</em> the <code>solve</code> keyword <code>dt</code>, which is just the initial suggestion for adaptive systems.  It is not permitted to pass this option <em>and</em> the <code>saves_per_orbit</code> option.</p><p>Also note that <code>callback</code> can be used, and is combined with the callbacks generated by the <code>termination_criteria_*</code> arguments above.  That is, you can use the default ones <em>and</em> your own by passing arguments to <code>callback</code>.  See <a href="https://diffeq.sciml.ai/dev/features/callback_functions/">the documentation</a> for more details, but note that if you want to make your own callbacks, you will need to add <code>OrdinaryDiffEq</code> to your project — or possibly even <code>DifferentialEquations</code> for some of the fancier built-in callbacks.</p><p><strong>ODE system</strong></p><p>The evolved variables, in order, are</p><ul><li><code>M₁</code>: Mass of black hole 1</li><li><code>M₂</code>: Mass of black hole 2</li><li><code>χ⃗₁ˣ</code>: <span>$x$</span> component of dimensionless spin of black hole 1</li><li><code>χ⃗₁ʸ</code>: <span>$y$</span> component...</li><li><code>χ⃗₁ᶻ</code>: <span>$z$</span> component...</li><li><code>χ⃗₂ˣ</code>: <span>$x$</span> component of dimensionless spin of black hole 2</li><li><code>χ⃗₂ʸ</code>: <span>$y$</span> component...</li><li><code>χ⃗₂ᶻ</code>: <span>$z$</span> component...</li><li><code>Rʷ</code>: Scalar component of frame rotor</li><li><code>Rˣ</code>: <span>$x$</span> component...</li><li><code>Rʸ</code>: <span>$y$</span> component...</li><li><code>Rᶻ</code>: <span>$z$</span> component...</li><li><code>v</code>: PN &quot;velocity&quot; parameter related to the total mass <span>$M$</span> and orbital angular frequency <span>$Ω$</span> by <span>$v = (M Ω)^{1/3}$</span></li><li><code>Φ</code>: Orbital phase given by integrating <span>$Ω$</span></li></ul><p>The masses and spin magnitudes evolve according to <a href="../pn_expressions/#PostNewtonian.tidal_heating-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>tidal_heating</code></a>.  The spin directions evolve according to <a href="../pn_expressions/#PostNewtonian.Ω⃗ᵪ₁-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>Ω⃗ᵪ₁</code></a> and <a href="../pn_expressions/#PostNewtonian.Ω⃗ᵪ₂-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>Ω⃗ᵪ₂</code></a>.  The frame precesses with angular velocity <a href="../pn_expressions/#PostNewtonian.Ω⃗ₚ-Tuple{Any}"><code>Ω⃗ₚ</code></a>, while also rotating with angular frequency <code>Ω</code> about the <a href="../derived_variables/#PostNewtonian.DerivedVariables.ℓ̂">Newtonian orbital angular velocity direction</a>.  The frame rotor <span>$R$</span> is given by integrating the sum of these angular velocities as described in <a href="https://arxiv.org/abs/1604.08139">Boyle (2016)</a>.  And finally, the PN parameter <span>$v$</span> evolves according to something like</p><p class="math-container">\[\dot{v} = - \frac{\mathcal{F} + \dot{M}_1 + \dot{M}_2} {\mathcal{E}&#39;}\]</p><p>where <a href="../pn_expressions/#PostNewtonian.𝓕-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>𝓕</code></a> is the flux of gravitational-wave energy out of the system, <span>$\dot{M}_1$</span> and <span>$\dot{M}_2$</span> are due to tidal coupling as computed by <a href="../pn_expressions/#PostNewtonian.tidal_heating-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>tidal_heating</code></a>, and <a href="../pn_expressions/#PostNewtonian.𝓔′-Union{Tuple{PNSystem{ST, PNOrder}}, Tuple{PNExpansionReducer}, Tuple{PNOrder}, Tuple{ST}} where {ST, PNOrder, PNExpansionReducer}"><code>𝓔′</code></a> is the derivative of the binding energy with respect to <span>$v$</span>.  For <code>&quot;TaylorT1&quot;</code>, the right-hand side of this equation is evaluated as given; for <code>&quot;TaylorT4&quot;</code>, the right-hand side is first expanded as a Taylor series in <span>$v$</span> and then truncated at some desired order; for <code>&quot;TaylorT5&quot;</code>, the <em>inverse</em> of the right-hand side is expanded as a Taylor series in <span>$v$</span>, truncated at some desired order, and then inverted to obtain an expression in terms of <span>$v$</span>.</p><p><strong>Returned solution</strong></p><p>The returned quantity is an <a href="https://diffeq.sciml.ai/dev/basics/solution/"><code>ODESolution</code></a> object, which has various features for extracting and interpolating the data.  We&#39;ll call this object <code>sol</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The solution comes with data at the time points the ODE integrator happened to step to.  However, it <em>also</em> comes with dense output (unless you manually turn it off when calling <code>orbital_evolution</code>).  This means that you can interpolate the solution to any other set of time points you want simply by calling it as <code>sol(t)</code> for some vector of time points <code>t</code>.  The quantity returned by that will have all the features described below, much like the original solution.  Note that if you only want some of the data, you can provide the optional keyword argument <code>idxs</code> to specify which of the elements described below you want to interpolate.  For example, if you only want to interpolate the values of <code>M₁</code> and <code>M₂</code>, you can use <code>sol(t, idxs=[1,2])</code>.</p></div></div><p>The field <code>sol.t</code> is the set of time points at which the solution is given.  To access the <code>i</code>th variable at time step <code>j</code>, use <code>sol[i, j]</code>.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> You can also use colons.  For example, <code>sol[:, j]</code> is a vector of all the data at time step <code>j</code>, and <code>sol[i, :]</code> is a vector of the <code>i</code>th variable at all times.</p><p>For convenience, you can also access the individual variables with their symbols.  For example, <code>sol[:v]</code> returns a vector of the PN velocity parameter at each time step.  Note the colon in <code>:v</code>, which is <a href="https://docs.julialang.org/en/v1/base/base/#Core.Symbol">Julia&#39;s notation for a <code>Symbol</code></a>.</p><p><strong>Initial frequency vs. first frequency vs. end frequency</strong></p><p>Note the distinction between <code>Ωᵢ</code> (with subscript <code>i</code>) and <code>Ω₁</code> (with subscript <code>1</code>).  The first, <code>Ωᵢ</code>, represents the angular frequency of the <em>initial condition</em> from which the ODE integrator will begin; the second, <code>Ω₁</code>, represents the target angular frequency of the first element of the output data.  That is, the ODE integration will run forwards in time from <code>Ωᵢ</code> to the merger, and then — if <code>Ωᵢ&gt;Ω₁</code> — come back to <code>Ωᵢ</code> and run backwards in time to <code>Ω₁</code>.  The output data will stitch these two together to be one continuous (forwards-in-time) data series.</p><p>For example, if you are trying to match to a numerical relativity (NR) simulation, you can read the masses and spins off of the NR data when the system is orbiting at angular frequency <code>Ωᵢ</code>.  Integrating the post-Newtonian (PN) solution forwards in time from this point will allow you to compare the PN and NR waveforms.  However, you may want to know what the waveform was at <em>earlier</em> times than are present in the NR data.  For this, you also have to integrate backwards in time.  We parameterize the point to which you integrate backwards with <code>Ω₁</code>.  In either case, element <code>1</code> of the output solution will have frequency <code>Ω₁</code> — though by default it is equal to <code>Ωᵢ</code>.</p><p>Similarly, the optional argument <code>Ωₑ=1</code> is the frequency of the <code>end</code> element of the solution — that is Julia&#39;s notation for the last element.  Note that this is automatically reduced if necessary so that the corresponding PN parameter <span>$v$</span> is no greater than 1, which may be the case whenever the total mass is greater than 1.</p><p><strong>Up-down instability</strong></p><p>Be aware that the <a href="http://arxiv.org/abs/1506.09116">up-down instability</a> (where the more massive black hole has spin aligned with the orbital angular velocity, and the less massive has spin anti-aligned) can cause systems with nearly zero precession at the initial time to evolve into a highly precessing system either at earlier or later times.  This is a real physical result, rather than a numerical issue.  If you want to simulate a truly non-precessing system, you should explicitly set the in-place components of spin to precisely 0.  By default, we check for this condition, and will issue a warning if it is likely to be encountered for systems with low initial precession.  The function used to compute the unstable region is <a href="#PostNewtonian.up_down_instability-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>up_down_instability</code></a>.</p><p><strong>Time-stepper algorithms</strong></p><p><code>Tsit5()</code> is a good default choice for time stepper when using <code>Float64</code> with medium-low tolerance.  If stiffness seems to be impacting the results, <code>AutoTsit5(Rosenbrock23())</code> will automatically switch when stiffness occurs.  For tighter tolerances, especially when using <code>Double64</code>s, <code>Vern9()</code> or <code>AutoVern9(Rodas5P())</code> are good choices.  For very loose tolerances, as when using <code>Float32</code>s, it might be better to use <code>OwrenZen3()</code>.</p><p><strong>Termination criteria</strong></p><p>The termination criteria are vital to efficiency of the integration and correctness of the solution.  The default values for forwards- and backwards-in-time evolution, respectively, are</p><pre><code class="language-julia hljs">CallbackSet(
    termination_forwards(v(Ω=Ωₑ, M=M₁+M₂)),
    dtmin_terminator(T),
    decreasing_v_terminator(),
    nonfinite_terminator()
)</code></pre><p>and</p><pre><code class="language-julia hljs">CallbackSet(
    termination_backwards(v(Ω=Ω₁, M=M₁+M₂)),
    dtmin_terminator(T),
    nonfinite_terminator()
)</code></pre><p>where <code>T</code> is the common float type of the input arguments.  If any additional termination criteria are needed, they could be added as additional elements of the <code>CallbackSet</code>s.  See the <a href="https://diffeq.sciml.ai/stable/features/callback_functions/">callback documentation</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/orbital_evolution.jl#L116-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.uniform_in_phase" href="#PostNewtonian.uniform_in_phase"><code>PostNewtonian.uniform_in_phase</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_in_phase(solution, saves_per_orbit)</code></pre><p>Interpolate <code>solution</code> to uniform steps in phase.</p><p>By default, the <code>solution</code> returned by <a href="#PostNewtonian.orbital_evolution"><code>orbital_evolution</code></a> may be sampled very sparsely — too sparsely to satisfy the Nyquist limit of the waveform.  If the waveform extends to <span>$\ell_{\mathrm{max}}$</span>, there will be modes varying slightly more rapidly than <span>$\exp\left(\pm i\, \ell_{\mathrm{max}}\, \Phi \right)$</span>, where <span>$\Phi$</span> is the orbital phase.  If the frequency were constant, this would require at least <span>$2\ell_{\mathrm{max}}$</span> samples per orbit.  To incorporate a safety factor, <span>$4\ell_{\mathrm{max}}$</span> seems to work fairly reliably.</p><p>See also the <code>saves_per_orbit</code> and <code>saveat</code> arguments to <a href="#PostNewtonian.orbital_evolution"><code>orbital_evolution</code></a>, as well as interpolation-in-time capabilities of the result of that function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/orbital_evolution.jl#L56-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.estimated_time_to_merger" href="#PostNewtonian.estimated_time_to_merger"><code>PostNewtonian.estimated_time_to_merger</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">estimated_time_to_merger(M, ν, v)
estimated_time_to_merger(pnsystem)</code></pre><p>Compute the lowest-order PN approximation for the time to merger, starting from PN velocity parameter <code>v</code>.</p><p>This is used internally as a convenient way to estimate how long the inspiral integration should run for; we don&#39;t want it to integrate forever if PN has broken down.  However, it can be a very poor approximation, especially close to merger, and doubly so if the spins or eccentricity are significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/orbital_evolution.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.fISCO" href="#PostNewtonian.fISCO"><code>PostNewtonian.fISCO</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fISCO(q, M)
fISCO(pnsystem)</code></pre><p>Compute the &quot;BKL&quot; approximation for the ISCO (Innermost Stable Circular Orbit) frequency.</p><p>This is taken from Eq. (5) of <a href="https://arxiv.org/abs/0801.4297">Hanna et al. (2008)</a>.  Note that this does not account for the spins of the objects in the binary, so that this returns a very crude estimate of a frequency of interest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/orbital_evolution.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.ΩISCO" href="#PostNewtonian.ΩISCO"><code>PostNewtonian.ΩISCO</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ΩISCO(q,M)
ΩISCO(pnsystem)</code></pre><p>2π times <a href="#PostNewtonian.fISCO"><code>fISCO</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/orbital_evolution.jl#L43-L48">source</a></section></article><h2 id="Detecting-the-up-down-instability"><a class="docs-heading-anchor" href="#Detecting-the-up-down-instability">Detecting the up-down instability</a><a id="Detecting-the-up-down-instability-1"></a><a class="docs-heading-anchor-permalink" href="#Detecting-the-up-down-instability" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.up_down_instability-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer" href="#PostNewtonian.up_down_instability-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>PostNewtonian.up_down_instability</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">up_down_instability(pnsystem)</code></pre><p>Compute the range of frequencies over which the system is unstable to increasing precession.</p><p>The returned value is a pair of dimensionless frequencies giving the lower and upper frequencies between which we can expect instability.  If there is no instability expected, the returned pair is just <span>$(1/M, 1/M)$</span> — where <span>$M$</span> is the total mass of the system, and <span>$1/M$</span> is the upper limit of physically reasonable frequencies.</p><p>For compact binaries in which the spins are either aligned or anti-aligned with the orbital angular velocity, we do not expect any precession effects — simply by symmetry.  However, if the spin of the higher-mass object is aligned with the orbital angular velocity and the spin of the lower-mass object is anti-aligned, the binary is unstable to precession — meaning that any minuscule misalignment can grow rapidly into significant precession.  This was first reported by <a href="http://arxiv.org/abs/1506.09116">Gerosa et al. (2015)</a>, and the range over which the system is unstable is given by Eq. (2) of that reference.  We use the lowest-order approximation to convert binary separation to frequency.  The result is also &quot;clamped&quot; between <span>$0$</span> and <span>$1/M$</span>, because sometimes the PN approximations involved break down and return values outside of those physically plausible limits.</p><p>Note that Gerosa et al. use the convention that <span>$q = M_2/M_1$</span> — which is opposite to the convention used in <a href="../derived_variables/#PostNewtonian.DerivedVariables.q">this package</a>; which we account for internally in this function. They also assume that <span>$M_1 \geq M_2$</span>, which we deal with by automatically swapping the relevant quantities.  Neither of these requires any adjustment by users of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/up_down_instability.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.up_down_instability_warn-Union{Tuple{PNExpansionReducer}, Tuple{Any, Any, Any}, NTuple{4, Any}} where PNExpansionReducer" href="#PostNewtonian.up_down_instability_warn-Union{Tuple{PNExpansionReducer}, Tuple{Any, Any, Any}, NTuple{4, Any}} where PNExpansionReducer"><code>PostNewtonian.up_down_instability_warn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function up_down_instability_warn(pnsystem, v₁, vₑ, vₗᵢₘᵢₜ=1//2)</code></pre><p>If this system is likely to encounter the up-down instability, log a warning with details.</p><p>This function issues the warning if the system is reasonably non-precessing (<span>$\chi_\perp \leq 10^{-2}$</span>) in its current configuration (as given by <code>pnsystem</code>), and the range of frequencies <code>(v₁, vₑ)</code> over which it will be integrated is likely to encounter the up-down instability — except that frequencies above <code>vₗᵢₘᵢₜ</code> will be ignored, as PN is likely to have broken down anyway.</p><p>See <a href="#PostNewtonian.up_down_instability-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer"><code>up_down_instability</code></a> for details of the calculation of the unstable region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/up_down_instability.jl#L51-L63">source</a></section></article><h2 id="Approximants"><a class="docs-heading-anchor" href="#Approximants">Approximants</a><a id="Approximants-1"></a><a class="docs-heading-anchor-permalink" href="#Approximants" title="Permalink"></a></h2><p>These compute the right-hand sides for the ODE integration of PN orbital evolutions.  They only differ in how they compute the time dependence of the fundamental PN variable <span>$v$</span>.  Fundamentally, we have</p><p class="math-container">\[\frac{dv}{dt} = -\frac{\mathcal{F} + \dot{M}_1 + \dot{M}_2} {\mathcal{E}&#39;}\]</p><p>as the essential expression.  The various approximants differ simply in how they expand this expression.  Details are explained in the following docstrings, but in principle the differences should be at the next-highest PN order beyond the orders to which the factors are calculated.</p><p>Note that <code>TaylorT2</code> and <code>TaylorT3</code> can also be <a href="https://arxiv.org/abs/0710.0158">found in the literature</a>, and are used to derive analytical expressions for the orbital evolution.<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>  Unfortunately, this can only be accomplished for non-precessing systems, so we don&#39;t bother to implement them in this package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.TaylorT1!-Tuple{Any, Any}" href="#PostNewtonian.TaylorT1!-Tuple{Any, Any}"><code>PostNewtonian.TaylorT1!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorT1!(u̇, pnsystem)</code></pre><p>Compute the right-hand side for the orbital evolution of a non-eccentric binary in the &quot;TaylorT1&quot; approximant.</p><p>This approximant is the simplest, in which the time derivative <span>$\dot{v}$</span> is given directly by</p><p class="math-container">\[\dot{v} = -\frac{\mathcal{F} + \dot{M}_1 + \dot{M}_2} {\mathcal{E}&#39;},\]</p><p>and the PN expression for each term on the right-hand side is evaluated numerically before insertion directly in this expression.  Compare <a href="#PostNewtonian.TaylorT4!-Tuple{Any, Any}"><code>TaylorT4!</code></a> and <a href="#PostNewtonian.TaylorT5!-Tuple{Any, Any}"><code>TaylorT5!</code></a>.</p><p>Here, <code>u̇</code> is the time-derivative of the state vector, which is stored in the <a href="../pn_systems/#PostNewtonian.PNSystem"><code>PNSystem</code></a> object <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/right_hand_sides.jl#L57-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.TaylorT1RHS!" href="#PostNewtonian.TaylorT1RHS!"><code>PostNewtonian.TaylorT1RHS!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorT1RHS!</code></pre><p>A <code>SciMLBase.ODEFunction</code> wrapper for <a href="#PostNewtonian.TaylorT1!-Tuple{Any, Any}"><code>TaylorT1!</code></a>, suitable for passing into <code>OrdinaryDiffEq.solve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/right_hand_sides.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.TaylorT4!-Tuple{Any, Any}" href="#PostNewtonian.TaylorT4!-Tuple{Any, Any}"><code>PostNewtonian.TaylorT4!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorT4!(u̇, pnsystem)</code></pre><p>Compute the right-hand side for the orbital evolution of a non-eccentric binary in the &quot;TaylorT4&quot; approximant.</p><p>In this approximant, we compute <span>$\dot{v}$</span> by expanding the right-hand side of</p><p class="math-container">\[\dot{v} = -\frac{\mathcal{F} + \dot{M}_1 + \dot{M}_2} {\mathcal{E}&#39;}\]</p><p>as a series in <span>$v$</span>, truncating again at the specified PN order, and only then is the result evaluated.  Compare <a href="#PostNewtonian.TaylorT1!-Tuple{Any, Any}"><code>TaylorT1!</code></a> and <a href="#PostNewtonian.TaylorT5!-Tuple{Any, Any}"><code>TaylorT5!</code></a>.</p><p>Here, <code>u</code> is the ODE state vector, which should just refer to the <code>state</code> vector stored in the <a href="../pn_systems/#PostNewtonian.PNSystem"><code>PNSystem</code></a> object <code>p</code>.  The parameter <code>t</code> represents the time, and will surely always be unused in this package, but is part of the <code>DifferentialEquations</code> API.</p><div class="admonition is-info"><header class="admonition-header">Truncation order vs. `PNOrder` vs. PN order</header><div class="admonition-body"><p>When expanding the fraction given above as a series in <span>$v$</span>, the truncation order is not necessarily the value of <code>PNOrder</code> given in the input <code>p</code>.  Instead, it is the highest order of the series that is present in the numerator or denominator — which is what we would normally <em>call</em> the PN order of those expansions.  The <code>PNOrder</code> parameter is the highest order of the series that is <em>allowed</em> to be present in those expansions, so that if <code>PNOrder</code> is <code>typemax(Int)</code>, the series will be expanded to the highest order given in any of the PN expansions, but the expansion of the ratio will not go to infinite order.  This is the reason that <code>TaylorT4</code> and <code>TaylorT5</code> do not approach <code>TaylorT1</code> as <code>PNOrder</code> approaches <code>typemax(Int)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/right_hand_sides.jl#L85-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.TaylorT4RHS!" href="#PostNewtonian.TaylorT4RHS!"><code>PostNewtonian.TaylorT4RHS!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorT4RHS!</code></pre><p>A <code>SciMLBase.ODEFunction</code> wrapper for <a href="#PostNewtonian.TaylorT4!-Tuple{Any, Any}"><code>TaylorT4!</code></a>, suitable for passing into <code>OrdinaryDiffEq.solve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/right_hand_sides.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.TaylorT5!-Tuple{Any, Any}" href="#PostNewtonian.TaylorT5!-Tuple{Any, Any}"><code>PostNewtonian.TaylorT5!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorT5!(u̇, pnsystem)</code></pre><p>Compute the right-hand side for the orbital evolution of a non-eccentric binary in the &quot;TaylorT5&quot; approximant.</p><p>In this approximant, we compute <span>$\dot{v}$</span> by expanding the right-hand side of <em>the multiplicative inverse of</em> the usual expression</p><p class="math-container">\[\frac{1}{\dot{v}}=\frac{dt}{dv} = -\frac{\mathcal{E}&#39;} {\mathcal{F} + \dot{M}_1 + \dot{M}_2}\]</p><p>as a series in <span>$v$</span>, truncating again at the specified PN order, evaluating the result, and then taking the multiplicative inverse again to find <span>$\dot{v}$</span>.  This approximant was introduced by <a href="https://arxiv.org/abs/1107.1267">Ajith (2011)</a> [see Eq. (3.5)].  Compare <a href="#PostNewtonian.TaylorT1!-Tuple{Any, Any}"><code>TaylorT1!</code></a> and <a href="#PostNewtonian.TaylorT4!-Tuple{Any, Any}"><code>TaylorT4!</code></a>.</p><p>Here, <code>u</code> is the ODE state vector, which should just refer to the <code>state</code> vector stored in the <a href="../pn_systems/#PostNewtonian.PNSystem"><code>PNSystem</code></a> object <code>p</code>.  The parameter <code>t</code> represents the time, and will surely always be unused in this package, but is part of the <code>DifferentialEquations</code> API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/right_hand_sides.jl#L124-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.TaylorT5RHS!" href="#PostNewtonian.TaylorT5RHS!"><code>PostNewtonian.TaylorT5RHS!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorT5RHS!</code></pre><p>A <code>SciMLBase.ODEFunction</code> wrapper for <a href="#PostNewtonian.TaylorT5!-Tuple{Any, Any}"><code>TaylorT5!</code></a>, suitable for passing into <code>OrdinaryDiffEq.solve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/dynamics/right_hand_sides.jl#L147-L152">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Truncation order vs. `PNOrder` vs. PN order</header><div class="admonition-body"><p>When expanding the fraction given above as a series in <span>$v$</span>, the truncation order is not necessarily the value of <code>PNOrder</code> given in the input <code>p</code>.  Instead, it is the highest order of the series that is present in the numerator or denominator — which is what we would normally <em>call</em> the PN order of those expansions.  The <code>PNOrder</code> parameter is the highest order of the series that is <em>allowed</em> to be present in those expansions, so that if <code>PNOrder</code> is effectively infinite, the series will be expanded to the highest order given in any of the PN expansions, but the expansion of the ratio will not go to infinite order.  This is the reason that <code>TaylorT4</code> and <code>TaylorT5</code> <em>do not</em> approach <code>TaylorT1</code> as <code>PNOrder</code> approaches <code>typemax(Int)</code>.  This design decision was made to ensure feasibility of the calculations.</p></div></div><p>Note that, internally, the <code>TaylorT*</code> functions call <code>causes_domain_error!</code>.  This is a fairly simplistic detection of when evolved parameters will lead to bad values.  It may be desirable to extend this detection to be more sophisticated.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.causes_domain_error!" href="#PostNewtonian.causes_domain_error!"><code>PostNewtonian.causes_domain_error!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">causes_domain_error!(u̇, p)</code></pre><p>Ensure that these parameters correspond to a physically valid set of PN parameters.</p><p>If the parameters are not valid, this function should modify <code>u̇</code> to indicate that the current step is invalid.  This is done by filling <code>u̇</code> with <code>NaN</code>s, which will be detected by the ODE solver and cause it to try a different (smaller) step size.</p><p>Currently, the only check that is done is to test that these parameters result in a PN parameter v&gt;0.  In the future, this function may be expanded to include other checks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/127db7a3bdcaffbebaf7167f647095d23bb0d809/src/pn_systems.jl#L37-L48">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Here, the <code>i</code>th variable just refers to which number it has in the list of evolved   variables in the ODE system, as described under &quot;ODE system&quot;.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>The second <code>T</code> in the <code>TaylorTn</code> names refers to the fact that these calculations provide the dynamics in the <em>time</em> domain.  In a manner following <code>TaylorT2</code>, it is also possible to use the stationary-phase approximation to derive the dynamics in the <em>frequency</em> domain, thus resulting in <a href="https://arxiv.org/abs/0901.1628">the <code>TaylorF2</code> approximant</a>.  Finally, it should be noted that approximants named <code>TaylorK1</code>, <code>TaylorK2</code>, and <code>TaylorEt</code> <a href="https://arxiv.org/abs/0712.3236">have also been introduced</a>.  None of these other approximants have been implemented in this package.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pn_expressions/">« PN expressions</a><a class="docs-footer-nextpage" href="../waveforms/">Waveforms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 22 April 2025 18:42">Tuesday 22 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
