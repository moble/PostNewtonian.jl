var documenterSearchIndex = {"docs":
[{"location":"interface/python/#Using-this-package-from-Python","page":"Python","title":"Using this package from Python","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"While not quite as natural as calling Python code from Julia, it is very easy to call Julia code from Python.  The process is essentially the same as using any other Python package, other than installing Julia itself and any dependencies within Julia that you may need (both of which are much easier than similar tasks in Python).","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"warning: Be careful of using unicode in Python!\nEvery effort is made to ensure that users of this package can always use plain ASCII — even though this package uses Unicode internally and in many of the examples found in this documentation.  For example, if keyword arguments are accepted as Unicode, ASCII equivalents are usually also accepted.  Some function names are similarly in Unicode, but have ASCII equivalents.  See the various functions' documentation for acceptable replacements.It can be dangerous to use Unicode in Python in particular. Python only accepts a small subset of Unicode — so that M₁ for example is not valid input.  And what it does accept is automatically \"NFKC normalized\". For example, variable names Mₐ, Ma, and Mᵃ are all treated identically by Python.  To illustrate this, consider the following python code:>>> Mₐ = 1\n>>> Mᵃ = 2\n>>> Ma = 3\n>>> print((Mₐ, Mᵃ, Ma))\n(3, 3, 3)We might have expected three different values (1, 2, 3) in the output, but Python never even sees the variable names as different strings; it interprets these expressions as setting, resetting, and resetting again the value of Ma.If you find an example where ASCII substitutions are not possible, please file a bug report.","category":"page"},{"location":"interface/python/#Installation","page":"Python","title":"Installation","text":"","category":"section"},{"location":"interface/python/#0.-Optionally-pre-install-Julia","page":"Python","title":"0. Optionally pre-install Julia","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"If you'll want to use Julia from outside of Python, install Julia first with the juliaup installer.","category":"page"},{"location":"interface/python/#1.-Install-the-sxs-python-package","page":"Python","title":"1. Install the sxs python package","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"While not strictly necessary, the sxs python package is very useful for providing a general interface to waveforms, and will automatically install the PostNewtonian package and its dependencies (and even Julia, if necessary).","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"If you use conda, just run something like[1]","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"conda install -c conda-forge sxs numba::numba numba::llvmlite","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"If you prefer pip, use","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"python -m pip install sxs","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"danger: Avoid segfaults on macOS\nIf using conda/mamba on macOS, you must install the correct versions of numba and llvmlite, or you will get segfaults. Specifically, you must include the numba:: prefix to select the correct anaconda channel, as shown in the command given above.  A more permanent solution is to run the following commands:conda config --set channel_priority strict\nconda config --add channels conda-forge --prepend channels numbaThis will automatically choose the correct versions of numba and llvmlite for your system, without the need to explicitly use the numba:: prefix ever again.","category":"page"},{"location":"interface/python/#2.-Install-Julia-and-PostNewtonian.jl","page":"Python","title":"2. Install Julia and PostNewtonian.jl","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"The following line will take a few minutes to install Julia (if necessary), then download and compile all the necessary Julia packages.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"python -c 'from sxs import julia'","category":"page"},{"location":"interface/python/#Testing-the-installation","page":"Python","title":"Testing the installation","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"danger: Import this package first\nWhen using this package from Python with any other non-standard libraries — like scri or lal — you should always import sxs.julia or one of its components first in your Python session. This is because those packages may use the same compiled libraries as this package, in the form of shared objects, like libfftw3.  But because Python packaging is so desperately bad, the libraries that come with Python packages are often quite old and will interfere with the operation of this package.  Loading this package first ensures that newer versions of the libraries are loaded, which will typically be backwards compatible.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Start up a python session and run something like this:","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"# Any python imports you need go here\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Start the Julia session\nfrom sxs.julia import PNWaveform\n\n# Declare the essential parameters\nM1 = 0.5\nM2 = 0.5\nchi1 = [0.1, 0.2, 0.3]\nchi2 = [-0.2, 0.1, -0.3]\nOmega_i = 0.01\n\n# Call `sxs` wrapper for Julia functions\nw = PNWaveform(M1, M2, chi1, chi2, Omega_i)\n\n# Plot the magnitudes of all the modes as functions of time\nplt.semilogy(w.t, np.abs(w.data))","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"The sxs.julia.PNWaveform function is a simple wrapper that calls orbital_evolution and inertial_waveform, then wraps the result in an sxs.WaveformModes object, with all the usual methods and properties, as well as several additional fields relevant to post-Newtonian waveforms:","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"M1 (array): The primary mass as a function of time.\nM2 (array): The secondary mass as a function of time.\nchi1 (array): The primary spin as a function of time.\nchi2 (array): The secondary spin as a function of time.\nframe (array): The quaternionic frame as a function of time.\nv (array): The orbital velocity as a function of time.\norbital_phase (array): The orbital phase as a function of   time.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"The input arguments for sxs.julia.PNWaveform are mostly the same as for orbital_evolution, except that the keyword argument inertial will switch whether the returned waveform will be in the inertial frame (the default of True) or the coorbital frame (False), and the keyword arguments ell_min, ell_max, and waveform_pn_order will be intercepted and passed to inertial_waveform or coorbital_waveform correspondingly.","category":"page"},{"location":"interface/python/#Full-Julia-interface-from-Python","page":"Python","title":"Full Julia interface from Python","text":"","category":"section"},{"location":"interface/python/","page":"Python","title":"Python","text":"In general, you can now call any function from the Julia PostNewtonian package by running","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"from sxs.julia import PostNewtonian","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"and then calling the function just as you would if you had run import PostNewtonian in Julia.  That is, any of the functions given in the rest of this documentation should be available in Python, just as they would be in Julia.  (Again, note that all function names and arguments should have ASCII equivalents to use from Python.)","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"You can also evaluate arbitrary Julia code by prefixing PostNewtonian. to the command, or as a fallback write Julia code as a string and pass it to PostNewtonian.seval(\"<Julia code goes here>\").  Simple examples include","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":">>> PostNewtonian.println(\"Hello from Julia!\")\nHello from Julia!\n>>> x = PostNewtonian.seval(\"1+2\")\n>>> x\n3","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"See the documentation for juliacall here for more details.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Whenever they correspond naturally to built-in Python types — like int, float, str, etc. — the returned objects will be converted to such Python objects.  Otherwise, the returned objects will be wrappers around Julia Vectors, Matrixes, or more generally shaped Arrays.  Usually, you will be able to pass these objects directly to Python functions.  If you really need a numpy array, you can use the to_numpy() method that the wrappers will support.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"Of course, it is much simpler to call Python code from Julia, so if you find yourself using a lot of Julia code, you may want to consider flipping your approach.","category":"page"},{"location":"interface/python/","page":"Python","title":"Python","text":"[1]: As general advice, you should run conda install -y mamba -n   base -c conda-forge, and then just use the command mamba   wherever you would have used conda; mamba is a complete   drop-in replacement, but is much faster because it's written in   C instead of python.  For example, mamba create -n julia_pn   python numpy matplotlib will typically run faster than the   command given here.  This becomes a huge advantage when the env   has lots of dependencies.","category":"page"},{"location":"interface/symbolics/#Symbolic-manipulations","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"","category":"section"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"It can be useful to evaluate the post-Newtonian expressions with symbolic arguments.  To do so, we just need to create a PNSystem containing a state vector of symbols.  All of the variables defined in PostNewtonian.FundamentalVariables and PostNewtonian.DerivedVariables have methods defined automatically to generate symbols instead of values when called with a symbolic PNSystem.  In turn, any function modified by the @pn_expression macro should also be able to return a symbolic result, including all functions described in the \"PN expressions\" section.","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"For convenience, an extension to this package also provides SymbolicPNSystem, which produces a PNSystem with all the fundamental variables stored as Symbolics.jl variables — as long as the Symbolics package is also loaded.  We can extract the symbols as usual:","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"julia> using PostNewtonian, Symbolics\n\njulia> symbolic_pnsystem = PostNewtonian.SymbolicPNSystem()\nPostNewtonian.SymbolicPNSystem{Vector{Num}, 9223372036854775805//2, Num}(Num[M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, Φ], Λ₁, Λ₂)\n\njulia> v = PostNewtonian.v(symbolic_pnsystem)\nv","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"More generally, we can obtain a symbolic expression for the binding energy as","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"julia> 𝓔(symbolic_pnsystem)\n(-1//2)*(1 + (v^2)*(-(3//4) - (1//12)*ν) + (v^3)*((14//3)*sₗ + 2δ*σₗ) + [...]","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"In fact, this is how the derivative-of-binding-energy function 𝓔′ used to be constructed, essentially as","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"julia> ∂ᵥ = Differential(v);\n\njulia> expand_derivatives(∂ᵥ(𝓔(symbolic_pnsystem)))\n-(1 + (v^2)*(-(3//4) - (1//12)*ν) + (v^3)*((14//3)*sₗ + 2δ*σₗ) + [...]","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"Note that special care is taken to preserve the types of Irrationals and the arguments of certain functions like sqrt and log. Ordinarily, Julia will evaluate these as Float64s; to ensure that they remain symbolic, we have to wrap them in a function that Symbolics.jl will know not to bother expanding: PostNewtonian.hold.  While manipulating these expressions symbolically, you'll probably want to leave those hold calls as they are.  If you convert the expressions to code, Julia will compile them away easily, so you don't need to do anything more.  However, you can remove them using PostNewtonian.unhold if the code is in Expr form.","category":"page"},{"location":"interface/symbolics/","page":"Symbolic manipulations","title":"Symbolic manipulations","text":"PostNewtonian.hold\nPostNewtonian.unhold\nPostNewtonian.SymbolicPNSystem","category":"page"},{"location":"interface/symbolics/#PostNewtonian.hold","page":"Symbolic manipulations","title":"PostNewtonian.hold","text":"hold(x)\n\nDelay evaluation of the argument in Symbolics expressions.\n\nThis is just a helper function that acts trivially — like the identity function — but also gets registered with Symbolics to avoid evaluation of the argument.  For example, we can preserve expressions like π^2, which Julia would normally convert directly to a Float64.\n\nNote that you probably don't want to use this function directly; this will probably be done for you by @pn_expression or similar.  If you do want to use this directly, you probably want another layer of indirection to construct something like Symbolics.Num(SymbolicUtils.Term(hold, [x])) so that you can use the result in a symbolic expression.\n\n\n\n\n\n","category":"function"},{"location":"interface/symbolics/#PostNewtonian.unhold","page":"Symbolic manipulations","title":"PostNewtonian.unhold","text":"unhold(expr)\n\nRemove occurrences of hold from an Expr.\n\n\n\n\n\n","category":"function"},{"location":"interface/symbolics/#PostNewtonian.SymbolicPNSystem","page":"Symbolic manipulations","title":"PostNewtonian.SymbolicPNSystem","text":"SymbolicPNSystem{ST, PNOrder, ET}(state, Λ₁, Λ₂)\n\nA PNSystem that contains information as variables from Symbolics.jl.\n\nExamples\n\njulia> using Symbolics\n\njulia> using PostNewtonian: M₁, M₂, χ⃗₁, χ⃗₂, SymbolicPNSystem\n\njulia> symbolic_pnsystem = SymbolicPNSystem()\nSymbolicPNSystem{Vector{Num}, 9223372036854775805//2, Num}(Num[M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, Φ], Λ₁, Λ₂)\n\njulia> M₁(symbolic_pnsystem), M₂(symbolic_pnsystem)\n(M₁, M₂)\n\njulia> χ⃗₁(symbolic_pnsystem)\nχ⃗₁\n\njulia> χ⃗₂(symbolic_pnsystem)\nχ⃗₂\n\n\n\n\n\n","category":"type"},{"location":"internals/derived_variables/#Derived-variables","page":"Derived variables","title":"Derived variables","text":"","category":"section"},{"location":"internals/derived_variables/#Orbital-elements","page":"Derived variables","title":"Orbital elements","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"n̂\nλ̂\nℓ̂\nΩ","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.n̂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.n̂","text":"n̂(pnsystem)\nn̂(R)\nn_hat(pnsystem)\nn_hat(R)\n\nThe unit vector pointing from object 2 to object 1, when the frame is given by the rotor R.  This is equal to\n\nn(R) = R x R\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.λ̂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.λ̂","text":"λ̂(pnsystem)\nλ̂(R)\nlambda_hat(pnsystem)\nlambda_hat(R)\n\nThe unit vector pointing in the direction of the instantaneous velocity of object 1, when the frame is given by the rotor R.  This is equal to\n\nλ(R) = R y R\n\nThis also completes the right-handed triple of (n λ ℓ).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ℓ̂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ℓ̂","text":"ℓ̂(pnsystem)\nℓ̂(R)\nell_hat(pnsystem)\nell_hat(R)\n\nThe unit vector pointing along the direction of orbital angular velocity, when the frame is given by the rotor R.  This is equal to\n\nℓ(R) = R z R\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Ω","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Ω","text":"Ω(pnsystem)\nΩ(;v, M=1)\nOmega(pnsystem)\nOmega(;v, M=1)\n\nOrbital angular frequency.\n\nThe parameter v is the PN velocity parameter, and must be passed as a keyword argument — as in Ω(v=0.1).  The parameter M is the total mass of the binary.  They are related by definition as\n\nOmega colonequals fracv^3M\n\nSee also v.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#Mass-combinations","page":"Derived variables","title":"Mass combinations","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"PostNewtonian.M\nPostNewtonian.μ\nPostNewtonian.ν\nPostNewtonian.δ\nPostNewtonian.q\nPostNewtonian.ℳ\nPostNewtonian.X₁\nPostNewtonian.X₂","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.M","page":"Derived variables","title":"PostNewtonian.DerivedVariables.M","text":"M(pnsystem)\nM(M₁, M₂)\ntotal_mass(pnsystem)\ntotal_mass(M1, M2)\n\nCompute the total mass M₁+M₂.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.μ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.μ","text":"μ(pnsystem)\nμ(M₁, M₂)\nreduced_mass(pnsystem)\nreduced_mass(M1, M2)\n\nCompute the reduced mass (M₁ M₂)(M₁+M₂).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ν","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ν","text":"ν(pnsystem)\nν(M₁, M₂)\nreduced_mass_ratio(pnsystem)\nreduced_mass_ratio(M1, M2)\n\nCompute the reduced mass ratio (M₁ M₂)(M₁+M₂)^2.\n\nNote that the denominator is squared, unlike in the reduced mass μ.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.δ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.δ","text":"δ(pnsystem)\nδ(M₁, M₂)\nmass_difference_ratio(pnsystem)\nmass_difference_ratio(M1, M2)\n\nCompute mass-difference ratio (M₁-M₂)(M₁+M₂).\n\nNote that we do not restrict to M₁  M₂ or vice versa; if you prefer that δ always be positive (or always negative), you are responsible for ensuring that.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.q","page":"Derived variables","title":"PostNewtonian.DerivedVariables.q","text":"q(pnsystem)\nq(M₁, M₂)\nmass_ratio(pnsystem)\nmass_ratio(M1, M2)\n\nCompute mass ratio M₁M₂.\n\nNote that we do not restrict to M₁  M₂ or vice versa; if you prefer that q always be greater than or equal to 1 (or vice versa), you are responsible for ensuring that.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ℳ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ℳ","text":"ℳ(pnsystem)\nℳ(M₁, M₂)\nchirp_mass(pnsystem)\nchirp_mass(M1, M2)\n\nCompute the chirp mass ℳ, which determines the leading-order orbital evolution of a binary system due to energy loss by gravitational-wave emission.\n\nThe chirp mass is defined as\n\n  mathcalM = frac(M_1 M_2)^35 (M_1 + M_2)^15\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.X₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.X₁","text":"X₁(pnsystem)\nX₁(M₁, M₂)\nX1(pnsystem)\nX1(M1, M2)\n\nCompute the reduced individual mass M₁(M₁+M₂).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.X₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.X₂","text":"X₂(pnsystem)\nX₂(M₁, M₂)\nX2(pnsystem)\nX2(M1, M2)\n\nCompute the reduced individual mass M₂(M₁+M₂).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#Spin-combinations","page":"Derived variables","title":"Spin combinations","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"S⃗₁\nS⃗₂\nS⃗\nΣ⃗\nχ⃗\nχ⃗ₛ\nχ⃗ₐ\nχₑ\nχₚ\nPostNewtonian.S⃗₀⁺\nPostNewtonian.S⃗₀⁻","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S⃗₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S⃗₁","text":"S⃗₁(pnsystem)\n\nDimensionful spin vector of object 1.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S⃗₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S⃗₂","text":"S⃗₂(pnsystem)\n\nDimensionful spin vector of object 2.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S⃗","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S⃗","text":"S⃗(pnsystem)\nS⃗(M₁, M₂, χ⃗₁, χ⃗₂)\n\nTotal (dimensionful) spin vector S₁+S₂.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Σ⃗","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Σ⃗","text":"Σ⃗(pnsystem)\nΣ⃗(M₁, M₂, χ⃗₁, χ⃗₂)\n\nDifferential spin vector M(a₂-a₁).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.χ⃗","page":"Derived variables","title":"PostNewtonian.DerivedVariables.χ⃗","text":"χ⃗(pnsystem)\nχ⃗(S⃗, M)\n\nNormalized spin vector SM².\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.χ⃗ₛ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.χ⃗ₛ","text":"χ⃗ₛ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nSymmetric spin vector (χ₁+χ₂)2.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.χ⃗ₐ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.χ⃗ₐ","text":"χ⃗ₐ(M₁, M₂, χ⃗₁, χ⃗₂)\n\nAntisymmetric spin vector (χ₁-χ₂)2.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.χₑ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.χₑ","text":"χₑ(s)\nchi_eff(s)\n\nEffective spin parameter of the system.\n\nDefined as\n\nchi_mathrmeff\ncolonequals fraccG left(\n    fracmathbfS_1M_1 + fracmathbfS_2M_2\nright) cdot frachatmathbfL_mathrmN M\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.χₚ","page":"Derived variables","title":"PostNewtonian.DerivedVariables.χₚ","text":"χₚ(s)\nchi_p(s)\n\nEffective precession spin parameter of the system.\n\nNote that there are two different definitions of this quantity found in the literature. The original definition (converted to the convention where M_1 geq M_2) is\n\nbegingathered\nA_1 = 2 + frac3M_22M_1 \nA_2 = 2 + frac3M_12M_2 \nchi_mathrmp colonequals frac1A_1 M_1^2\nmathrmmaxleft(A_1 S_1perp A_2 S_2perp right)\nendgathered\n\nIn a paper from early in the detection era, the LIGO collaboration used this definition.\n\nHowever, a more recent paper redefines this essentially as M_1^2 times that quantity.  Using the convention that q = M_2M_1 leq 1, the definition may be more compactly written as\n\nchi_mathrmp colonequals mathrmmax left(\n    chi_1perp chi_2perp q frac4q+34+3q\nright)\n\nAgain, a more recent paper by LIGO/Virgo/KAGRA uses this convention.\n\nBecause it seems to be the trend, this function uses the latter definition.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S⃗₀⁺","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S⃗₀⁺","text":"S⃗₀⁺(s)\nS⃗₀⁺(M₁, M₂, κ₁, κ₂, S⃗₁, S⃗₂)\n\nDefined in Eq. (3.4) of Buonanno et al. (2012):\n\nvecS_0^+\n= fracMM_1 left( frackappa_1 kappa_2 right)^14\n  left( 1 + sqrt1 - kappa_1 kappa_2 right)^12 vecS_1\n  + fracMM_2 left( frackappa_2 kappa_1 right)^14\n    left( 1 - sqrt1 - kappa_1 kappa_2 right)^12 vecS_2\n\nNote that, currently, kappa_1 and kappa_2 are both assumed to be equal to 1, as is the case for black holes.  You can define κ₁ and κ₂ to have other values for your own PNSystem types, and this function will work appropriately.\n\nSee also S⃗₀⁻.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.S⃗₀⁻","page":"Derived variables","title":"PostNewtonian.DerivedVariables.S⃗₀⁻","text":"S⃗₀⁻(s)\nS⃗₀⁻(M₁, M₂, κ₁, κ₂, S⃗₁, S⃗₂)\n\nDefined below Eq. (3.4) of Buonanno et al. (2012):\n\nvecS_0^-\n= fracMM_1 left( frackappa_1 kappa_2 right)^14\n  left( 1 - sqrt1 - kappa_1 kappa_2 right)^12 vecS_1\n  + fracMM_2 left( frackappa_2 kappa_1 right)^14\n    left( 1 + sqrt1 - kappa_1 kappa_2 right)^12 vecS_2\n\nNote that, currently, kappa_1 and kappa_2 are both assumed to be equal to 1, as is the case for black holes.  You can define κ₁ and κ₂ to have other values for your own PNSystem types, and this function will work appropriately.\n\nSee also S⃗₀⁺.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Additionally, there are numerous convenience functions to give certain components of the spins.  They take a single pnsystem argument and are not exported.  Given the definitions above, they are all fairly self explanatory — such as χ₁², which gives χ⃗₁ ⋅ χ⃗₁; or χ₁₂ = χ⃗₁ ⋅ χ⃗₂; or Sₙ = S⃗ ⋅ n̂. Like all the other fundamental and derived variables, these can be used directly in PN expressions modified by the @pn_expression macro.","category":"page"},{"location":"internals/derived_variables/#Horizons","page":"Derived variables","title":"Horizons","text":"","category":"section"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"We can also compute some variables defined by Alvi (2001) related to the horizons.  The hardest parts to compute here involve the relative angles between the spins and the black-hole separation vectors.  Alvi constructs a spherical coordinate system centered on each black hole where the z axis is given by the direction of the spin, and theta and phi represent the direction to the other black hole.  While he makes a (somewhat ambiguous) choice about the origin of the phi coordinate, only dotphi comes into the equations, so we don't really care about that origin.","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Note that Alvi uses mathbfn to represent the \"normal to the orbital plane\", whereas we — and most of the rest of the post-Newtonian literature — use hatell for this vector and hatn to represent the separation vector pointing from object 2 to object 1.  For convenience, we define","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"hatn_i = begincases\n-hatn  texti=1 \nhphantom-hatn  texti=2\nendcases","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Alvi's construction is also somewhat adiabatic, so we treat the spins and orbital plane as constant in the calculation of the instantaneous tidal heating — though they evolve slowly over time — and the angles theta and phi as evolving rapidly.  In our formulation, then, the goal is to find the angle theta_i(t) between vecchi_i and hatn_i, and the rotation rate dotphi_i(t) of hatn_i about the vecchi_i axis.","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Computing the angle between vectors is a somewhat infamously tricky problem. There are various claims floating around about the best ways to compute quantities involving areas and angles of triangles.  While these claims are surely true for areas, I am more skeptical of the relevance for angles.  I find it best to realize that you probably don't need the angle per se, but trigonometric functions of the angle — like sin^2 theta_i, which is what we actually need in this case.  In particular, I believe the best results come from computing","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"sin^2theta_i = frac\n    lefthatn_i times vecchi_iright^2\n\n    left vecchi_iright^2\n","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"If the denominator is zero, we set sin^2theta_i = 1 from physical considerations.","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Now consider the quantity hatn_i times vecchi_i.  We next aim to calculate the rotation rate dotphi_i of this vector about vecchi_i.  We begin by directly calculating","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"partial_t left(hatn_i times vecchi_iright)\n=\nleft(partial_t hatn_iright) times vecchi_i\n=\nleft(Omega hatell times hatn_iright) times vecchi_i\n=\nmp Omega hatlambda times vecchi_i","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"where the negative sign is chosen for i=1 and positive for i=2.  Now, from more fundamental considerations, we can understand the components of this change.  Since we assume that vecchi_i is constant at each instant for the purposes of calculation here, the only way for hatn_i times vecchi_i to change is either because hatn_i rotates about vecchi_i, or because the angle theta_i is changing.  We can express this as","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"partial_t left(hatn_i times vecchi_iright)\n=\nleft( dotphi hatchi_i right) times left(hatn_i times vecchi_iright)\n+\ndottheta_i cot theta_i left(hatn_i times vecchi_iright)","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Since these two components are orthogonal, we can obtain dotphi directly by taking the component of this quantity along hatchi_i times left(hatn_i times vecchi_iright):","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"dotphi_i\n=\nfrac\n    left( Omega hatlambda times vecchi_i right)\n    cdot\n    left(\n        vphantomhatlambda hatchi_i\n        times\n        left(hatn times vecchi_iright)\n    right)\n\n    left hatchi_i times left(hatn times vecchi_iright) right^2\n\n=\nOmega frachatell cdot hatchi_isin^2 theta_i","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Here again, we may run into numerical trouble if left vecchi_1 right approx 0, in which case we again use physical arguments to take dotphi_i = Omega. We might also expect to run into trouble if sin^2 theta_i approx 0, which corresponds to a polar orbit, in which case Alvi's approximations break down. This turns out to not be a problem numerically, because of the cancellation with the numerator, except when sin^2 theta_i = 0 exactly.  In this case, we choose dotphi_i = 0.","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"Note that the sign of hatn_i has dropped out of the calculations of both sin^2theta_i and dotphi_i, cancelling with the signs that had appeared next to Omega.","category":"page"},{"location":"internals/derived_variables/","page":"Derived variables","title":"Derived variables","text":"PostNewtonian.rₕ₁\nPostNewtonian.rₕ₂\nPostNewtonian.Ωₕ₁\nPostNewtonian.Ωₕ₂\nPostNewtonian.sin²θ₁\nPostNewtonian.sin²θ₂\nPostNewtonian.ϕ̇̂₁\nPostNewtonian.ϕ̇̂₂\nPostNewtonian.Î₀₁\nPostNewtonian.Î₀₂\nPostNewtonian.κ₁\nPostNewtonian.κ₂\nPostNewtonian.κ₊\nPostNewtonian.κ₋\nPostNewtonian.λ₁\nPostNewtonian.λ₂\nPostNewtonian.λ₊\nPostNewtonian.λ₋","category":"page"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.rₕ₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.rₕ₁","text":"rₕ₁(s)\n\nHorizon radius of black hole 1.\n\nAs defined on page 2, line 4, of Alvi (2001).  See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.rₕ₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.rₕ₂","text":"rₕ₂(s)\n\nHorizon radius of black hole 2.\n\nAs defined on page 2, line 4, of Alvi (2001).  See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Ωₕ₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Ωₕ₁","text":"Ωₕ₁(s)\n\nHorizon angular velocity of black hole 1.\n\nAs defined on page 2, line 5, of Alvi (2001).  See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Ωₕ₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Ωₕ₂","text":"Ωₕ₂(s)\n\nHorizon angular velocity of black hole 2.\n\nAs defined on page 2, line 5, of Alvi (2001).  See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.sin²θ₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.sin²θ₁","text":"sin²θ₁(s)\n\nSine-squared of angle between spin of black hole 1 and vector to black hole 2.\n\nCompare to Eq. (18) of Alvi (2001). See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.sin²θ₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.sin²θ₂","text":"sin²θ₂(s)\n\nSine-squared of angle between spin of black hole 2 and vector to black hole 1.\n\nCompare to Eq. (18) of Alvi (2001). See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ϕ̇̂₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ϕ̇̂₁","text":"ϕ̇̂₁(s)\n\nRate of rotation of black hole 2 about the spin of black hole 1, relative to orbital rotation rate.\n\nThis is the rotation rate ϕ̇ as defined in Eq. (19) of Alvi (2001), divided by v^3  = M Omega.  This division is done to make sure we can track the relative PN order of terms that depend on this.\n\nSee the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.ϕ̇̂₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.ϕ̇̂₂","text":"ϕ̇̂₂(s)\n\nRate of rotation of black hole 1 about the spin of black hole 2, relative to orbital rotation rate.\n\nThis is the rotation rate ϕ̇ as defined in Eq. (19) of Alvi (2001), divided by v^3  = M Omega.  This division is done to make sure we can track the relative PN order of terms that depend on this.\n\nSee the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Î₀₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Î₀₁","text":"Î₀₁(s)\n\nHorizon moment of inertia of black hole 1.\n\nThis is the moment divided by ν^2 v^12, as given by Eq. (10) of Alvi (2001).  See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.Î₀₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.Î₀₂","text":"Î₀₂(s)\n\nHorizon moment of inertia of black hole 2.\n\nThis is the moment divided by ν^2 v^12, as given by Eq. (10) of Alvi (2001).  See the documentation section on \"Horizons\" for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.κ₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.κ₁","text":"κ₁(s)\n\nThe \"quadrupolar polarisability\" of object 1 used by Bohé et al. (2015).\n\nNote that Bohé et al. refer to the closely related (and co-authored) Marsat (2014), who notes above Eq. (4.7) that this is denoted C_mathrmES^2 in Levi and Steinhoff (2014), who in turn notes that \"we can set ... the Wilson coefficients C_mathrmES^2 = C_mathrmBS^3 = 1 for the black hole case.\"\n\nHowever, a very similar constant kappa_A is used in Eq. (2.1) of Buonanno et al. (2012).  They say that kappa_A=1 for an isolated black hole, but can deviate from 1 for a black hole in a binary — though those deviations occur at \"much higher\" order than those they consider (2PN).\n\nSee also λ₁.\n\nwarn: Warn\nThis function will be incorrect for objects other than black holes.  It is not clear to me if this is the same quantity as C_Q used in some papers, such as Bini and Geralico (2014), but they point out that for neutron stars, the value varies between 4.3 and 7.4, depending on the equation of state.  This quantity may also be related to λ₁.  Pull requests or issues with more information are welcome.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.κ₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.κ₂","text":"κ₂(s)\n\nThe \"quadrupolar polarisability\" of object 2 used by Bohé et al. (2015).  See κ₁ for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.κ₊","page":"Derived variables","title":"PostNewtonian.DerivedVariables.κ₊","text":"κ₊(s)\n\nEqual to κ₁+κ₂; defined below Eq. (3.28) of Bohé et al. (2015).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.κ₋","page":"Derived variables","title":"PostNewtonian.DerivedVariables.κ₋","text":"κ₋(s)\n\nEqual to κ₁-κ₂; defined below Eq. (3.28) of Bohé et al. (2015).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.λ₁","page":"Derived variables","title":"PostNewtonian.DerivedVariables.λ₁","text":"λ₁(s)\n\nThe \"quadrupolar polarisability\" of object 1 used by Marsat (2014), who notes above Eq. (4.11) that this is denoted C_mathrmBS^2 in Levi and Steinhoff (2014), who in turn notes that \"we can set ... the Wilson coefficients C_mathrmES^2 = C_mathrmBS^3 = 1 for the black hole case.\"\n\nSee also κ₁.\n\nwarn: Warn\nThis function will be incorrect for objects other than black holes.  It is not clear to me if this is the same quantity as C_Q used in some papers, such as Bini and Geralico (2014), but they point out that for neutron stars, the value varies between 4.3 and 7.4, depending on the equation of state.  This quantity may also be related to λ₁.  Pull requests or issues with more information are welcome.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.λ₂","page":"Derived variables","title":"PostNewtonian.DerivedVariables.λ₂","text":"λ₂(s)\n\nThe \"quadrupolar polarisability\" of object 2 used by Bohé et al. (2015).  See λ₁ for more details.\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.λ₊","page":"Derived variables","title":"PostNewtonian.DerivedVariables.λ₊","text":"λ₊(s)\n\nEqual to λ₁+λ₂; defined below Eq. (3.28) of Bohé et al. (2015).\n\n\n\n\n\n","category":"function"},{"location":"internals/derived_variables/#PostNewtonian.DerivedVariables.λ₋","page":"Derived variables","title":"PostNewtonian.DerivedVariables.λ₋","text":"λ₋(s)\n\nEqual to λ₁-λ₂; defined below Eq. (3.28) of Bohé et al. (2015).\n\n\n\n\n\n","category":"function"},{"location":"contributing/#contributing","page":"Contributing guidelines","title":"Contributing guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"First of all, thanks for the interest!","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"Please be polite and respectful, and recognize that time spent on this project or helping you specifically is always voluntary.","category":"page"},{"location":"contributing/#Bug-reports-and-discussions","page":"Contributing guidelines","title":"Bug reports and discussions","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you think you found a bug, feel free to open an issue.  Focused suggestions and requests can also be opened as issues.  Before opening a pull request, start an issue or a discussion on the topic, please. Note that there is a dedicated page for advice on adding new PN terms or expressions.","category":"page"},{"location":"contributing/#Working-on-an-issue","page":"Contributing guidelines","title":"Working on an issue","text":"","category":"section"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If you found an issue that interests you, comment on that issue what your plans are.  If the solution to the issue is clear, you can immediately create a pull request (see below).  Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"tip: Tip\nFeel free to ping us after a few days if there are no responses.","category":"page"},{"location":"contributing/","page":"Contributing guidelines","title":"Contributing guidelines","text":"If your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"page"},{"location":"internals/code_structure/#Structure-of-this-package's-code","page":"Code structure","title":"Structure of this package's code","text":"","category":"section"},{"location":"internals/code_structure/","page":"Code structure","title":"Code structure","text":"There is a fairly simple hierarchy to the code.  Beyond some basic utilities, which are related to how we write the code, rather than post-Newtonian calculations per se, we have the following:","category":"page"},{"location":"internals/code_structure/","page":"Code structure","title":"Code structure","text":"System and state\nObjects of type PNSystem represent the PN system itself and some information about it, including:\nThe Binary type — BBH, BHNS, or NSNS\nThe float type T — Float64, etc.\nThe PN expansion order PNOrder — a Rational\nThe current state of the system, including the fundamental variables\nThe first of these is represented as the type itself, the last is stored as a vector inside the object, and the rest are represented as type parameters.\nNote that basically everything below will be written as a function of such an object, which we will denote pnsystem.\nFundamental variables\nThis consists of the basic variables describing the instantaneous state of the system, including M₁, M₂, χ⃗₁, χ⃗₂, R, v. For systems with matter, this may also include tidal deformability for each star, Λ₁ and Λ₂.\nThese are encapsulated within a PNSystem, but it's important to note that these should all be accessed through functions like M₁(pnsystem) rather than directly like pnsystem.M₁.  This allows Julia's type system to get involved, enabling important optimizations.\nAlso, these variables can be automatically computed in functions that need them with the @pn_expression macro.  For example, you can directly use the symbols M₁, M₂, etc., in a function that is wrapped in that macro, without any qualifiers to specify where those variables are coming from, and the macro will automatically and efficiently evaluate them for you because they are defined in the PostNewtonian.FundamentalVariables module.\nDerived variables\nThese are variables that are frequently used in PN expressions that can be computed from the fundamental variables, and are defined in terms of them.  For example, the total mass M ≔ M₁+M₂, the antisymmetric spin vector χ⃗ₐ ≔ (χ⃗₁-χ⃗₂)/2, or the orbital separation vector n̂ ≔ R x̂ R̄.  While none of these are strictly necessary, it is helpful to be able to write the same variables used in articles providing the PN expressions in the code itself.\nBecause they are defined solely in terms of fundamental variables, which can be computed from an PNSystem alone, these are all written as functions of such an object — such as M(pnsystem), χ⃗ₐ(pnsystem), and n̂(pnsystem).\nAgain, these quantities will be automatically computed for you in any function wrapped in the @pn_expression macro because they are defined in the PostNewtonian.DerivedVariables module.\nPN expressions\nUnlike derived variables, these are not necessarily defined in terms of only the fundamental variables, but they can be calculated in terms of both fundamental and derived variables.  These are generally the result of post-Newtonian expansions — the most important examples being the flux 𝓕, binding energy 𝓔, and the waveform mode weights h! themselves.\nPN expansions\nThese are the specific parts of a \"PN expression\" that are expanded in powers of 1c.  For example, the flux 𝓕 and binding energy 𝓔 are expanded in powers of vc.  When such PN expansions are defined using the @pn_expression macro, any occurrence of c is turned into an object that captures the exponent of c in that expression.  The expansion is automatically truncated at the appropriate order, and then c is finally set to 1 so that the result can be computed as usual.  See PNTerm and PNExpansion for more details.\nDynamics\nThis is where the ODE integration actually occurs, to evolve the orbital dynamics of the system.\nEvaluation\nFinally, we construct the waveforms themselves.  This level contains the main interface that will usually be used from Julia code, and should be restricted to fairly high-level functions like PNWaveform(M₁, M₂, ...), while still handling the full range of options that will be present in \"Dynamics\", for example.\nCompatibility layers\nThis is an optional level of abstraction that allows us to wrap the evaluation layer in functions that are designed to look and act more like other packages' functions.  As of this writing, the only such layer is for GWFrames compatibility, but similar wrappers could certainly be added.","category":"page"},{"location":"developer/#dev_docs","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"If you want to make contributions to this package that involves code, then this guide is for you.","category":"page"},{"location":"developer/#First-time-clone","page":"Developer documentation","title":"First time clone","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: If you have writing rights\nIf you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead.","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"If this is the first time you work with this repository, follow the instructions below to clone the repository.","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Fork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\ngit remote add upstream https://github.com/moble/PostNewtonian.jl","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"This will ensure that you have two remotes in your git: origin and upstream.  You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"page"},{"location":"developer/#Linting-and-formatting","page":"Developer documentation","title":"Linting and formatting","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Install a plugin on your editor to use EditorConfig.  This will ensure that your editor is configured with important formatting settings.","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"We use https://pre-commit.com to run the linters and formatters.  In particular, the Julia code is formatted using JuliaFormatter.jl, so please install it globally first:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # Press ]\npkg> activate\npkg> add JuliaFormatter","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"To install pre-commit, use your standard python method — for example:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"python -m pip install pre-commit","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"With pre-commit installed, activate it as a pre-commit hook by running this command in the repository folder:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit install","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"To run the linting and formatting manually, enter the command below:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"pre-commit run -a","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Now, you can only commit if all the pre-commit tests pass.","category":"page"},{"location":"developer/#Testing","page":"Developer documentation","title":"Testing","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"julia> # press ]\npkg> activate .\npkg> test","category":"page"},{"location":"developer/#Working-on-a-new-issue","page":"Developer documentation","title":"Working on a new issue","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Fetch from the remote and fast-forward your local main\ngit fetch upstream\ngit switch main\ngit merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\ngit switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\ngit push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"page"},{"location":"developer/#Branch-naming","page":"Developer documentation","title":"Branch naming","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"page"},{"location":"developer/#Commit-message","page":"Developer documentation","title":"Commit message","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"page"},{"location":"developer/#Before-creating-a-pull-request","page":"Developer documentation","title":"Before creating a pull request","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"tip: Atomic git commits\nTry to create \"atomic git commits\" (recommended reading: The Utopic Git History).","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Make sure the tests pass.\nMake sure the pre-commit tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\ngit fetch upstream\ngit rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"page"},{"location":"developer/#Building-and-viewing-the-documentation-locally","page":"Developer documentation","title":"Building and viewing the documentation locally","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation.  Here is how you do it:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Run julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"page"},{"location":"developer/#Making-a-new-release","page":"Developer documentation","title":"Making a new release","text":"","category":"section"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"To create a new release, once the code is merged into main, just go to the register action, click the gray \"Run workflow\" button, enter the version component you want to bump, and click the green \"Run workflow\" button.","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"After that, you only need to wait and verify:","category":"page"},{"location":"developer/","page":"Developer documentation","title":"Developer documentation","text":"Wait for the bot to comment (should take < 1m) with a link to a RP to the registry\nFollow the link and wait for a comment on the auto-merge\nThe comment should said all is well and auto-merge should occur shortly\nAfter the merge happens, TagBot will trigger and create a new GitHub tag. Check on https://github.com/moble/PostNewtonian.jl/releases\nAfter the release is create, a \"docs\" GitHub action will start for the tag.\nAfter it passes, a deploy action will run.\nAfter that runs, the stable docs should be updated. Check them and look for the version number.","category":"page"},{"location":"internals/fundamental_variables/","page":"Fundamental variables","title":"Fundamental variables","text":"CurrentModule = PostNewtonian.FundamentalVariables","category":"page"},{"location":"internals/fundamental_variables/#Fundamental-variables","page":"Fundamental variables","title":"Fundamental variables","text":"","category":"section"},{"location":"internals/fundamental_variables/","page":"Fundamental variables","title":"Fundamental variables","text":"These constitute the basic quantities needed to fully describe a PN binary system at any instant.  All other variables — and ultimately all PN expressions — may be expressed as functions of these.  In the docstrings below, pnsystem is an object of any type that subtypes PNSystem.","category":"page"},{"location":"internals/fundamental_variables/","page":"Fundamental variables","title":"Fundamental variables","text":"PostNewtonian.M₁\nPostNewtonian.M₂\nPostNewtonian.χ⃗₁\nPostNewtonian.χ⃗₂\nPostNewtonian.R\nPostNewtonian.v\nPostNewtonian.Φ\nPostNewtonian.Λ₁\nPostNewtonian.Λ₂","category":"page"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.M₁","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.M₁","text":"M₁(pnsystem)\nM1(pnsystem)\n\nMass of object 1 in this system.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.M₂","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.M₂","text":"M₂(pnsystem)\nM2(pnsystem)\n\nMass of object 2 in this system.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.χ⃗₁","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.χ⃗₁","text":"χ⃗₁(pnsystem)\nchi1(pnsystem)\n\nDimensionless spin vector of object 1 in this system, as a QuatVec.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.χ⃗₂","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.χ⃗₂","text":"χ⃗₂(pnsystem)\nchi2(pnsystem)\n\nDimensionless spin vector of object 2 in this system, as a QuatVec.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.R","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.R","text":"R(pnsystem)\n\nOrientation of the binary, as a Rotor.\n\nAt any instant, the binary is represented by the right-handed triad (n λ ℓ), where n is the unit vector pointing from object 2 to object 1, and the instantaneous velocities of the binary's elements are in the n-λ plane.  This Rotor will rotate the x vector to be along n,  the y vector to be along λ, and  the z vector to be along ℓ.\n\nNote that the angular velocity associated to R is given by Ω = 2 R R = Ω ℓ + ϖ n. (Any component of Ω along λ would violate the condition that the velocities be in the n-λ plane.)  Here, the scalar quantity Ω is the orbital angular frequency, and ϖ is the precession angular frequency.\n\nSee also n̂, λ̂, ℓ̂, Ω, and 𝛡=ϖ n.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.v","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.v","text":"v(pnsystem)\nv(;Ω, M=1)\n\nPost-Newtonian velocity parameter.  This is related to the orbital angular frequency Omega as\n\nv colonequals (MOmega)^13\n\nwhere M is the total mass of the binary.\n\nNote that if you want to pass the value Ω (rather than a PNSystem), you must pass it as a keyword argument — as in v(Ω=0.1).\n\nSee also Ω.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.Φ","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.Φ","text":"Φ(pnsystem)\nPhi(pnsystem)\n\nIntegrated orbital phase of the system.  It is computed as the integral of Ω.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.Λ₁","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.Λ₁","text":"Λ₁(pnsystem)\nLambda1(pnsystem)\n\nQuadrupolar tidal-coupling parameter of object 1 in this system.\n\nWe imagine object 1 begin placed in an (adiabatic) external field with Newtonian potential phi, resulting in a tidal field measured by partial_i partial_j phi evaluated at the center of mass of the object.  This induces a quadrupole moment Q_ij in object 1, which can be related to the tidal field as\n\nQ_ij = -fracG^4c^10 Lambda_1 M_1^5 partial_i partial_j phi\n\nwhere M_1 is the mass of object 1.  This tidal-coupling parameter Lambda_1 can be related to the Love number k_2 (where the subscript 2 refers to the fact that this is for the ell=2 quadrupole, rather than object 2) as\n\nLambda_1 = frac23 fracc^10G^5 fracR_1^5M_1^5 k_2\n\nwhere R_1 is the radius of object 1.  Note that Lambda_1 is dimensionless.  For black holes, it is precisely zero; for neutron stars it may range up to 1; more exotic objects may have significantly larger values.\n\nNote that — as of this writing — only NSNS systems can have a nonzero value for this quantity.  All other types return 0, which Julia can use to eliminate code that would then be 0.  Thus, it is safe and efficient to use this quantity in any PN expression that specializes on the type of pnsystem.\n\n\n\n\n\n","category":"function"},{"location":"internals/fundamental_variables/#PostNewtonian.FundamentalVariables.Λ₂","page":"Fundamental variables","title":"PostNewtonian.FundamentalVariables.Λ₂","text":"Λ₂(pnsystem)\nLambda2(pnsystem)\n\nQuadrupolar tidal coupling parameter of object 2 in this system.\n\nSee Λ₁ for details about the definition, swapping \"object 1\" with \"object 2\".\n\nNote that — as of this writing — only BHNS and NSNS systems can have a nonzero value for this quantity.  All other types return 0, which Julia can use to eliminate code that would then be 0.  Thus, it is safe and efficient to use this quantity in any PN expression that specializes on the type of pnsystem.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#Computing-the-waveform","page":"Waveforms","title":"Computing the waveform","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"Once you have computed the orbital evolution, and selected the time steps on which you want to evaluate the waveform, you can do so with one of the functions documented below.","category":"page"},{"location":"internals/waveforms/#Precise-definition-of-waveforms","page":"Waveforms","title":"Precise definition of waveforms","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"The waveform returned by these functions is essentially the complex strain h colonequals h_+ - ih_times.  However, this quantity decays as 1r, where r is the radius at which the strain is measured.  Therefore, as is conventional, the returned quantity is actually","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"H colonequals lim_rtoinfty h fracrM fracc^2G","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"where M is the total mass of the two objects in the binary.  Note that both h and H are dimensionless, but only H is scale invariant.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"Binaries are usually modeled in relativity as being isolated systems in otherwise empty asymptotically flat spacetimes — or even more specifically, in asymptotically Minkowski spacetimes.  In this case, r is just the asymptotic areal radius.  The equivalent expression in an FLRW spacetime requires a simple reinterpretation of M as the redshifted mass M_z colonequals M(1+z) and r as the luminosity distance d_L[1]  Thus, to obtain the strain as it would be measured (in the asymptotic approximation) by an actual observer in an asymptotically flat universe or in our universe, we just need to invert the previous equation:","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"h approx H fracMr fracGc^2\nqquad mathrmor qquad\nh approx H fracM_zd_L fracGc^2","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"[1]: Note that we use \"luminosity distance\" as it is understood in   contemporary cosmology, which is   unfortunately different from its meaning in older cosmology literature,   and even some of the gravitational-wave astronomy literature from before   2015 or so.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"Furthermore, H is a function of coordinates (t theta phi).  The dependence on t will be discretely sampled at the times t_i that are present in the inspiral arguments to the functions below.  To handle the angular dependence, we provide the waveform decomposed as mode weights in a spin-weighted spherical-harmonic decomposition, so that the actual quantity returned will be","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"H_ellm(t_i)\ncolonequals\nint H(t theta phi) _-2barY_ellm(theta phi)\nsintheta dtheta dphi","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"The output array is a two-dimensional complex array.  The first dimension varies over (ellm) values, with m varying most rapidly — as in","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"[(ℓ,m) for ℓ ∈ ℓₘᵢₙ:ℓₘₐₓ for m ∈ -ℓ:ℓ]","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"The second dimension of the array indexes the time.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"See Example 2 on the \"Units\" page for a complete example of converting this package's output to standard units in our universe.","category":"page"},{"location":"internals/waveforms/#Evaluation-of-waveforms","page":"Waveforms","title":"Evaluation of waveforms","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"coorbital_waveform\ninertial_waveform","category":"page"},{"location":"internals/waveforms/#PostNewtonian.coorbital_waveform","page":"Waveforms","title":"PostNewtonian.coorbital_waveform","text":"coorbital_waveform(inspiral; [ℓₘᵢₙ=2], [ℓₘₐₓ=8], [PNOrder])\ncoorbital_waveform(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the co-orbital frame for the given inspiral output by orbital_evolution.\n\nSee also inertial_waveform for the waveform in the inertial frame.\n\nFor a detailed description of the format and physical interpretation of the returned quantity, see the \"Waveforms\" section of the manual.\n\nThe PNOrder defaults to the one used to compute inspiral, but may be changed by passing the keyword argument.\n\ntip: Tip\nIf you need this waveform at a different set of times t′ than is currently present in inspiral.t, you should use the built-in interpolation capabilities of inspiral first, as in inspiral′ = inspiral(t′), rather than interpolating the results of this function.  Or, perhaps better yet, you could select the times when calling orbital_evolution by using the saves_per_orbit or saveat keyword argument to that function.  These approaches will be more accurate, faster, and require less memory than interpolating the result of this function.  If using saves_per_orbit, you probably want to set it to at least 2ℓₘₐₓ, or preferably 4ℓₘₐₓ.\n\nThe mode weights are given starting at ℓₘᵢₙ (which must satisfy 0 ≤ ℓₘᵢₙ ≤ 2) and extending through ℓₘₐₓ.  The waveform is returned as a 2-dimensional Array, in which the first index varies over the mode index from (ℓ, m) = (ℓₘᵢₙ, -ℓₘᵢₙ) to (ℓ, m) = (ℓₘₐₓ, ℓₘₐₓ), with m varying most rapidly, and the second index varying over the time steps.\n\nIn this function, the waveform is returned in the co-orbital frame — which is somewhat like the co-rotating frame.  In particular, the modes of non-precessing systems vary slowly, over inspiral timescales; modes of precessing systems still vary on orbital timescales, though even this variation could be factored out.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.inertial_waveform","page":"Waveforms","title":"PostNewtonian.inertial_waveform","text":"inertial_waveform(inspiral; [ℓₘᵢₙ=2], [ℓₘₐₓ=8], [PNOrder])\ninertial_waveform(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the inertial frame for the given inspiral output by orbital_evolution.\n\nThe inertial frame is the one in which inertial observers are found, so this waveform is more like one that actual observers would detect.  This function transforms the waveform from the co-orbital frame — which is the one in which PN expressions are provided.\n\nSee coorbital_waveform for details about the other arguments and returned quantity.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#In-place-evaluation-of-waveforms","page":"Waveforms","title":"In-place evaluation of waveforms","text":"","category":"section"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"This is likely to be an uncommon scenario, but if you happen to need to evaluate the waveform repeatedly on the same set (or at least same number) of time steps and same range of ell values, then you can pre-allocate the storage needed in this process, and re-use that storage.  To do so, pre-allocate using either coorbital_waveform_computation_storage or inertial_waveform_computation_storage, and then pass the result as the first argument to either coorbital_waveform! or inertial_waveform!.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"note: Note\nThe h array returned by either coorbital_waveform! or inertial_waveform! is part of the pre-allocated storage.  You need to use its values before you call either of those functions again, or those values will just be overwritten.","category":"page"},{"location":"internals/waveforms/","page":"Waveforms","title":"Waveforms","text":"coorbital_waveform_computation_storage\ninertial_waveform_computation_storage\ncoorbital_waveform!\ninertial_waveform!","category":"page"},{"location":"internals/waveforms/#PostNewtonian.coorbital_waveform_computation_storage","page":"Waveforms","title":"PostNewtonian.coorbital_waveform_computation_storage","text":"coorbital_waveform_computation_storage(inspiral; [ℓₘᵢₙ=2], [ℓₘₐₓ=8], [PNOrder])\ncoorbital_waveform_computation_storage(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nConstruct storage needed to compute waveforms in the co-orbital frame without allocations.\n\nThis returns the storage for the waveforms themselves and PNSystem used as temporary storage.  The returned quantity can just be passed as the first argument to coorbital_waveform! without being unpacked.\n\nThe meaning of the arguments is the same as in coorbital_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.inertial_waveform_computation_storage","page":"Waveforms","title":"PostNewtonian.inertial_waveform_computation_storage","text":"inertial_waveform_computation_storage(inspiral; [ℓₘᵢₙ=2], [ℓₘₐₓ=8], [PNOrder])\ninertial_waveform_computation_storage(inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nConstruct storage needed to compute waveforms in the inertial frame without allocations.\n\nThis returns the storage for the waveforms themselves, storage used for computing the Wigner 𝔇 matrices, and for \"in-place\" multiplication.  The returned quantity can just be passed as the first argument to inertial_waveform! without being unpacked.\n\nThe meaning of the arguments is the same as in inertial_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.coorbital_waveform!","page":"Waveforms","title":"PostNewtonian.coorbital_waveform!","text":"coorbital_waveform!(storage, inspiral; [ℓₘᵢₙ=2], [ℓₘₐₓ=8], [PNOrder])\ncoorbital_waveform!(storage, inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the co-orbital frame for the given inspiral output by orbital_evolution, using pre-allocated storage.\n\nThe storage is assumed to be the object returned from coorbital_waveform_computation_storage.  Other arguments are the same as in coorbital_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/waveforms/#PostNewtonian.inertial_waveform!","page":"Waveforms","title":"PostNewtonian.inertial_waveform!","text":"inertial_waveform!(storage, inspiral; [ℓₘᵢₙ=2], [ℓₘₐₓ=8], [PNOrder])\ninertial_waveform!(storage, inspiral; [ell_min=2], [ell_max=8], [PNOrder])\n\nEvaluate the post-Newtonian waveform mode weights in the inertial frame for the given inspiral output by orbital_evolution, using pre-allocated storage.\n\nThe storage is assumed to be the object returned from inertial_waveform_computation_storage.  Other arguments are the same as in inertial_waveform.\n\n\n\n\n\n","category":"function"},{"location":"internals/pn_systems/#PN-systems","page":"PN systems","title":"PN systems","text":"","category":"section"},{"location":"internals/pn_systems/","page":"PN systems","title":"PN systems","text":"PNSystem\nBBH\nBHNS\nNSNS\nFDPNSystem\nfd_pnsystem","category":"page"},{"location":"internals/pn_systems/#PostNewtonian.PNSystem","page":"PN systems","title":"PostNewtonian.PNSystem","text":"PNSystem{T, PNOrder}\n\nBase type for all PN systems, such as BBH, BHNS, and NSNS.\n\nThese objects encode all essential properties of the binary, including its current state. As such, they can be used as inputs to the various fundamental and derived variables, as well as PN expressions and dynamics functions.\n\nAll subtypes should contain a state vector holding all of the fundamental variables for the given type of system.  The parameter T is the type of the state vector — for example, Vector{Float64}.  PNOrder is a Rational giving the order to which PN expansions should be carried.\n\n\n\n\n\n","category":"type"},{"location":"internals/pn_systems/#PostNewtonian.BBH","page":"PN systems","title":"PostNewtonian.BBH","text":"BBH{T, PNOrder}\n\nThe PNSystem subtype describing a binary black hole system.\n\nThe state vector here holds the fundamental variables M₁, M₂, χ⃗₁, χ⃗₂, R, v, with the spins unpacked into three components each, and R unpacked into four — for a total of 13 elements.\n\nOptionally, Φ may also be tracked as the 14th element of the state vector.  This is just the integral of the orbital angular frequency Ω, and holds little interest for general systems beyond a convenient description of how \"far\" the system has evolved.\n\n\n\n\n\n","category":"type"},{"location":"internals/pn_systems/#PostNewtonian.BHNS","page":"PN systems","title":"PostNewtonian.BHNS","text":"BHNS{T, PNOrder}\n\nThe PNSystem subtype describing a black-hole—neutron-star binary system.\n\nThe state vector is the same as for a BBH.  There is an additional field Λ₂ holding the (constant) tidal-coupling parameter of the neutron star.\n\nNote that the neutron star is always object 2 — meaning that M₂, χ⃗₂, and Λ₂ always refer to it; M₁ and χ⃗₁ always refer to the black hole.  See also NSNS.\n\n\n\n\n\n","category":"type"},{"location":"internals/pn_systems/#PostNewtonian.NSNS","page":"PN systems","title":"PostNewtonian.NSNS","text":"NSNS{T, PNOrder}\n\nThe PNSystem subtype describing a neutron-star—neutron-star binary system.\n\nThe state vector is the same as for a BBH.  There are two additional fields Λ₁ and Λ₂ holding the (constant) tidal-coupling parameters of the neutron stars.  See also BHNS.\n\n\n\n\n\n","category":"type"},{"location":"internals/pn_systems/#PostNewtonian.FDPNSystem","page":"PN systems","title":"PostNewtonian.FDPNSystem","text":"FDPNSystem{FT, PNOrder}(state, Λ₁, Λ₂)\n\nA PNSystem that contains information as variables from FastDifferentiation.jl.\n\nSee also fd_pnsystem for a particular instance of this type.  Note that this type also involves the type FT, which will be the float type of actual numbers that eventually get fed into (and will be passed out from) functions that use this system.  The correct type of FDPNSystem is used in calculating 𝓔′.\n\n\n\n\n\n","category":"type"},{"location":"internals/pn_systems/#PostNewtonian.fd_pnsystem","page":"PN systems","title":"PostNewtonian.fd_pnsystem","text":"fd_pnsystem\n\nA symbolic PNSystem that contains symbolic information for all types of PNSystems.\n\nIn particular, note that this object has (essentially) infinite PNOrder, has nonzero values for quantities like Λ₁ and Λ₂, and assumes that the eventual output will be in Float64.  If you want different choices, you may need to call FDPNSystem yourself, or even construct a different specialized subtype of PNSystem (it's not hard).\n\nExamples\n\njulia> using PostNewtonian: M₁, M₂, χ⃗₁, χ⃗₂, FDPNSystem\n\njulia> fd_pnsystem = FDPNSystem(Float64)\nFDPNSystem{Float64, 9223372036854775805//2}(FastDifferentiation.Node[M₁, M₂, χ⃗₁ˣ, χ⃗₁ʸ, χ⃗₁ᶻ, χ⃗₂ˣ, χ⃗₂ʸ, χ⃗₂ᶻ, Rʷ, Rˣ, Rʸ, Rᶻ, v, Φ], Λ₁, Λ₂)\n\njulia> M₁(fd_pnsystem), M₂(fd_pnsystem)\n(M₁, M₂)\n\njulia> χ⃗₁(fd_pnsystem)\n + χ⃗₁ˣ𝐢 + χ⃗₁ʸ𝐣 + χ⃗₁ᶻ𝐤\n\njulia> χ⃗₂(fd_pnsystem)\n + χ⃗₂ˣ𝐢 + χ⃗₂ʸ𝐣 + χ⃗₂ᶻ𝐤\n\n\n\n\n\n","category":"constant"},{"location":"internals/pn_expressions/#PN-expressions","page":"PN expressions","title":"PN expressions","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"These are collected from numerous sources in the literature.  The docstrings below provide the relevant citations.","category":"page"},{"location":"internals/pn_expressions/#Binding-energy","page":"PN expressions","title":"Binding energy","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/binding_energy.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.𝓔-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.𝓔","text":"𝓔(pnsystem)\nbinding_energy(pnsystem)\n\nCompute the gravitational binding energy of a compact binary.\n\nNote that this may not be as useful as its derivative, 𝓔′, which is used as part of the right-hand side for orbital evolutions.\n\nThe nonspinning orbital binding energy is known through 4pN.  The expressions through 3.5pN here come from Eq. (233) of Blanchet (2014).\n\nThe 4pN term from Eq. (5.2d) of Jaranowski and Schäfer is known exactly, now that the ν-linear piece is given as Eq. (32) of Bini and Damour (2013a).  The remaining terms are not known exactly, but Bini and Damour (2013b) have derived some terms, though there is incomplete information, which are noted as the constants in this code.\n\nThe spin-orbit terms in the energy are now complete to 4.0pN (the last term is zero).  These terms come from Eq. (4.6) of Bohé et al. (2012).\n\nThe spin-squared terms (by which we mean both spin-spin and spin-orbit squared terms) in the energy are known to 3pN order, and given in Eq. (3.33) of Bohé et al. (2015).\n\nThe tidal-coupling terms come in to the binding energy at relative 5pN order, and are known to 6pN order.  These terms come from Eq. (2.11) of Vines et al. (2011).  Note their unusual convention for mass ratios, where χ₁ = m₁m in their notation; in particular, χ is not a spin parameter.  Also note that λ = λ₂ v^10(m₁+m₂)^5, and we need to add the coupling terms again with 1  2.  Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.𝓔′-Union{Tuple{PNSystem{ST, PNOrder}}, Tuple{PNExpansionReducer}, Tuple{PNOrder}, Tuple{ST}} where {ST, PNOrder, PNExpansionReducer}","page":"PN expressions","title":"PostNewtonian.𝓔′","text":"𝓔′(pnsystem)\nbinding_energy_deriv(pnsystem)\n\nCompute the derivative with respect to v of the binding energy of a compact binary.\n\nThis is computed automatically (via FastDifferentiation) from 𝓔; see that function for details of the PN formulas.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Flux","page":"PN expressions","title":"Flux","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/flux.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.𝓕-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.𝓕","text":"𝓕(pnsystem)\ngw_energy_flux(pnsystem)\n\nCompute the gravitational-wave energy flux to infinity\n\nThe nonspinning flux terms are complete to 4.5pN order, and are given in Eq. (6.11) of Blanchet et al. (2023).\n\nThe spin-orbit terms in the flux are now known to 4.0pN.  These terms come from Eq. (4.9) of Marsat et al. (2013)\n\nThe spin-squared terms (by which we mean both spin-spin and spin-orbit squared terms) in the flux are known to 3pN order, and given most conveniently in Eq. (4.14) of Bohé et al. (2015).\n\nBeyond 4.5pN, terms are only known in the extreme-mass-ratio limit.  These terms are given in Appendix A of Fujita (2012).  He computed them up to 22pN.  That seems like overkill, so we'll just go up to 6pN.\n\nFor systems with matter, the tidal-heating terms come in at relative 5pN order, and are known partially at 6pN order.  These terms come from Eq. (3.6) of Vines et al. (2011).  Note their unusual convention for mass ratios, where χ₁ = m₁m in their notation; in particular, χ is not a spin parameter.  Also note that λ = λ₂ v^10(m₁+m₂)^5, and we need to add the coupling terms again with 1  2.  Finally, note the normalization difference, where a different overall factor is used, leading to a sign difference.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Tidal-heating","page":"PN expressions","title":"Tidal heating","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/tidal_heating.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.tidal_heating-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.tidal_heating","text":"tidal_heating(pnsystem)\n\nCompute the rate of energy and angular-momentum absorption into each black hole in a binary.\n\nThe returned quantity is a tuple (Ṡ₁, Ṁ₁, Ṡ₂, Ṁ₂), representing the corresponding rates of change of spin (magnitude) and mass on black hole 1 and black hole 2.  These apply to general — possibly precessing — non-eccentric binaries.  This collection of terms comes from Alvi (2001).  It probably wouldn't be too hard to extend Alvi's analysis to eccentric systems.\n\nNote that the validity of the result depends not only on the PN parameter v, but also on the angles of the spins relative to the separation vector n: the smaller the angle, the lower the v at which the approximations should be expected to break down.\n\nSee also\n\nTagoshi and Sasaki (1994)\nPoisson and Sasaki (1995)\nTagoshi et al. (1997)\nPorto (2007)\nChatziioannou et al. (2012)\n\nSee the documentation section on \"Horizons\" for details about the computation of horizon quantities used in this function.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Separation","page":"PN expressions","title":"Separation","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/separation.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.r-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.r","text":"r(pnsystem)\nseparation(pnsystem)\n\nCompute the separation between the two black holes.  This is essentially the inverse of γₚₙ, with some factors of G and M thrown in.\n\nNote that there should be a factor of 1/c^2 in this expression; we reserve it to use explicitly in PN expansions.  That is, for every factor of 1/r, we explicitly include a factor of 1/c^2 in the expansion.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.r′-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.r′","text":"r′(pnsystem)\nseparation_deriv(pnsystem)\n\nCompute the derivative of the separation between the two black holes with respect to v.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.r⁻¹-Tuple{Any, Any}","page":"PN expressions","title":"PostNewtonian.r⁻¹","text":"r⁻¹(r, pnsystem)\nseparation_inverse(r, pnsystem)\n\nReturn v such that r = r(v) when pnsystem is evaluated at v.\n\nNote that the value of v in the input pnsystem is ignored; you may use any value.  It may also be convenient to know that you can set the value of v in pnsystem to the returned value using PostNewtonian.vindex as in\n\npnsystem.state[PostNewtonian.vindex] = r⁻¹(r, pnsystem)\n\nSee also γₚₙ⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.γₚₙ-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.γₚₙ","text":"γₚₙ(pnsystem)\ninverse_separation(pnsystem)\n\nCompute the post-Newtonian parameter\n\ngamma_mathrmPN equiv fracG Mr c^2\n\nwhere r is the magnitude of the orbital separation.  This quantity has PN order 1, and is given by Eq. (4.3) of Bohé et al. (2013) and Eq. (3.32) of Bohé et al.  (2015).\n\nNote that there is a 3PN gauge term of -22νln(rr₀)3 that is simply ignored here, as it should cancel out of any physical quantity.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.γₚₙ′-Union{Tuple{PNSystem{ST, PNOrder}}, Tuple{PNExpansionReducer}, Tuple{PNOrder}, Tuple{ST}} where {ST, PNOrder, PNExpansionReducer}","page":"PN expressions","title":"PostNewtonian.γₚₙ′","text":"γₚₙ′(pnsystem)\ninverse_separation_deriv(pnsystem)\n\nCompute the derivative of γₚₙ with respect to v.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.γₚₙ⁻¹-Tuple{Any, Any}","page":"PN expressions","title":"PostNewtonian.γₚₙ⁻¹","text":"γₚₙ⁻¹(γ, pnsystem)\ninverse_separation_inverse(γ, pnsystem)\n\nReturn v such that γₚₙ(pnsystem) = γ when pnsystem is evaluated at v.\n\nNote that the value of v in the input pnsystem is ignored; you may use any value.  It may also be convenient to know that you can set the value of v in pnsystem to the returned value using PostNewtonian.vindex as in\n\npnsystem.state[PostNewtonian.vindex] = γₚₙ⁻¹(γ, pnsystem)\n\nSee also r⁻¹.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Kidder-(1995)","page":"PN expressions","title":"Kidder (1995)","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian.Kidder1995]\nPages   = [\"pn_expressions/separation.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.Kidder1995","page":"PN expressions","title":"PostNewtonian.Kidder1995","text":"This module contains a few expressions from Kidder (1995).\n\nThis is mostly here for testing, because these expressions are not directly used in this package: they are somewhat outdated and describe quantities that are not actually used in this formulation.  However, they were used in the SpEC code as an initial guess for eccentricity reduction, so we want to make sure that results from this package are consistent with those from SpEC.\n\n\n\n\n\n","category":"module"},{"location":"internals/pn_expressions/#PostNewtonian.Kidder1995.r-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.Kidder1995.r","text":"r(pnsystem)\n\nEq. (4.13).\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Kidder1995.ṙ-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.Kidder1995.ṙ","text":"ṙ(pnsystem)\n\nEq. (4.12), computed as ṙ = (dE/dt) / (dE/dr), re-expanded and truncated.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Precession","page":"PN expressions","title":"Precession","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/precession.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.aₗ-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.aₗ","text":"aₗ(pnsystem)\n\nEq. (4.4) of Bohé et al. (2013).  This term contributes to 𝛡.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Ω⃗ᵪ-NTuple{8, Any}","page":"PN expressions","title":"PostNewtonian.Ω⃗ᵪ","text":"Ω⃗ᵪ(Mⱼ, Mₖ, χ⃗ⱼ, χ⃗ₖ, R)\n\nCompute the angular velocity of precession of spin vector χ⃗ⱼ.\n\nIn the approximation that the spin magnitude is constant, the time derivative of χⱼ is due to its rotation alone, and is given by Ωᵪ  χⱼ.\n\nNote that this function is called by Ω⃗ᵪ₁ and Ω⃗ᵪ₂ with the appropriate parameters; you probably want to use those instead of this one.\n\nThe spin-spin term is given by Eq. (2.4) of Kidder (1995); the spin-orbit terms by Eq. (4.5) of Bohé et al. (2013); and the quadrupole-monopole term by Eq. (2.7) Racine (2008).\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Ω⃗ᵪ₁-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.Ω⃗ᵪ₁","text":"Ω⃗ᵪ₁(pnsystem)\n\nCompute the angular velocity of precession of χ⃗₁\n\nIn the approximation that the spin magnitude is constant, the time derivative of χ₁ is due to its rotation alone, and is given by Ωᵪ₁  χ₁.\n\nNote that this function simply calls Ω⃗ᵪ with the appropriate parameters.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Ω⃗ᵪ₂-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.Ω⃗ᵪ₂","text":"Ω⃗ᵪ₂(pnsystem)\n\nCompute the angular velocity of precession of χ⃗₂\n\nIn the approximation that the spin magnitude is constant, the time derivative of χ₂ is due to its rotation alone, and is given by Ωᵪ₂  χ₂.\n\nNote that this function simply calls Ω⃗ᵪ with the appropriate parameters.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.Ω⃗ₚ-Tuple{Any}","page":"PN expressions","title":"PostNewtonian.Ω⃗ₚ","text":"Ω⃗ₚ(pnsystem)\n\nCompute the angular velocity of orbital precession.\n\nThis is the angular velocity of the orbital angular velocity direction unit vector ℓ; the time derivative of that unit vector is Ωₚ  ℓ.\n\nAt the moment, this is computed solely by expressions from Bohé et al. (2013).  See 𝛡 for details.\n\nSee also R.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#PostNewtonian.𝛡-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.𝛡","text":"𝛡(pnsystem)\n\nCompute the angular velocity of orbital precession according to Bohé et al.\n\nAs Bohé et al. (2013) explain above their Eq. (4.1), the orbital precession is given by the time derivative of the orbital axis: 𝓵̇ = 𝛡 × 𝓵, where the angular velocity is along the separation vector 𝓷, so that 𝛡 = ϖ 𝓷.  And in turn, they define aₗ ≔ r ω ϖ, where r is the separation and ω is the orbital angular frequency. Then, they define the PN parameter γₚₙ≔M/r and we have Mω = v³ so that ϖ = γₚₙ aₗ / v³.  The parameters γₚₙ and aₗ are given by Eqs. (4.3) and (4.4), and given here by the functions γₚₙ and aₗ.\n\nThe spin-squared terms (by which we mean both spin-spin and spin-orbit squared terms) in the energy are known to 3pN order, and given in Eq. (3.32) of Bohé et al. (2015).\n\nSee also R.\n\n\n\n\n\n","category":"method"},{"location":"internals/pn_expressions/#Mode-weights","page":"PN expressions","title":"Mode weights","text":"","category":"section"},{"location":"internals/pn_expressions/","page":"PN expressions","title":"PN expressions","text":"Modules = [PostNewtonian]\nPages   = [\"pn_expressions/mode_weights.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/pn_expressions/#PostNewtonian.h!-Union{Tuple{PNExpansionReducer}, Tuple{Any, Any}} where PNExpansionReducer","page":"PN expressions","title":"PostNewtonian.h!","text":"h!(h, pnsystem; ℓₘᵢₙ=0, ℓₘₐₓ=typemax(Int))\nmode_weights!(h, pnsystem; ℓₘᵢₙ=0, ℓₘₐₓ=typemax(Int))\n\nCompute mode weights of gravitational waves emitted by pn system, modifying h in place.\n\nnote: Note\nThis is a low-level function; you probably don't want to use this directly.  See coorbital_waveform or inertial_waveform for more user-friendly functions.\n\nThese modes are computed in the \"co-orbital\" frame, in which the larger object lies on the positive x axis, the smaller lies on the negative x axis, and the instantaneous angular velocity is in the positive z direction.\n\nThe modes are stored in h in order of increasing ℓ and increasing m, with m iterating fastest, all the way up to the highest available mode, (88).\n\nBecause gravitational waves have spin weight -2, the (ℓm)=(00), (1-1), (10), and (11) modes are always 0.  By default, we assume that these modes are nonetheless included in h.  If that is not the case, set ℓₘᵢₙ to the smallest ℓ value that should be present in the output data — ℓₘᵢₙ=2 being the most reasonable alternative.\n\nThese results come most directly from Eqs. (A5) of Boyle et al. (2014), with the exception of errors in the 2PN spin-spin terms, in which cases we must multiply by nu2 and make the substitutions S_1 mapsto S_0^+ and S_2 mapsto S_0^-.  In turn, those expressions are synthesized from the following:  Non-spinning terms are taken from Blanchet (2014), except for the highest-pN term in the (2,±2) mode, which are taken from Blanchet et al.  (2023), and the m=0 modes, which are taken from Favata (2008). The 1PN spin-orbit term is from Eq. (3.22d) of Kidder (1995).  The 1.5PN spin-orbit term is from Eq. (3.22f) of Kidder (1995) and Eq. (F15b) of Will and Wiseman (1996).  The 2PN spin-orbit term is from Eq. (4.13) of Buonanno, Faye, Hinderer (2013), while the 2PN spin-spin term is from Eq. (4.15) of that reference.\n\n\n\n\n\n","category":"method"},{"location":"interface/differentiation/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"interface/differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"While symbolic differentiation can be useful in many important scenarios, it is not very helpful for providing derivatives of general evolved waveforms, because waveforms require integration of ODEs.  However, Julia is quite capable of automatically differentiating even through an ODE integration — both gradients and Hessians — with respect to any or all of the initial conditions.","category":"page"},{"location":"interface/differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"There are many automatic differentiation packages in Julia.  Zygote will most likely be the best in the not-too-distant future, but at the time of writing, the simplest approach is to use ForwardDiff.jl.  A simple wrapper function that takes only the arguments to be differentiated may be needed.  The returned quantity will be a vector of waveforms corresponding to the derivative in the waveform at each instant with respect to the desired parameters.","category":"page"},{"location":"interface/differentiation/","page":"Automatic differentiation","title":"Automatic differentiation","text":"More broadly, it can also be helpful to differentiate a function of a waveform.  For example, if we are trying to minimize the difference between a waveform and a PN waveform, we may have a cost function that takes (some or all of) the PN parameters integrates the L^2 norm of the difference between them.  This cost function should be easily differentiable as well.","category":"page"},{"location":"interface/high-level/#High-level-interface","page":"High-level interface","title":"High-level interface","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"The typical workflow for users of this package will involve two or three steps:","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Integrate the orbital dynamics of a black-hole binary using the orbital_evolution function.\n(Optional) If not specified in step 1, choose the time steps on which you want the waveform.\nCompute the waveform as a function of the orbital dynamics using the inertial_waveform (or coorbital_waveform) function.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Here, we'll work through an example, and provide some more details.","category":"page"},{"location":"interface/high-level/#1.-Integrate-orbital-dynamics","page":"High-level interface","title":"1. Integrate orbital dynamics","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"First, we have to specify the initial masses, spins, and orbital angular frequency.  Let's arbitrarily choose something close to a hangup-kick configuration.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"using PostNewtonian\n\n# Initial values of the masses, spins, and orbital angular frequency\nM₁ = 0.6\nM₂ = 0.4\nχ⃗₁ = [0.7, 0.1, 0.7]\nχ⃗₂ = [-0.7, 0.1, 0.7]\nΩᵢ = 0.01\n\ninspiral = orbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ)\nnothing;  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"There are also numerous optional keyword arguments to orbital_evolution, controlling things like the range of frequencies over which to integrate (including possibly both forwards and backwards from the initial values), accuracy of the ODE integration, the PN order at which to compute the evolution equations, and so on.  See that function's documentation for details.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"The returned object named inspiral here is an ODESolution with many features, like high-order interpolation (using dense output from the ODE integrator).  The time steps at which the solution was saved are available as inspiral.t, and the evolved variables are available as inspiral.u, or by their names as in inspiral[:v] or inspiral[:Φ].  For example, we can plot the components of the spin of object 1 like this:","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"using Plots  # Requires also installing `Plots` in your project\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=2, leg=:top)  # hide\n\nplot(inspiral.t, inspiral[:χ⃗₁ˣ], label=raw\"$\\vec{\\chi}_1^x$\")\nplot!(inspiral.t, inspiral[:χ⃗₁ʸ], label=raw\"$\\vec{\\chi}_1^y$\")\nplot!(inspiral.t, inspiral[:χ⃗₁ᶻ], label=raw\"$\\vec{\\chi}_1^z$\")\nplot!(xlabel=\"Time (𝑀)\", ylabel=\"Dimensionless spin components\")\nsavefig(\"inspiral_spins.html\"); nothing  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"<!-- NOTE: ../ in src works on github, but not locally -->\n<iframe src=\"../inspiral_spins.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"As expected, we see significant precession of the spin on long time scales, as well as smaller nutations on orbital time scales visible mostly at later times.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"The evolved variables, in order, are","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"join(stdout, PostNewtonian.pnsystem_symbols, \", \")  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"They can be accessed by their symbols, like the spins above, or by their number in this list.  To access the ith variable at time step j, use sol[i, j]. You can also use colons: sol[i, :] is a vector of the ith variable at all times, and sol[:, j] is a vector of all the data at time step j.  For example, inspiral[:χ⃗₁ˣ] could also be written as inspiral[3, :].","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"By default, the output of orbital_evolution is just the time steps to which the adaptive ODE integrator happened to step.  If you know that you want the solution on a set of uniform time steps separated by dt — such as when you need to FFT the waveform — you can pass the option saveat=dt.  Or, if you somehow know the specific set of times t at which you want the solution, you can pass saveat=t.  Finally, if you want the solution — say — 32 times per orbit, you can pass the option saves_per_orbit=32, which calls uniform_in_phase as needed.","category":"page"},{"location":"interface/high-level/#sec_optional_choose_time_steps","page":"High-level interface","title":"2. (Optional) Choose time steps","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"If you did not pass the saveat or saves_per_orbit arguments to orbital_evolution (as described in the previous paragraph), the output will usually be on a fairly coarse set of times — possibly many times the orbital period for non-precessing systems.  However, in this case the solution will come with \"dense output\", which lets us quickly and accurately interpolate the solution to a new set of times.  This is important if you want the waveform to be sampled at the \"local\" Nyquist rate; anything less and the waveform will be distorted by aliasing.","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"For instance, suppose we want to plot the results every 05M for the last 5000M of the data.  We could define the new set of times as","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"t′ = inspiral.t[end]-5_000 : 0.5 : inspiral.t[end]\nnothing;  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"and then interpolate to this new set of times as","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"inspiral = inspiral(t′)\nnothing  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"We couldn't have achieved quite the same effect with the saveat argument mentioned above because in this case, we wanted to know the point at which we were 5000M before the end of the inspiral.  In general, if you need the results of orbital_evolution before you can decide what you want t′ to be, this is the approach you'll have to take.","category":"page"},{"location":"interface/high-level/#3.-Compute-the-waveform","page":"High-level interface","title":"3. Compute the waveform","text":"","category":"section"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Usually, we will also want the actual waveform from this system.  We can just call inertial_waveform (or coorbital_waveform for the waveform in a rotating frame in which the binary is stationary).","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"h = inertial_waveform(inspiral)\nnothing;  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"Again, we can plot the result:","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"plot(inspiral.t, real.(h[1, :]), label=raw\"$\\Re\\left\\{h_{2,-2}\\right\\}$\")\nplot!(inspiral.t, imag.(h[1, :]), label=raw\"$\\Im\\left\\{h_{2,-2}\\right\\}$\")\nplot!(inspiral.t, abs.(h[1, :]), label=raw\"$\\left|h_{2,-2}\\right|$\", linewidth=3)\nplot!(xlabel=\"Time (𝑀)\", ylabel=\"Mode weights\", ylim=(-0.5,0.5))\nsavefig(\"waveform.html\"); nothing  # hide","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"<!-- NOTE: ../ in src works on github, but not locally -->\n<iframe src=\"../waveform.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/high-level/","page":"High-level interface","title":"High-level interface","text":"We see oscillations in the amplitude of the h_2-2 mode on the orbital timescale, which is to be expected in a hangup-kick scenario as the system alternates between beaming power preferentially along the +z and -z directions.","category":"page"},{"location":"adding_terms/#Adding-new-PN-terms-or-expressions","page":"Adding terms","title":"Adding new PN terms or expressions","text":"","category":"section"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"danger: Cite your sources!\nRemember that it is absolutely crucial to record the source of any expressions in the relevant docstrings, including a link to the relevant paper.  If the terms or expressions in a given function come from more than one source, use comments inside the code itself to clarify exactly which parts come from which source.","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"The first step in actually adding new information is to decide where it fits in the hierarchy described in the \"Code structure\" page.  Most likely, you will want to add new terms to existing PN expressions, and possibly simple functions in PostNewtonian.DerivedVariables.","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"Existing code should be a good guide on how to do this.  However, it may appear as if some magic is happening in the various PN expressions, whereby variables like M₁, χ⃗₂, ν, Λ, etc., can be used without being defined.  These are automatically computed by way of the @pn_expression macro.  Also note that to correctly truncate a PN expansion at the desired order, the @pn_expansion macro must be used.","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"To make it easier to compare code to original sources, we also want to keep the code looking as similar as possible to equations as given in those sources, so try to keep variable names the same, and order things in the same ways as in the sources.  (Don't worry about rewriting expressions to optimize evaluation; Julia will probably do a better job automatically anyway.)  There are, however, a few important exceptions to this rule:","category":"page"},{"location":"adding_terms/","page":"Adding terms","title":"Adding terms","text":"If you need any new variables to be computed from the \"fundamental variables\", you should define them in the PostNewtonian.DerivedVariables module.  This will ensure that they can be automatically computed using the @pn_expression.\nIt is crucial to explicitly include factors of 1c to the appropriate power relative to the 0-pN order term inside the @pn_expansion macro.  For example, the first couple terms in the binding energy expansion look like\n32/5G * ν^2 * v^10 / c^5 * @pn_expansion(1 + (v/c)^2 * (-1247//336 - 35ν/12))\nThe 1/c^5 factor at the beginning is useful to remind us of the absolute order of this expression, but the 1/c^2 factor inside the @pn_expansion macro is crucial to ensure that the expression can be correctly truncated at the desired order. Thus, if you want to add a new 6-pN term to the binding energy, you could either manually code it inside the @pn_expansion expression, including its 1/c^12 factor, or you could create a separate function that should look like this:\n@pn_expression function binding_energy_6pn(pnsystem::PNSystem)\n    32/5G * ν^2 * v^12 / c^5 * @pn_expansion((v/c)^12 * 17//4)\nend\nNote that we have kept the 1/c^5 factor out front, and the 1/c^12 factor inside the @pn_expansion macro.  This tells the compiler that this is a 6-pN term, so if the user requests a lower pN order, the term should be ignored.\nIt should be possible to evaluate PN expressions using different precisions.  To ensure this, enter fractions as Irrationals — e.g., 9//5 instead of 9/5.  The latter would be immediately converted to the inexact 64-bit float value 1.8, which would poison other values.  Note that if you are multiplying by something else that already has general float type, as in 9π/5, you don't need to use Irrational; in this case, 9π is evaluated first and achieves full precision, and is then divided by the exact integer 5, so that it retains full precision.  Note that a helpful regex to search for this case is (?<!(ζ|n|\\^))[0-9]+/[0-9], which has relatively few false positives in this repo.\nA slight caveat to the above is that an expression like 3λ/2 could still be converted to Float64 if λ is defined at compile time to be 0.  For type-stability reasons, Julia will always treat 0/2 just like it would treat 7/2, which is converted to Float64.  Thus, it is probably safest to write expressions like 3//2 * λ.\nIf you happen to use any other math functions, similarly ensure that their arguments are converted appropriately to retain precision.  For unary functions, this can be done automatically by including the function name in the unary_funcs list used by @pn_expression.","category":"page"},{"location":"interface/units/#A-note-about-units","page":"Units","title":"A note about units","text":"","category":"section"},{"location":"interface/units/","page":"Units","title":"Units","text":"note: TL;DR:\nThis package uses geometric units with G=c=1.  Units are essentially determined by the values you input.  Masses and frequencies in particular must have inverse units.  For example, if frequency is measured in Hertz, mass should be measured in seconds.  The common relativist's convention of measuring in units of \"total mass\" (whatever that means to you) is also perfectly fine.Output time is in units of the total mass; to get the time in seconds, multiply by the total mass as measured in seconds.  Waveforms are output as the asymptotic quantity rhM; to get an observable strain, multiply by the total mass and divide by the distance to the source.You may want to skip to Example 2 for a complete example using astrophysical units.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The units of measurement used in this package are implicitly established by the input.  Specifically, the arguments M₁, M₂, and Ωᵢ in the call","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral = orbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"are inherently dimensionful, and the units are effectively determined by the values entered.  For example, if we enter 0.4 as M₁, we have established the units as — quite simply — those units in which M₁ has the value 0.4.  The only real requirement on the units of the input arguments is that they must be consistent.  In particular, the quantity (M₁+M₂)*Ωᵢ should be dimensionless.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"It must also be noted that this package uses geometric units where G=c=1; in fact, G and c never appear in the code at all.  This means that you must input values in geometric units, and interpret the output as being in geometric units.  This does not completely constrain the units, however.  There is still a freedom to scale the units however you wish.  For example, it is most common to describe all quantities in units of some mass M — such as the sum of the input masses M₁+M₂ or the Solar mass M_odot.  The input arguments would then all be given in units of that mass, or more likely some product of that mass with G and c.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The complete set of (required or optional) dimensionful arguments to orbital_evolution is","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"M₁, M₂, Ωᵢ, Λ₁, Λ₂, Ω₁, Ωₑ, abstol, saveat","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"If we scale the values by some σ, then to maintain the same physical meaning we should transform all the arguments as","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"M₁ ↦ M₁ * σ\nM₂ ↦ M₂ * σ\nΩᵢ ↦ Ωᵢ / σ\nΛ₁ ↦ Λ₁\nΛ₂ ↦ Λ₂\nΩ₁ ↦ Ω₁ / σ\nΩₑ ↦ Ωₑ / σ\nabstol ↦ [abstol[1:2] * σ; abstol[3:end]]\nsaveat ↦ saveat * σ","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Note that the scaling happens automatically for default values of the parameters; you would only need to rescale them if you were actually setting them.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"When the scaled arguments are provided to orbital_evolution, the resulting inspiral is affected as","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral.t ↦ inspiral.t * σ\ninspiral[:M₁] ↦ inspiral[:M₁] * σ\ninspiral[:M₂] ↦ inspiral[:M₂] * σ","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"All other evolved variables are dimensionless, and so are unaffected by the scaling.  In particular, if the initial conditions are entered with values of M₁ and M₂ in their desired final units, no change needs to be made.  On the other hand, if the values are entered so that M₁+M₂=1, we can rescale any BBH system to any desired total mass Mₜₒₜ using","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral.t ↦ inspiral.t * Mₜₒₜ * G / c^3","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Furthermore, if M₁ and M₂ represent the source-frame mass, and we need to apply a cosmological redshift z, we simply apply","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"inspiral.t ↦ inspiral.t * (1+z)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The waveform H returned by either coorbital_waveform or inertial_waveform is the rescaled asymptotic limit of the strain.  The observable strain is","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"h approx H fracMr fracGc^2\nqquad mathrmor qquad\nh approx H fracM_zd_mathrmL fracGc^2","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"(The equality is only approximate because we assume that terms in 1r^2 can be ignored, which is almost certainly true of any detection in the foreseeable future.)  Here, r is the radius of the observer in asymptotically Minkowski coordinates centered on the source and M is the total mass of the binary; alternatively, M_z=M(1+z) is the redshifted mass and d_mathrmL is the luminosity distance between the source and observer.  For more complete description, see here.","category":"page"},{"location":"interface/units/#Example-1:-Scale-dependence","page":"Units","title":"Example 1: Scale dependence","text":"","category":"section"},{"location":"interface/units/","page":"Units","title":"Units","text":"It's important to check that the claims above are actually true.  Here, we put them to the test with a very large scale factor.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"using PostNewtonian, Plots  # hide\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=3, leg=:top, legendfontsize=11)  # hide\nσ = 10.0^10  # Scale factor\n\nM₁ = 0.4\nM₂ = 0.6\nχ⃗₁ = [0.0, 0.5, 0.8]\nχ⃗₂ = [0.8, 0.0, 0.5]\nΩᵢ = 0.01\nΩ₁ = 3Ωᵢ/4\nΩₑ = 0.9\ndt = 5.0\n\ninspiral1 = orbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ, Ω₁=Ω₁, Ωₑ=Ωₑ, saveat=dt)\ninspiral2 = orbital_evolution(M₁*σ, M₂*σ, χ⃗₁, χ⃗₂, Ωᵢ/σ, Ω₁=Ω₁/σ, Ωₑ=Ωₑ/σ, saveat=dt*σ)\n\nplot(inspiral1.t, inspiral1[:v], label=\"Original\")\nplot!(inspiral2.t/σ, inspiral2[:v], label=\"Scaled\", linewidth=4, ls=:dot)\nplot!(xlabel=\"Time\", ylabel=\"PN parameter 𝑣\")\nsavefig(\"units1.html\"); nothing  # hide\n\n# Check that the evolved `v` parameters are nearly equal (when interpolating\n# the second to *exactly* the same times as the first)\ninspiral1[:v] ≈ inspiral2(inspiral1.t*σ, idxs=:v)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"<!-- NOTE: ../ in src works on github, but not locally -->\n<iframe src=\"../units1.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The fact that these curves are on top of each other, and the final expression returned true shows that this system does indeed depend on scale as suggested above.","category":"page"},{"location":"interface/units/#Units-example-2","page":"Units","title":"Example 2: Astrophysical units","text":"","category":"section"},{"location":"interface/units/","page":"Units","title":"Units","text":"Suppose we want to construct a system consistent with GW150914, having source-frame masses 356M_odot and 300M_odot, as it would be observed from a distance of 440mathrmMpc with an initial frequency in the dominant (ellm)=(2pm 2) modes of f_i approx 20mathrmHz.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Because the masses and frequencies must be in inverse units, we arbitrarily choose to measure frequencies in their natural unit of Hertz, and therefore masses are measured in seconds — multiplying the masses by Gc^3 for geometric units.  The distance to the source d_mathrmL will also be converted to seconds by dividing by c, so that we can simply multiply the waveform by M_zd_mathrmL to get the observed strain.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"The frequency f_i is the observed initial frequency of the (22) mode. We will need the corresponding angular orbital frequency in the frame.  Recall that, by definition of redshift z, we have","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"fracf_mathrmsource f_mathrmobserver = 1+z\nqquad\ntextand\nqquad\nfracDelta t_mathrmobserverDelta t_mathrmsource = 1+z","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Thus, the initial source-frame orbital angular frequency Omega_i is related to the observer-frame (22) temporal frequency f_i by[1]","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"Omega_i = 2pi f_mathrmsource^(22)  2 qquad f_i = f_mathrmobserver^(22)\nqquad\nfracf_mathrmsource^(22) f_mathrmobserver^(22) =\nfracOmega_ipi f_i = 1+z\nqquad\nOmega_i = pi f_i (1+z)","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"[1]: Here, we have approximated the frequency of the (ellm)=(2pm 2) modes as being twice the orbital frequency.  In the post-Newtonian approximation, waveform mode H_ellm is frequently written as A_ellm exp-i m Phi, where Phi is the orbital phase that varies in time with dPhidt = Omega.  Just looking at the exponential, we might expect the frequency of H_ellm to be m Omega.  However, the \"amplitude\" term A_ellm is not an amplitude in the usual sense; it is actually complex, with a slowly varying phase. This means that the frequency of H_ellm is not precisely m Omega — though this is a reasonable approximation for systems with reasonably low frequency.","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"using Quaternionic\nusing SphericalFunctions\nusing PostNewtonian\nusing Plots\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=3, leg=:top, legendfontsize=11)  # hide\n\n# Useful astronomical constants\nc = float(299_792_458)   # meters/second\nGMₛᵤₙ = 1.32712440041e20  # meters³/second²\nau = float(149_597_870_700)  # meters\npc = 1au / (π / 648_000)  # meters\nMpc = 1_000_000pc  # meters\n\n# Approximate maximum a posteriori spins (via SXS:BBH:0308)\nχ⃗₁ = [0.0, 0.0, 0.3224]\nχ⃗₂ = [0.2663, 0.2134, -0.5761]\n\n# Parameters of this system (arXiv:1606.01210)\nM₁ = 35.6GMₛᵤₙ / c^3  # seconds\nM₂ = 30.0GMₛᵤₙ / c^3  # seconds\ndL = 440Mpc / c  # seconds\nz = 0.094\nfᵢ = 20  # Hertz\nΔtₒ = 1/2048  # seconds\n\n# Conversions\nMz = (M₁+M₂) * (1+z)  # seconds\nΩᵢ = π * fᵢ * (1+z)  # Hertz\nΔtₛ = Δtₒ / (1+z)  # seconds\n\n# Evaluate waveform and convert to observer's frame and units\ninspiral = orbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ, saveat=Δtₛ)\ntₒ = (1+z) * inspiral.t\nHₗₘ = inertial_waveform(inspiral)\nhₗₘ = Hₗₘ * Mz / dL\n\n# Evaluate waveform at a point; see Scri.jl for simpler methods\nR = Quaternionic.from_spherical_coordinates(2.856, 0.0)\n₋₂Yₗₘ = SphericalFunctions.ₛ𝐘(-2, 8, Float64, [R])[1, :]\nh = (₋₂Yₗₘ' * hₗₘ)[1,:]\n\n# Plot the results\nplot(tₒ, real.(h), label=\"ℎ₊\")\nplot!(tₒ, -imag.(h), label=\"ℎₓ\")\nplot!(xlabel=\"Time (seconds)\", ylabel=\"Strain (dimensionless)\", ylim=(-1.5e-21,1.5e-21))\nplot!(title=\"Observer-frame waveform\", legend=(0.205, 0.9))\nsavefig(\"units2.html\"); nothing  # hide","category":"page"},{"location":"interface/units/","page":"Units","title":"Units","text":"<!-- NOTE: ../ in src works on github, but not locally -->\n<iframe src=\"../units2.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"interface/assorted_binaries/#Assorted-binaries","page":"Assorted binaries","title":"Assorted binaries","text":"","category":"section"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"For convenience, an assortment of constructors is provided for relevant classes of physical scenarios, as well as the ability to construct random systems across a broad range of reasonable physical parameters.","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"In each case, the returned object is a PNSystem, which can be used as input to most functions in this package — most notably the orbital_evolution function. For example, to integrate the inspiral of a binary black-hole system in \"superkick\" configuration, we could write","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"inspiral = orbital_evolution(superkick())","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"This implicitly provides the M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ, Rᵢ, and PNOrder arguments (along with Λ₁ and/or Λ₂ for BHNS or NSNS systems) to orbital_evolution; other keyword arguments to that function can be provided after superkick().","category":"page"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"Modules = [PostNewtonian]\nPages   = [\"assorted_binaries/examples.jl\"]","category":"page"},{"location":"interface/assorted_binaries/#PostNewtonian.hangup_kick-Tuple{}","page":"Assorted binaries","title":"PostNewtonian.hangup_kick","text":"hangup_kick(;v=0.2, χ=0.99, θ=deg2rad(50.98), ϕ=deg2rad(30.0), PNOrder=typemax(Int))\nhangup_kick(;v=0.2, chi=0.99, theta=deg2rad(50.98), phi=deg2rad(30.0), PNOrder=typemax(Int))\n\nConstruct a black-hole binary in hangup-kick configuration.\n\nThe spin magnitudes are both equal to χ.  The direction of vecchi_1 is given by the spherical coordinates (θ, ϕ).  vecchi_2 is the same, except that its projection into the orbital plane is opposite to that of vecchi_1.\n\nSee also superkick for the original systems, which can't actually achieve recoil kicks as large as those achieved by \"hangup-kick\" systems.\n\nThe physical mechanism here is similar to the one described in superkick, with an additional \"hangup\" due to the fact that the spins have components parallel to the orbital angular velocity.  The physical interpretation of that part is that any system with such spin components will not merge as quickly because the remnant black hole must have total dimensionless spin less than 1, so excess angular momentum must be radiated away.  This gives the hangup-kick configuration more time to develop a large recoil.\n\nExamples\n\njulia> pnsystem = hangup_kick(v=0.1)\nBBH{Vector{Float64}, 9223372036854775805//2}([0.5, 0.5, 0.3845784887294712, 0.6661094819774992, 0.6232957115416596, -0.3845784887294712, -0.6661094819774992, 0.6232957115416596, 1.0, 0.0, 0.0, 0.0, 0.1, 0.0])\n\njulia> inspiral = orbital_evolution(pnsystem);\n\njulia> inspiral[:v, 1]\n0.1\n\njulia> absvec(PostNewtonian.χ⃗₁(inspiral[1]))\n0.99\n\n\n\n\n\n","category":"method"},{"location":"interface/assorted_binaries/#PostNewtonian.superkick-Tuple{}","page":"Assorted binaries","title":"PostNewtonian.superkick","text":"superkick(;v=0.2, χ=0.99, PNOrder=typemax(Int))\nsuperkick(;v=0.2, chi=0.99, PNOrder=typemax(Int))\n\nConstruct a black-hole binary in \"superkick\" configuration.\n\nThis is the scenario first published by Campanelli et al. (2007), which has equal-mass black holes with spins of equal magnitude oriented in opposite directions in the orbital plane.  This configuration produces large asymmetrical emission of gravitational-wave linear momentum along the +z or -z directions, depending on which part of the orbit the binary is in.  Depending on when the system mergers, the remnant may then acquire a huge recoil velocity.\n\n(That recoil velocity, of course, depends on details of the merger, which post-Newtonian approximations cannot describe.  Therefore, we cannot actually use PN methods to derive any useful information about the remnant.)\n\nNote that the name \"superkick\" appeared in the literature before a class of systems that can achieve even larger recoil velocities: see hangup_kick for such systems.\n\nExamples\n\njulia> pnsystem = superkick(v=0.1)\nBBH{Vector{Float64}, 9223372036854775805//2}([0.5, 0.5, 0.99, 0.0, 0.0, -0.99, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.1, 0.0])\n\njulia> inspiral = orbital_evolution(pnsystem);\n\njulia> inspiral[:v, 1]\n0.1\n\njulia> absvec(PostNewtonian.χ⃗₁(inspiral[1]))\n0.99\n\n\n\n\n\n","category":"method"},{"location":"interface/assorted_binaries/","page":"Assorted binaries","title":"Assorted binaries","text":"rand(pnclass::PNSystem; v, PNOrder)","category":"page"},{"location":"interface/assorted_binaries/#Base.rand-Tuple{PNSystem}","page":"Assorted binaries","title":"Base.rand","text":"rand([rng=default_rng()], pnclass; [v=0.2], [PNOrder=typemax(Int)])\n\nGenerate a random PNSystem, specifically of class pnclass (one of BBH, BHNS, or NSNS), with parameters chosen to be consistent with typical LIGO/Virgo/KAGRA searches as of this writing.\n\nExamples\n\njulia> pnsystem = rand(BBH);\n\njulia> inspiral = orbital_evolution(pnsystem);\n\n\nParameter ranges\n\nChoosing the space of parameters from which to randomly select values is nontrivial.  The most relevant numbers are of two types from LIGO/Virgo/KAGRA: (1) the range of parameters over which systems are searched for, and (2) the range of parameters used as priors in parameter estimation.\n\nAppendix B1 of LIGO's GWTC-1 catalog paper says that the \"spin vectors are assumed to be isotropic on the sphere and uniform in spin magnitude\", with two choices of uniform magnitude: a_i leq 089 and a_i leq 005.  The dimensionless tidal deformabilities Lambda_i of each NS are assumed to be jointly uniform within 0 leq Lambda_i leq 5000.\n\nThe more current GWTC-3 paper searches with the following:\n\nThe PyCBC-BBH analysis focuses on a region ranging in primary component mass from 5M to 350M, with mass ratios from 1/3 to 1, and effective spins ranging from chi_mathrmeff = 0998 to 0998.\n\nThat paper's parameter estimation uses uniform priors over spin magnitudes and redshifted component masses; isotropic spin orientation, sky location and binary orientation; mass-ratio q in 005 1 (sometimes extending down to q=002).  It seems that the actual ranges of the spin magnitudes and masses are restricted based on initial guesses, which may be expanded to ensure that the posteriors lie entirely within the priors.  The distance priors are uniform in D_mathrmL^2, with some adjustments due to cosmology.\n\nFor the purposes of this package, we're not too interested in absolute scales — specifically distance or total mass — so we'll just choose the total mass to be 1 at the initial frequency, then sample based on mass ratio and spin magnitudes.\n\nGiven these, it seems like the current state of the art would be well covered by choosing a random q ∈ [0.05, 1], χᵢ ∈ [0, 0.998], and Λᵢ ∈ [0, 5000], with isotropic choices for orientations.  Note that the Λᵢ are only used if the input pnclass is BHNS or NSNS.\n\nIf you would prefer a different range of parameters, the source code for this function is easily modified.\n\n\n\n\n\n","category":"method"},{"location":"interface/gwframes/#GWFrames-compatibility-layer","page":"GWFrames","title":"GWFrames compatibility layer","text":"","category":"section"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"GWFrames is an old python package that was too hard to upgrade to python 3, and therefore became impossible to maintain.  Many of its capabilities have been superseded by the scri and sxs packages, but not the post-Newtonian capabilities.  This package now supersedes the latter.  For convenience, the PostNewtonian.GWFrames submodule provides a simple function to mimic the arguments used with the original GWFrames package to obtain a PN waveform (with a couple extra arguments).  We won't bother to provide a return type that can fully mimic the object returned by the original GWFrames package, though it should be similar to the ones used by scri and sxs.","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"This interface can be used directly from Julia, but is more likely to be wanted by python users.  To borrow from the example in the standard python interface documentation:","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"# Any python imports you need go here\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Start the Julia session\nfrom sxs.julia import GWFrames\n\n# Declare the essential parameters\ndelta = 0.0\nchi1 = [0.1, 0.2, 0.3]\nchi2 = [-0.2, 0.1, -0.3]\nOmega_i = 0.01\n\n# Call into Julia to run some function\nw = GWFrames.PNWaveform(\"TaylorT1\", delta, chi1, chi2, Omega_i)\n\n# Plot the magnitudes of all the modes as functions of time\nplt.semilogy(w.t, np.abs(w.data))","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"This should produce precisely the same plot as the python example, but using the GWFrames interface.  Note that the parameters given here are required, but optional parameters are the same as in the original GWFrames interface — which are listed in full in the docstring below.","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"When called directly from Julia, the result will just be a NamedTuple with fields described in the docstring below.  When called from python as shown above, the resulting w will be an sxs.WaveformModes object, with all the usual methods and properties, as well as several fields relevant to post-Newtonian waveforms:","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"M1 (array): The primary mass as a function of time.\nM2 (array): The secondary mass as a function of time.\nchi1 (array): The primary spin as a function of time.\nchi2 (array): The secondary spin as a function of time.\nframe (array): The quaternionic frame as a function of time.\nv (array): The orbital velocity as a function of time.\norbital_phase (array): The orbital phase as a function of   time.","category":"page"},{"location":"interface/gwframes/","page":"GWFrames","title":"GWFrames","text":"Modules = [PostNewtonian.GWFrames]\nPages   = [\"gwframes.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"interface/gwframes/#PostNewtonian.GWFrames.PNWaveform","page":"GWFrames","title":"PostNewtonian.GWFrames.PNWaveform","text":"PNWaveform(Approximant, delta, chi1_i, chi2_i, Omega_orb_i; kwargs...)\n\nCompute a PN waveform, with the same call signature as GWFrames.PNWaveform\n\nThis is essentially a compatibility layer for the corresponding function in the original GWFrames Python package, with several additional optional arguments: inertial, dt, quiet, ell_min, ell_max, Lambda1, and Lambda2 (see below).  Also, this function accepts optional arguments either as positional arguments (which the original GWFrames requires) or as keyword arguments.\n\nwarning: Warning\nWe do not expect the result of this function to be identical to the result from the GWFrames Python package.  In particular, this package uses more general expressions for the tidal-heating terms, fixes an error in the 2PN quadratic-spin terms for the waveform modes, uses more accurate (and efficient) ODE integration, and uses a more accurate method to compute the number of steps per orbit (by default).Also note that there are differences in the order of operations for computing intermediate variables.  Cancellation and roundoff error caused by these differences can have surprisingly large effects on the orbital evolution in many cases — particularly for precessing systems.  Results from the two packages have been painstakingly analyzed, leading to the conclusion that all differences are caused by such errors or the differences in formulations mentioned above.\n\nThe Julia interface is more detailed, flexible, and efficient than the simple GWFrames interface that this function emulates.  In particular, orbital_evolution takes essentially all the same arguments that DifferentialEquations.solve takes, and returns a solution that provides dense output and more details about the ODE solution itself.  For example, one reason this function is more efficient than GWFrames is that we can use dense output to solve with fewer timesteps, while accurately and efficiently interpolating to the requested timesteps.  While orbital_evolution solves for the dynamics, coorbital_waveform or inertial_waveform provides the actual waveform; both are returned by this function.\n\nRequired arguments\n\nApproximant: Currently, supported arguments are \"TaylorT1\", \"TaylorT4\", and \"TaylorT5\".\ndelta: Fractional mass difference (M₁-M₂)(M₁+M₂)\nchi1_i: Normalized spin vector S₁M₁²\nchi2_i: Normalized spin vector S₂M₂²\nOmega_orb_i: Orbital angular frequency at initial instant\n\nOptional arguments\n\nAs mentioned above, the following may be given either as positional arguments in this order (though any number of them may be omitted from the end), or as keyword arguments.\n\nOmega_orb_0=Omega_orb_i: Orbital angular frequency at first instant found in data.  If this is less than Omega_orb_i, the system is integrated backwards in time from the latter value to this value.\nR_frame_i=Rotor(1): Initial orientation of the frame.\nMinStepsPerOrbit=32: Number of time steps in the output data per orbit.  Because the waveform modes go as high as m=8, this number should be at least 16 to avoid Nyquist aliasing in those modes.  Note that this value may be overridden by dt (see below).\nPNWaveformModeOrder=4.0: Maximum PN order of terms in the waveform formulas.\nPNOrbitalEvolutionOrder=4.0: Maximum PN order of terms in the orbital-evolution formulas.\ninertial=false: If true, transform waveform to the inertial frame; otherwise, the waveform will be in the co-orbital frame.\ndt=0: Uniform time step size of the output.  If this is not a strictly positive number, MinStepsPerOrbit will be used instead.\nquiet=true: If false, show informational messages about the reasons for terminating the ODE integration.  In either case, warnings will still be issued if terminating for bad or suspicious reasons.  See the documentation of orbital_evolution for an example of how to filter warnings also.\nell_min=2: The lowest ℓ value in the output waveform.\nell_max=8: The highest ℓ value in the output waveform.\nLambda1=0: Tidal-coupling parameter of object 1.\nLambda2=0: Tidal-coupling parameter of object 2.\n\nReturned values\n\nThis function returns a NamedTuple with the following keys:\n\nt: The vector of time steps at which the data are evaluated.  The time t=0 corresponds to the initial values that are arguments to this function.\ndata: Matrix of complex values of the mode weights.  The shape is length(t) x 77.  The first dimension enumerates the values at each instant of time.  The second dimension enumerates the modes, starting with (2-2), then (2-1), up to (22), followed by (3-3), and so on up to (88).  This is the opposite ordering as results from GWFrames, but the same as the ordering used by the sxs and scri packages.  However, also note that certain conversions between Julia and Python may transpose matrices, because Julia is Fortran-ordered by default, whereas numpy is C-ordered.  It is best to check the shape manually to be sure which dimension is which.\nframe: Matrix of shape length(t) x 4 representing the frame-orientation quaternion as a function of time t.\nM1, M2: Vectors of the respective masses as functions of time t.  Note that only at the time corresponding to Omega_orb_i will the total mass be precisely 1. Generally, tidal heating will lead to time-dependent masses.\nchi1, chi2: Matrices of shape length(t) x 3 representing the spins as functions of time t.\nv: PN velocity parameter as a function of time t.\nPhi: Orbital phase as a function of time t.\n\nBecause this is a NamedTuple, the fields can be accessed much like the fields of a WaveformModes object in the scri or sxs Python packages — as in w.t and w.data, where w is the object returned by this function.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"internals/utilities/#PN-terms-and-PN-expansions","page":"Utilities","title":"PN terms and PN expansions","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"The basic building blocks of post-Newtonian theory are the terms and expansions.  These are used to build up the various expressions that describe the dynamics of the system.  The terms are the individual parts of the expansions, while the expansions are the full expressions that are expanded in powers of 1c.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"PostNewtonian.PNTerm\nPostNewtonian.PNExpansionParameter\nPostNewtonian.PNExpansion","category":"page"},{"location":"internals/utilities/#PostNewtonian.PNTerm","page":"Utilities","title":"PostNewtonian.PNTerm","text":"PNTerm{T,PNOrder,c⁻¹Exponent}\n\nThis object represents a single term in a PNExpansion.  It has a single field: coeff, which is the coefficient of the term.  The type parameter T is the type of the coefficient.  The type parameter PNOrder is a half-integer (just as in PNSystems) representing the PN order of the expansion.  And the type parameter c⁻¹Exponent is an integer representing the exponent of the PN expansion parameter 1c.\n\nPNTerms can be multiplied and divided by scalars and exponentiated by integers, to produce another PNTerm.  They can also be added to other PNTerms to produce a PNExpansion.\n\nA simple way to define a PNTerm or a PNExpansion is to define the PN expansion parameter\n\nc = PNExpansionParameter(pnsystem)\n\nand use that naturally in formulas, as in\n\ne = 1 + (v/c)^2 * (-ν/12 - 3//4) + (v/c)^4 * (-ν^2/24 + 19ν/8 - 27//8)\n\nAny exponent higher than the desired PNOrder will be automatically set to zero.\n\nUseful facts:\n\nv has order 1/c\nx has order 1/c^2\nγ has order 1/c^2\n1/r has order 1/c^2\n\n\n\n\n\n","category":"type"},{"location":"internals/utilities/#PostNewtonian.PNExpansionParameter","page":"Utilities","title":"PostNewtonian.PNExpansionParameter","text":"PNExpansionParameter(pnsystem)\n\nCreate a PNTerm object representing the post-Newtonian expansion parameter c. This can be used to automatically create more complicated PNTerms, which combine to form a PNExpansion.  This is a simple but effective way to write PN formulas while automatically tracking the PN order of each term.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.PNExpansion","page":"Utilities","title":"PostNewtonian.PNExpansion","text":"PNExpansion{N,T,NMax}\n\nThis object can be multiplied by a scalar or another PNExpansion object, and contains a tuple of coefficients.  The coefficients are stored in the order of the expansion, with the zeroth-order coefficient first.  Multiplication by a scalar just multiplies each of the elements.  Multiplication by another PNExpansion object is done by convolving the two tuples of coefficients.\n\nBlanchet (2014) defines the post-Newtonian expansion parameter as follows:\n\nThis parameter represents essentially a slow motion estimate ϵ  𝑣𝑐, where 𝑣 denotes a typical internal velocity.  By a slight abuse of notation, following Chandrasekhar et al. [...], we shall henceforth write formally ϵ  1𝑐, even though ϵ is dimensionless whereas 𝑐 has the dimension of a velocity. Thus, 1𝑐  1 in the case of post-Newtonian sources. The small post-Newtonian remainders will be denoted 𝒪(1𝑐^𝑛). Furthermore, [...] we shall refer to a small post-Newtonian term with formal order 𝒪(1𝑐^𝑛) relative to the Newtonian acceleration in the equations of motion, as frac𝑛2textPN.\n\nTherefore, we consider the coefficients of the PNExpansion to be a polynomial in 1𝑐. Here, the type parameter N corresponds to the number of elements actually present in the tuple of coefficients, and T is the type of the coefficients.  The NMax parameter is the maximum number of elements, related to the usual PN order by\n\ntextpn_order = fractextttNMax-1 2\n\nThe N parameter is not related to the PN order; it is just used by Julia to know how many elements are currently in the coefficients, but is required to be 1 ≤ N ≤ NMax.\n\n\n\n\n\n","category":"type"},{"location":"internals/utilities/#Macros","page":"Utilities","title":"Macros","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Some of the most useful features of this package are the macros allowing us to write PN expressions in fairly natural form, without worrying about calculating all the variables needed for each expression, or manually accounting for the various PN orders to which we may need to truncate PN expansions.  To achieve this, we rely primarily on two macros.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/macros.jl\"]\nOrder   = [:macro, :module, :type, :constant, :function]","category":"page"},{"location":"internals/utilities/#PostNewtonian.@pn_expansion-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.@pn_expansion","text":"@pn_expansion [pnsystem] expansion\n\nGather terms in expansion by the powers of 1c involved, zeroing out any terms with powers of 1c higher than the pnsystem's PNOrder parameter, and combine the terms using the PNExpansionReducer specified in argument of the function that includes this macro call.\n\nThis expansion is achieved by setting — inside a let block created by this macro —\n\nNote that the pnsystem argument can be inserted automatically by @pn_expression.\n\n\n\n\n\n","category":"macro"},{"location":"internals/utilities/#PostNewtonian.@pn_expression-Tuple{Any}","page":"Utilities","title":"PostNewtonian.@pn_expression","text":"@pn_expression [arg_index=1] func\n\nThis macro takes the function func, looks for various symbols inside that function, and if present defines them appropriately inside that function.\n\nThe first argument to this macro is arg_index, which just tells us which argument to the function func is a PNSystem.  For example, the variables defined in PostNewtonian.FundamentalVariables all take a single argument of pnsystem, which is used to compute the values for those variables; this macro just needs to know where to find pnsystem.\n\nOnce it has this information, there are five types of transformations it will make:\n\nAdds a keyword argument pn_expansion_reducer::Val{PNExpansionReducer}=Val(sum) to the function signature.  This is used to determine how to reduce the PN expansion terms. The default is Val(sum), which will just return a single number,  but Val(identity) can be used to return the expansion.  This should be used inside the function as PNExpansionReducer, and will be automatically used inside any @pn_expansion.\nFor every fundamental or derived variable, the name of that variable used in the body of func will be replaced by its value when called with pnsystem.  For example, you can simply use the symbols M₁ or μ in your code, rather than calling them as M₁(pnsystem) or μ(pnsystem) every time they appear.\nEvery Irrational defined in Base.MathConstants or PostNewtonian.MathConstants will be transformed to the eltype of pnsystem.  This lets you naturally use such constants in expressions like 2π/3 without automatically converting to Float64.\nEach of a short list of functions given by unary_funcs in utilities/macros.jl will first convert their arguments to the eltype of pnsystem.  In particular, you can use expressions like √10 or ln(2) without the result being converted to a Float64.\nInsert the pnsystem argument as the first argument to each occurrence of @pn_expansion that needs it.\n\nTo be more explicit, the first three are achieved by defining the relevant quantities in a let block placed around the body of func, so that the values may be used efficiently without recomputation.\n\nIf you need to use one of the fundamental- or derived-variable functions as arguments of values other than those encapsulated in pnsystem, you'll need to address them explicitly with the module name — as in PostNewtonian.v(;Ω, M).\n\n\n\n\n\n","category":"macro"},{"location":"internals/utilities/#PostNewtonian.type_converter-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.type_converter","text":"type_converter(pnsystem, x)\n\nConvert x to a type appropriate for the float type of pnsystem.\n\nThis is sort of an expansion of the convert function, but with nicer syntax for types from this package, including the ability to do really weird things for SymbolicPNSystem.  It's needed to ensure that the types of variables and constants are correct when we use them in expressions, rather than just assuming everything is a Float64.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#Termination-criteria","page":"Utilities","title":"Termination criteria","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Hopefully, it should not be necessary to directly use these termination criteria.  They are used by default in the orbital_evolution function. But certain particularly extreme physical parameters may lead ODEs that are difficult to integrate — especially if new PN systems or terms are introduced. These, or similar functions may be helpful examples of \"callbacks\" that can be passed to the ODE integrator.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Note that several of these will issue warnings if the evolution has to be terminated for particularly bad or suspicious reasons, even if the quiet flag is set to true.  See the documentation of the quiet argument to the orbital_evolution function for an example of how to use Logging to quiet even the warnings.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/termination_criteria.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.decreasing_v_terminator","page":"Utilities","title":"PostNewtonian.decreasing_v_terminator","text":"decreasing_v_terminator([quiet])\n\nConstruct termination criterion to stop integration when v is decreasing.\n\nNote that some systems may truly have decreasing v as physical solutions — including eccentric systems and possibly precessing systems.  You may prefer to implement another solution, like detecting when v decreases below some threshold, or detecting when v is decreasing too quickly.  See this function's source code for a simple\n\nIf this terminator is triggered while v is less than 0.35, a warning will always be issued; otherwise an info message will be issued only if the quiet flag is set to false.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.dtmin_terminator","page":"Utilities","title":"PostNewtonian.dtmin_terminator","text":"dtmin_terminator(T, [quiet])\n\nConstruct termination criterion to terminate when dt drops below √eps(T).\n\nPass force_dtmin=true to solve when using this callback.  Otherwise, the time-step size may decrease too much within a single time step, so that the integrator itself will quit before reaching this callback, leading to a less graceful exit.\n\nIf this terminator is triggered while v is less than 0.35, a warning will always be issued; otherwise an info message will be issued only if the quiet flag is set to false.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.nonfinite_terminator-Tuple{}","page":"Utilities","title":"PostNewtonian.nonfinite_terminator","text":"nonfinite_terminator()\n\nConstruct termination criterion to stop integration when any NaN or Inf is found in the data after an integration step.\n\nIf this terminator is triggered, a warning will always be issued.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.termination_backwards","page":"Utilities","title":"PostNewtonian.termination_backwards","text":"termination_backwards(v₁, [quiet])\n\nConstruct termination criteria of solving PN evolution backwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at v₁.\n\nThe optional quiet argument will silence informational messages about reaching the target value of v₁ if set to true, but warnings will still be issued when terminating for other reasons.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.termination_forwards","page":"Utilities","title":"PostNewtonian.termination_forwards","text":"termination_forwards(vₑ, [quiet])\n\nConstruct termination criteria of solving PN evolution forwards in time\n\nThese criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at vₑ.\n\nThe optional quiet argument will silence informational messages about reaching the target value of vₑ if set to true, but warnings will still be issued when terminating for other reasons.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#Manipulating-ODE-solutions","page":"Utilities","title":"Manipulating ODE solutions","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/combine_solutions.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.combine_solutions-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.combine_solutions","text":"combine_solutions(sol₋, sol₊)\n\nCombine ODESolutions\n\nThis function is internal to this package.  It is not entirely general, but allows us to combine the backwards- and forwards-in-time solutions of the PN orbital-evolution ODE equations into a single ODESolution object that should behave just as if it were the result of solve.  In particular, indexing, interpolation, and iterations should behave exactly as described in the DifferentialEquations docs.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#Irrational-constants","page":"Utilities","title":"Irrational constants","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"These quantities are constants that appear in PN expressions, so they are not exported, but can be used by importing them explicitly or by using the fully qualified names.  They are defined here as Irrationals.  This means that Julia can convert them to float types as necessary.  Unfortunately, by default Julia converts to Float64.  For example, BigFloat(2ζ3) will be a BigFloat, but will only have the precision of a Float64, because 2ζ3 is converted first. To get full precision, you'll need to do things like 2BigFloat(ζ3).","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"One approach to avoiding this is to explicitly redefine these constants as floats of the desired precision, using let to essentially overwrite the name:","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"function foo(x)\n    let ζ3=oftype(x, ζ3)\n        2ζ3 + x\n    end\nend","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Inside the let block, ζ3 is no longer an Irrational; it has been converted to whatever number type x is.  Thus, when multiplying by 2, it is not converted to a Float64; its precision matches that of x.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"This can be quite awkward, so the macro PostNewtonian.@pn_expression is provided to (among other things) automatically search for all Irrationals and replace them with the appropriate float values.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"PostNewtonian.γₑ\nPostNewtonian.ζ3\nPostNewtonian.ln2\nPostNewtonian.ln3\nPostNewtonian.ln5\nPostNewtonian.ln³╱₂\nPostNewtonian.ln⁵╱₂","category":"page"},{"location":"internals/utilities/#PostNewtonian.MathConstants.γₑ","page":"Utilities","title":"PostNewtonian.MathConstants.γₑ","text":"γₑ\n\nEuler's constant (also known as the Euler–Mascheroni constant) is defined as the limit as n to infty of the difference between the nth partial sum of the harmonic series and log(n).  This is OEIS sequence A001620.\n\njulia> PostNewtonian.γₑ\nγₑ = 0.5772156649015...\n\njulia> n=10_000_000; sum(1 ./ (1:n))-log(n)\n0.5772157149015307\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ζ3","page":"Utilities","title":"PostNewtonian.MathConstants.ζ3","text":"ζ3\napery\n\nApéry's constant is defined as ζ(3), where ζ is the Riemann zeta function.  This is OEIS sequence A002117.\n\njulia> PostNewtonian.apery\nζ3 = 1.2020569031595...\n\njulia> PostNewtonian.ζ3\nζ3 = 1.2020569031595...\n\njulia> sum((1:10_000_000).^-3)\n1.2020569031595896\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln2","page":"Utilities","title":"PostNewtonian.MathConstants.ln2","text":"ln2\nlog2\n\nThe natural logarithm of 2.  This is OEIS sequence A002162.\n\njulia> PostNewtonian.ln2\nln2 = 0.6931471805599...\n\njulia> exp(PostNewtonian.ln2)\n2.0\n\njulia> exp(big(PostNewtonian.ln2))\n2.0\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln3","page":"Utilities","title":"PostNewtonian.MathConstants.ln3","text":"ln3\nlog3\n\nThe natural logarithm of 3.  This is OEIS sequence A002391.\n\njulia> PostNewtonian.ln3\nln3 = 1.0986122886681...\n\njulia> exp(PostNewtonian.ln3)\n3.0000000000000004\n\njulia> exp(big(PostNewtonian.ln3))\n3.0\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln5","page":"Utilities","title":"PostNewtonian.MathConstants.ln5","text":"ln5\nlog5\n\nThe natural logarithm of 5.  This is OEIS sequence A016628.\n\njulia> PostNewtonian.ln5\nln5 = 1.6094379124341...\n\njulia> exp(PostNewtonian.ln5)\n4.999999999999999\n\njulia> exp(big(PostNewtonian.ln5))\n5.0\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln³╱₂","page":"Utilities","title":"PostNewtonian.MathConstants.ln³╱₂","text":"ln³╱₂\nlog³╱₂\nlog3halves\n\nThe natural logarithm of 3//2.  This is OEIS sequence A016578.\n\njulia> PostNewtonian.ln³╱₂\nln³╱₂ = 0.4054651081081...\n\njulia> exp(PostNewtonian.ln³╱₂)\n1.5\n\njulia> exp(big(PostNewtonian.ln³╱₂))\n1.5\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#PostNewtonian.MathConstants.ln⁵╱₂","page":"Utilities","title":"PostNewtonian.MathConstants.ln⁵╱₂","text":"ln⁵╱₂\nlog⁵╱₂\nlog5halves\n\nThe natural logarithm of 5//2.  This is OEIS sequence A016579.\n\njulia> PostNewtonian.ln⁵╱₂\nln⁵╱₂ = 0.9162907318741...\n\njulia> exp(PostNewtonian.ln⁵╱₂)\n2.5\n\njulia> exp(big(PostNewtonian.ln⁵╱₂))\n2.5\n\n\n\n\n\n","category":"constant"},{"location":"internals/utilities/#Truncated-series","page":"Utilities","title":"Truncated series","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"We also have some utilities for dealing with series — or more precisely summations, since we only handle finitely many terms.  In particular, we need truncated multiplication (and some times division) of truncated series.  This multiplication is associative and there is a multiplicative identity element — though not always a multiplicative inverse — which means that this structure naturally forms a monoid.  (In fact, it also forms more general structures, like a commutative algebra; all we need is the monoidal structure.)","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Here, we are assuming that there is a fixed order at which the series are truncated, and that truncated multiplication preserves that order. That is, if A and B are summations in terms up to v^N for some integer N, we want their product and ratio (if it exists) to also be a summation in terms up to v^N.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Note that we are not referring to these summations as \"polynomials\" in v, because the coefficients will sometimes involve ln(v) — which is not technically permitted for polynomials.  In particular, the presence of logarithms is irrelevant to our meaning of the \"order\" of the truncated series.  This is standard practice in post-Newtonian theory.[1]","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"[1]: Different texts in post-Newtonian theory treat these logarithmic   terms with varying levels of rigor.  The preferred method is   Hadamard   regularization   (often referred to in the literature as the partie finie).  A   good summary is found in Section 6 of Blanchet's Living   Review.   Another potential approach could be taken following this   paper.  But for   our purposes, it will suffice to take the simplistic approach of   treating logarithmic terms as if they were any other constant.","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"The following functions implement this behavior:","category":"page"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"PostNewtonian.truncated_series_inverse\nPostNewtonian.truncated_series_product\nPostNewtonian.truncated_series_ratio\nPostNewtonian.lagrange_inversion\nPostNewtonian.x╱f_mod_xⁿ⁻¹\nPostNewtonian.hⁱ✖h_mod_xⁿ⁻¹","category":"page"},{"location":"internals/utilities/#PostNewtonian.truncated_series_inverse","page":"Utilities","title":"PostNewtonian.truncated_series_inverse","text":"truncated_series_inverse(a)\ntruncated_series_inverse!(b, a)\n\nGiven the coefficients a of a series, find the coefficients b of the multiplicative inverse of that series, up to the order of the original series.  That is, if\n\nA colonequals sum_i=0^n a_i-1 v^i\n\nthen we return the coefficients b of the series\n\nB colonequals sum_i=0^n b_i-1 v^i\n\nsuch that\n\nA B = 1 + mathcalO(v^n+1)\n\nSee lagrange_inversion for the compositional inverse (a.k.a. reversion), which returns the coefficients of f^-1 such that f^-1(f(v)) = v + mathcalO(v^n+1).\n\nNote that this function returns the coefficients of the inverse, rather than its value. This is relevant for use in truncated_series_product and truncated_series_ratio — the latter of which just combines the former with this function.\n\nFor example, suppose the input coefficients represent the series\n\nA colonequals sum_i=0^n a_i-1 v^i\n\n(Remember that Julia's indexing is 1-based, so we subtract 1 to get the index of the coefficient of v^i.)  Then we return the coefficients b of the series\n\nB colonequals sum_i=0^n b_i-1 v^i\n\nsuch that\n\nA B = 1 + mathcalO(v^n+1)\n\nnote: Note\nThis function requires that a[1] be nonzero.  If you have a series that starts at a higher term — say, v^n for n0 — you should factor out the v^n, and multiply the series resulting from this function by v^-n.\n\nExplanation\n\nThe inverse coefficients can be computed fairly easily by induction.  Start by defining\n\nb_0 = 1a_0\n\nNow, assuming that we've computed all coefficients up to and including b_i, we can compute b_i+1 from the condition that the term proportional to v^i+1 in the product of the series and its inverse must be zero.  This gives\n\nb_i+1 = -b_0sum_j=1^i a_j b_i-j\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.truncated_series_product","page":"Utilities","title":"PostNewtonian.truncated_series_product","text":"truncated_series_product(a, b, v)\n\nEvaluate the truncated product of the series a and b, which are expanded in powers of v.\n\nNote that this function returns the value of the summation, rather than its coefficients.\n\nHere we define the series in terms of the coefficients a and b as\n\nA colonequals sum_i=0^n a_i-1 v^i\nqquad\nB colonequals sum_i=0^n b_i-1 v^i\n\nand return the value of the product A B truncated at v^n.\n\nInternally, the sums are performed using evalpoly.\n\nSee also truncated_series_ratio.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.truncated_series_ratio","page":"Utilities","title":"PostNewtonian.truncated_series_ratio","text":"truncated_series_ratio(a, b, v)\n\nEvaluate the truncated ratio of the series a and b, which are expanded in powers of v.\n\nNote that this function returns the value of the summation, rather than its coefficients.\n\nHere we define the series in terms of the coefficients a and b as\n\nA colonequals sum_i=0^n a_i-1 v^i\nqquad\nB colonequals sum_i=0^n b_i-1 v^i\n\nand return the value of the ratio A  B truncated at v^n.\n\nThis function simply combines truncated_series_product and truncated_series_inverse.\n\n\n\n\n\ntruncated_series_ratio(a, b)\n\nEvaluate the truncated ratio of the series a and b, evaluated at expansion value 1. This is relevant when the expansion is not in the dynamic variable v, for example, but in powers of 1c as in post-Newtonian expansions.  (That is, when the v dependence is already include in the input coefficients.)\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.lagrange_inversion","page":"Utilities","title":"PostNewtonian.lagrange_inversion","text":"lagrange_inversion(a)\n\nCompute the compositional inverse (a.k.a. reversion) of the power series expansion\n\nf(x) = a1*x + a2*x^2 + ldots + an-1*x^n-1\n\nabout 0, where a is an NTuple.  Note, in particular, that there is no constant term.  The result is a similar NTuple b allowing us to write\n\nf^-1(y) = b1*y + b2*y^2 + ldots + bn-1*y^n-1\n\nsuch that f^-1(f(x)) = f(f^-1(y)) = x mod x^n.\n\nSee truncated_series_inverse for the multiplicative inverse.\n\nWhen the constant coefficient a_0 is nonzero, the result must be expanded about a different point, which is done by evaluating the output as f^-1(y-a_0).  Similarly, if the original expansion is about a point x_0  0, the result must be shifted by adding x_0 to the output.\n\nJohansson (2015) summarizes this basic form of the algorithm nicely:\n\nOur setting is the ring of truncated power series Rxlangle x^n rangle over a commutative coefficient ring R in which the integers 1n1 are cancellable (i.e., nonzero and not zero divisors).  [...]  If f(x) = xh(x) where h(0) is a unit, then the compositional inverse or reversion f^-1(x) satisfying f(f^-1(x)) = f^-1(f(x)) = x exists and its coefficients are given byx^k f^-1(x) = frac1k x^k-1 h(x)^k\n\nNote that Johansson also presents a pair of asymptotically faster algorithms for computing the compositional inverse.  Because of the low orders of the power series expansions we typically work with, it is not clear if the improved scaling of those algorithms would actually be beneficial in practice, so we stick with the basic algorithm here — though they would not be too difficult to implement if needed.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.x╱f_mod_xⁿ⁻¹","page":"Utilities","title":"PostNewtonian.x╱f_mod_xⁿ⁻¹","text":"x╱f_mod_xⁿ⁻¹(a)\n\nCompute the truncated power series expansion of xf mod x^n-1, where f is the power series expansion of a function f(x)\n\nf(x) = a1 x + a2 x^2 + a3 x^3 + ldots + an-1 x^n-1\n\nNote, in particular that there is no constant term.  The result is a power series expansion\n\nh(x) = h1 + h2 x + h3 x^2 + ldots + hn-1 x^n-2\n\nwhich notably does have a constant term.\n\nThis function is essentially a helper function for the lagrange_inversion function.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#PostNewtonian.hⁱ✖h_mod_xⁿ⁻¹","page":"Utilities","title":"PostNewtonian.hⁱ✖h_mod_xⁿ⁻¹","text":"hⁱ✖h_mod_xⁿ⁻¹(h, i)\n\nCompute the truncated power series expansion of h^i mod x^n-1, where h is the power series expansion of a function h(x)\n\nh(x) = h1 + h2 x + h3 x^2 + ldots + hn-1 x^n-2\n\nThe result is a power series expansion\n\nh^i(x) = h^i1 + h^i2 x + h^i3 x^2 + ldots + h^in-1 x^n-2\n\nThis function is essentially a helper function for the lagrange_inversion function.\n\n\n\n\n\n","category":"function"},{"location":"internals/utilities/#Miscellaneous","page":"Utilities","title":"Miscellaneous","text":"","category":"section"},{"location":"internals/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [PostNewtonian]\nPages   = [\"utilities/misc.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/utilities/#PostNewtonian.apply_to_first_add!-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.apply_to_first_add!","text":"apply_to_first_add!(expr, func)\n\nApply func to the first sub-expression found in a \"prewalk\"-traversal of expr that satisfies isadd.  If func acts in place, so does this function.  In either case, the expression should be returned.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.find_symbols_of_type-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.find_symbols_of_type","text":"find_symbols_of_type(mod, T)\n\nGiven a module mod (not just its name, but the actual imported module), find all objects inside that module that are instances of the given type T.  The returned quantity is a vector of Symbols.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.flatten_binary!-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.flatten_binary!","text":"flatten_binary!(expr, symbols)\n\nFlatten nested binary operations — that is, apply associativity repeatedly.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.isadd-Tuple{Any}","page":"Utilities","title":"PostNewtonian.isadd","text":"isadd(x)\n\nReturn true if the Expr x is a call to (+) or :+.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.iscall-Tuple{Any, Any}","page":"Utilities","title":"PostNewtonian.iscall","text":"iscall(x, symbols)\n\nReturn true if the Expr x is a call to any element of symbols.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.ismul-Tuple{Any}","page":"Utilities","title":"PostNewtonian.ismul","text":"ismul(x)\n\nReturn true if the Expr x is a call to (*) or :*.\n\n\n\n\n\n","category":"method"},{"location":"internals/utilities/#PostNewtonian.value-Tuple{Any}","page":"Utilities","title":"PostNewtonian.value","text":"value(x)\n\nReturn x or the value wrapped by the Dual number x\n\n\n\n\n\n","category":"method"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = PostNewtonian","category":"page"},{"location":"#PostNewtonian","page":"Introduction","title":"PostNewtonian","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package computes orbital dynamics of and waveforms from binary black-hole systems, in the post-Newtonian approximation. Currently, general precessing quasispherical systems are supported, but support for eccentric systems is still upcoming.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you intend to use this package via Python, see this page for installation instructions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is recommended to use this package with Julia version 1.9 or greater, because of that version's improved pre-compilation caching.  If you find it very slow the first time you use functions from this package in a new Julia session, that is most likely because Julia has to compile a lot of code.  Version 1.9 does a better job of caching that compiled code, which speeds up your first-time usage.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you haven't installed Julia yet, you probably want to use juliaup to do so.  You'll probably also want to use a Julia \"project environment\" specifically for using this package.  An easy way to do this is to create a directory, cd into that directory, and then run julia as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia --project=.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then, installation of this package involves the usual commands:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"PostNewtonian\")","category":"page"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An example with slightly more explanation is given under \"High-level interface\", and of course the rest of this documentation goes into far more detail.  Here we see a simple example to start things off.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Tip\nYou don't have to use cool Unicode names for your variables if you don't want to.  For example, chi1 works just as well as χ⃗₁.  Similarly, many functions in this package have Unicode names or take optional Unicode keyword arguments.  But every such name or argument will also have an ASCII equivalent; see the documentation of those functions for the appropriate substitutions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using PostNewtonian\n\n# Initial values of the masses, spins, and orbital angular frequency\nM₁ = 0.4\nM₂ = 0.6\nχ⃗₁ = [0.0, 0.5, 0.8]\nχ⃗₂ = [0.8, 0.0, 0.5]\nΩᵢ = 0.01\n\n# Integrate the orbital dynamics\ninspiral = orbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ)\n\n# Interpolate for nicer plotting\nt′ = inspiral.t[end]-6_000 : 0.5 : inspiral.t[end]\ninspiral = inspiral(t′)\n\n# Compute the waveform in the inertial frame\nh = inertial_waveform(inspiral)\nnothing  # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can plot the result like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Plots  # Requires also installing `Plots` in your project\nplotlyjs()  # hide\ndefault(size=(800,480), linewidth=2, leg=:top, legendfontsize=11)  # hide\ndefault(extra_plot_kwargs = KW(:include_mathjax => \"cdn\"))  # hide\n\nplot(inspiral.t, real.(h[1, :]), label=raw\"$\\Re\\left\\{h_{2,-2}\\right\\}$\")\nplot!(inspiral.t, imag.(h[1, :]), label=raw\"$\\Im\\left\\{h_{2,-2}\\right\\}$\")\nplot!(inspiral.t, abs.(h[1, :]), label=raw\"$\\left|h_{2,-2}\\right|$\", linewidth=3)\nplot!(inspiral.t, abs.(h[5, :]), label=raw\"$\\left|h_{2,2}\\right|$\")\nplot!(xlabel=raw\"$\\text{Time }(M)$\", ylabel=\"Mode weights\", ylim=(-0.45,0.45))\n\nsavefig(\"quickstart_waveform.html\"); nothing  # hide","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<iframe src=\"quickstart_waveform.html\" style=\"height:500px;width:100%;\"></iframe>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We see various features to be expected of a precessing system like this, including slow modulations of the modes on the precession timescale, as well as faster oscillations in the amplitudes and asymmetry between the m=pm 2 modes on the orbital timescale.","category":"page"},{"location":"internals/dynamics/#Dynamics","page":"Dynamics","title":"Dynamics","text":"","category":"section"},{"location":"internals/dynamics/#Integrating-orbital-evolution","page":"Dynamics","title":"Integrating orbital evolution","text":"","category":"section"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"orbital_evolution\nuniform_in_phase\nestimated_time_to_merger\nfISCO\nΩISCO","category":"page"},{"location":"internals/dynamics/#PostNewtonian.orbital_evolution","page":"Dynamics","title":"PostNewtonian.orbital_evolution","text":"orbital_evolution(pnsystem; kwargs...)\norbital_evolution(M₁, M₂, χ⃗₁, χ⃗₂, Ωᵢ; kwargs...)\n\nIntegrate the orbital dynamics of an inspiraling non-eccentric compact binary.\n\nRequired arguments\n\nThe first argument to this function may be a single PNSystem that encodes these required arguments (as well as Rᵢ, Λ₁, and Λ₂ among the keyword arguments), or the following may be given explicitly:\n\nM₁: Initial mass of object 1\nM₂: Initial mass of object 2\nχ⃗₁: Initial dimensionless spin of object 1, S⃗₁/M₁²\nχ⃗₂: Initial dimensionless spin of object 2, S⃗₂/M₂²\nΩᵢ: Initial orbital angular frequency\n\n(Note that the explicit inputs require Ωᵢ, whereas PNSystems require vᵢ as input.)\n\nThese parameters all describe the \"initial\" conditions.  See below for an explanation of the different meanings of \"initial\" and \"first\" in this context.  Note that the masses change in time as a result of tidal heating — though the changes are quite small throughout most of the inspiral.  The spins change direction due to precession, but also change in magnitude due to tidal heating.  Therefore, the values passed here are only precisely as given precisely at the moment of the initial data corresponding to the frequency Ωᵢ.\n\nKeyword arguments\n\nNote that several of these keywords are given as Unicode but can also be given as the ASCII string noted.  For example, Λ₁ may be input as Lambda1 equivalently; the default values are the same, regardless.\n\nΛ₁=0 or Lambda1: Tidal-coupling parameter of object 1.\nΛ₂=0 or Lambda2: Tidal-coupling parameter of object 2.\nΩ₁=Ωᵢ or Omega_1: First angular frequency in output data.  This may be less than Ωᵢ, in which case we integrate backwards to this point, and combine the backwards and forwards solutions into one seamless output.  (See next section.)\nΩₑ=Ω(v=1,M=M₁+M₂) or Omega_e: Final angular frequency at which to stop ODE integration.  Note that integration may stop before the system reaches this frequency, if we detect that PN has broken down irretrievably — for example, if one of the masses is no longer strictly positive, if a spin is super-extremal, or the PN velocity parameter v is decreasing, or is no longer in the range (0,1).  Warnings will usually only be issued if v < 0.35, but if quiet=true informational messages will be issued.\nRᵢ=Rotor(1) or R_i: Initial orientation of binary.\napproximant=\"TaylorT1\": Method of evaluating the right-hand side of the evolution equations.  Other possibilities are \"TaylorT4\" and \"TaylorT5\".  See the documentation of TaylorT1! for more details.\nPNOrder=typemax(Int): Order to which to retain powers of v^2 in PN expansions. The default is to include all available terms in each PN expression.\ncheck_up_down_instability=true: Warn if the \"up-down instability\" (see below) is likely to affect this system.\ntime_stepper=Vern9(): Choice of solver in OrdinaryDiffEq to integrate ODE.\nabstol=eps(T)^(11//16): Absolute tolerance of ODE solver, where T is the common type to which all the positional arguments are promoted.  This is the tolerance on local error estimates, not necessarily the global error.  Note that 11//16 is just chosen to suggest that we will have roughly 11 digits of accuracy (locally) for Float64 computations, and a similar accuracy for other float types relative to that type's epsilon.\nreltol=eps(T)^(11//16): Relative tolerance of ODE solver.  (As above.)\ntermination_criteria_forwards=nothing: Callbacks to use for forwards-in-time evolution.  See below for discussion of the default value.\ntermination_criteria_backwards=nothing: Callbacks to use for backwards-in-time evolution.  See below for discussion of the default value.\nforce_dtmin=true: If dt decreases below the integrator's own minimum, and this is false, the integrator will immediately raise an error, before the termination criteria have the chance to exit gracefully.  Note that a true value here is critical if the dtmin_terminator callback is to have any effect.\nquiet=true: If set to false, informational messages about successful terminations of the ODE integrations (which occur when the target v is reached in either direction) will be provided.  Warnings will still be issued when terminating for other reasons; if you wish to silence them too, you should do something like\nusing Logging\nwith_logger(SimpleLogger(Logging.Error)) do\n    <your code goes here>\nend\nsaves_per_orbit=0: If greater than 0, the output will be interpolated so that there are saves_per_orbit time steps in the output for each orbit.  Note that this conflicts with the saveat option noted below.\n\nAll remaining keyword arguments are passed to the solve function of DiffEqBase.  See that function's documentation for details, including useful keyword arguments.  The most likely important one is\n\nsaveat: Denotes specific times to save the solution at, during the solving phase — either a time step or a vector of specific times.\n\nIn particular, if you want the solution to be output at uniform time steps δt, you want to pass something like saveat=δt; you don't want the solve keyword dt, which is just the initial suggestion for adaptive systems.  It is not permitted to pass this option and the saves_per_orbit option.\n\nAlso note that callback can be used, and is combined with the callbacks generated by the termination_criteria_* arguments above.  That is, you can use the default ones and your own by passing arguments to callback.  See the documentation for more details, but note that if you want to make your own callbacks, you will need to add OrdinaryDiffEq to your project — or possibly even DifferentialEquations for some of the fancier built-in callbacks.\n\nODE system\n\nThe evolved variables, in order, are\n\nM₁: Mass of black hole 1\nM₂: Mass of black hole 2\nχ⃗₁ˣ: x component of dimensionless spin of black hole 1\nχ⃗₁ʸ: y component...\nχ⃗₁ᶻ: z component...\nχ⃗₂ˣ: x component of dimensionless spin of black hole 2\nχ⃗₂ʸ: y component...\nχ⃗₂ᶻ: z component...\nRʷ: Scalar component of frame rotor\nRˣ: x component...\nRʸ: y component...\nRᶻ: z component...\nv: PN \"velocity\" parameter related to the total mass M and orbital angular frequency Ω by v = (M Ω)^13\nΦ: Orbital phase given by integrating Ω\n\nThe masses and spin magnitudes evolve according to tidal_heating.  The spin directions evolve according to Ω⃗ᵪ₁ and Ω⃗ᵪ₂.  The frame precesses with angular velocity Ω⃗ₚ, while also rotating with angular frequency Ω about the Newtonian orbital angular velocity direction.  The frame rotor R is given by integrating the sum of these angular velocities as described in Boyle (2016).  And finally, the PN parameter v evolves according to something like\n\ndotv = - fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nwhere 𝓕 is the flux of gravitational-wave energy out of the system, dotM_1 and dotM_2 are due to tidal coupling as computed by tidal_heating, and 𝓔′ is the derivative of the binding energy with respect to v.  For \"TaylorT1\", the right-hand side of this equation is evaluated as given; for \"TaylorT4\", the right-hand side is first expanded as a Taylor series in v and then truncated at some desired order; for \"TaylorT5\", the inverse of the right-hand side is expanded as a Taylor series in v, truncated at some desired order, and then inverted to obtain an expression in terms of v.\n\nReturned solution\n\nThe returned quantity is an ODESolution object, which has various features for extracting and interpolating the data.  We'll call this object sol.\n\nnote: Note\nThe solution comes with data at the time points the ODE integrator happened to step to.  However, it also comes with dense output (unless you manually turn it off when calling orbital_evolution).  This means that you can interpolate the solution to any other set of time points you want simply by calling it as sol(t) for some vector of time points t.  The quantity returned by that will have all the features described below, much like the original solution.  Note that if you only want some of the data, you can provide the optional keyword argument idxs to specify which of the elements described below you want to interpolate.  For example, if you only want to interpolate the values of M₁ and M₂, you can use sol(t, idxs=[1,2]).\n\nThe field sol.t is the set of time points at which the solution is given.  To access the ith variable at time step j, use sol[i, j].[1] You can also use colons.  For example, sol[:, j] is a vector of all the data at time step j, and sol[i, :] is a vector of the ith variable at all times.\n\n[1]: Here, the ith variable just refers to which number it has in the list of evolved   variables in the ODE system, as described under \"ODE system\".\n\nFor convenience, you can also access the individual variables with their symbols.  For example, sol[:v] returns a vector of the PN velocity parameter at each time step.  Note the colon in :v, which is Julia's notation for a Symbol.\n\nInitial frequency vs. first frequency vs. end frequency\n\nNote the distinction between Ωᵢ (with subscript i) and Ω₁ (with subscript 1).  The first, Ωᵢ, represents the angular frequency of the initial condition from which the ODE integrator will begin; the second, Ω₁, represents the target angular frequency of the first element of the output data.  That is, the ODE integration will run forwards in time from Ωᵢ to the merger, and then — if Ωᵢ>Ω₁ — come back to Ωᵢ and run backwards in time to Ω₁.  The output data will stitch these two together to be one continuous (forwards-in-time) data series.\n\nFor example, if you are trying to match to a numerical relativity (NR) simulation, you can read the masses and spins off of the NR data when the system is orbiting at angular frequency Ωᵢ.  Integrating the post-Newtonian (PN) solution forwards in time from this point will allow you to compare the PN and NR waveforms.  However, you may want to know what the waveform was at earlier times than are present in the NR data.  For this, you also have to integrate backwards in time.  We parameterize the point to which you integrate backwards with Ω₁.  In either case, element 1 of the output solution will have frequency Ω₁ — though by default it is equal to Ωᵢ.\n\nSimilarly, the optional argument Ωₑ=1 is the frequency of the end element of the solution — that is Julia's notation for the last element.  Note that this is automatically reduced if necessary so that the corresponding PN parameter v is no greater than 1, which may be the case whenever the total mass is greater than 1.\n\nUp-down instability\n\nBe aware that the up-down instability (where the more massive black hole has spin aligned with the orbital angular velocity, and the less massive has spin anti-aligned) can cause systems with nearly zero precession at the initial time to evolve into a highly precessing system either at earlier or later times.  This is a real physical result, rather than a numerical issue.  If you want to simulate a truly non-precessing system, you should explicitly set the in-place components of spin to precisely 0.  By default, we check for this condition, and will issue a warning if it is likely to be encountered for systems with low initial precession.  The function used to compute the unstable region is up_down_instability.\n\nTime-stepper algorithms\n\nTsit5() is a good default choice for time stepper when using Float64 with medium-low tolerance.  If stiffness seems to be impacting the results, AutoTsit5(Rosenbrock23()) will automatically switch when stiffness occurs.  For tighter tolerances, especially when using Double64s, Vern9() or AutoVern9(Rodas5P()) are good choices.  For very loose tolerances, as when using Float32s, it might be better to use OwrenZen3().\n\nTermination criteria\n\nThe termination criteria are vital to efficiency of the integration and correctness of the solution.  The default values for forwards- and backwards-in-time evolution, respectively, are\n\nCallbackSet(\n    termination_forwards(v(Ω=Ωₑ, M=M₁+M₂)),\n    dtmin_terminator(T),\n    decreasing_v_terminator(),\n    nonfinite_terminator()\n)\n\nand\n\nCallbackSet(\n    termination_backwards(v(Ω=Ω₁, M=M₁+M₂)),\n    dtmin_terminator(T),\n    nonfinite_terminator()\n)\n\nwhere T is the common float type of the input arguments.  If any additional termination criteria are needed, they could be added as additional elements of the CallbackSets.  See the callback documentation for details.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.uniform_in_phase","page":"Dynamics","title":"PostNewtonian.uniform_in_phase","text":"uniform_in_phase(solution, saves_per_orbit)\n\nInterpolate solution to uniform steps in phase.\n\nBy default, the solution returned by orbital_evolution may be sampled very sparsely — too sparsely to satisfy the Nyquist limit of the waveform.  If the waveform extends to ell_mathrmmax, there will be modes varying slightly more rapidly than expleft(pm i ell_mathrmmax Phi right), where Phi is the orbital phase.  If the frequency were constant, this would require at least 2ell_mathrmmax samples per orbit.  To incorporate a safety factor, 4ell_mathrmmax seems to work fairly reliably.\n\nSee also the saves_per_orbit and saveat arguments to orbital_evolution, as well as interpolation-in-time capabilities of the result of that function.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.estimated_time_to_merger","page":"Dynamics","title":"PostNewtonian.estimated_time_to_merger","text":"estimated_time_to_merger(M, ν, v)\nestimated_time_to_merger(pnsystem)\n\nCompute the lowest-order PN approximation for the time to merger, starting from PN velocity parameter v.\n\nThis is used internally as a convenient way to estimate how long the inspiral integration should run for; we don't want it to integrate forever if PN has broken down.  However, it can be a very poor approximation, especially close to merger, and doubly so if the spins or eccentricity are significant.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.fISCO","page":"Dynamics","title":"PostNewtonian.fISCO","text":"fISCO(q, M)\nfISCO(pnsystem)\n\nCompute the \"BKL\" approximation for the ISCO (Innermost Stable Circular Orbit) frequency.\n\nThis is taken from Eq. (5) of Hanna et al. (2008).  Note that this does not account for the spins of the objects in the binary, so that this returns a very crude estimate of a frequency of interest.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.ΩISCO","page":"Dynamics","title":"PostNewtonian.ΩISCO","text":"ΩISCO(q,M)\nΩISCO(pnsystem)\n\n2π times fISCO.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#Detecting-the-up-down-instability","page":"Dynamics","title":"Detecting the up-down instability","text":"","category":"section"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Modules = [PostNewtonian]\nPages   = [\"dynamics/up_down_instability.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/dynamics/#PostNewtonian.up_down_instability-Union{Tuple{Any}, Tuple{PNExpansionReducer}} where PNExpansionReducer","page":"Dynamics","title":"PostNewtonian.up_down_instability","text":"up_down_instability(pnsystem)\n\nCompute the range of frequencies over which the system is unstable to increasing precession.\n\nThe returned value is a pair of dimensionless frequencies giving the lower and upper frequencies between which we can expect instability.  If there is no instability expected, the returned pair is just (1M 1M) — where M is the total mass of the system, and 1M is the upper limit of physically reasonable frequencies.\n\nFor compact binaries in which the spins are either aligned or anti-aligned with the orbital angular velocity, we do not expect any precession effects — simply by symmetry.  However, if the spin of the higher-mass object is aligned with the orbital angular velocity and the spin of the lower-mass object is anti-aligned, the binary is unstable to precession — meaning that any minuscule misalignment can grow rapidly into significant precession.  This was first reported by Gerosa et al. (2015), and the range over which the system is unstable is given by Eq. (2) of that reference.  We use the lowest-order approximation to convert binary separation to frequency.  The result is also \"clamped\" between 0 and 1M, because sometimes the PN approximations involved break down and return values outside of those physically plausible limits.\n\nNote that Gerosa et al. use the convention that q = M_2M_1 — which is opposite to the convention used in this package; which we account for internally in this function. They also assume that M_1 geq M_2, which we deal with by automatically swapping the relevant quantities.  Neither of these requires any adjustment by users of this function.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.up_down_instability_warn-Union{Tuple{PNExpansionReducer}, Tuple{Any, Any, Any}, NTuple{4, Any}} where PNExpansionReducer","page":"Dynamics","title":"PostNewtonian.up_down_instability_warn","text":"function up_down_instability_warn(pnsystem, v₁, vₑ, vₗᵢₘᵢₜ=1//2)\n\nIf this system is likely to encounter the up-down instability, log a warning with details.\n\nThis function issues the warning if the system is reasonably non-precessing (chi_perp leq 10^-2) in its current configuration (as given by pnsystem), and the range of frequencies (v₁, vₑ) over which it will be integrated is likely to encounter the up-down instability — except that frequencies above vₗᵢₘᵢₜ will be ignored, as PN is likely to have broken down anyway.\n\nSee up_down_instability for details of the calculation of the unstable region.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#Approximants","page":"Dynamics","title":"Approximants","text":"","category":"section"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"These compute the right-hand sides for the ODE integration of PN orbital evolutions.  They only differ in how they compute the time dependence of the fundamental PN variable v.  Fundamentally, we have","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"fracdvdt = -fracmathcalF + dotM_1 + dotM_2 mathcalE","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"as the essential expression.  The various approximants differ simply in how they expand this expression.  Details are explained in the following docstrings, but in principle the differences should be at the next-highest PN order beyond the orders to which the factors are calculated.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Note that TaylorT2 and TaylorT3 can also be found in the literature, and are used to derive analytical expressions for the orbital evolution.[2]  Unfortunately, this can only be accomplished for non-precessing systems, so we don't bother to implement them in this package.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"[2]: The second T in the TaylorTn names refers to the fact that these calculations provide the dynamics in the time domain.  In a manner following TaylorT2, it is also possible to use the stationary-phase approximation to derive the dynamics in the frequency domain, thus resulting in the TaylorF2 approximant.  Finally, it should be noted that approximants named TaylorK1, TaylorK2, and TaylorEt have also been introduced.  None of these other approximants have been implemented in this package.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Modules = [PostNewtonian]\nPages   = [\"dynamics/right_hand_sides.jl\"]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"internals/dynamics/#PostNewtonian.TaylorT1!-Tuple{Any, Any}","page":"Dynamics","title":"PostNewtonian.TaylorT1!","text":"TaylorT1!(u̇, pnsystem)\n\nCompute the right-hand side for the orbital evolution of a non-eccentric binary in the \"TaylorT1\" approximant.\n\nThis approximant is the simplest, in which the time derivative dotv is given directly by\n\ndotv = -fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nand the PN expression for each term on the right-hand side is evaluated numerically before insertion directly in this expression.  Compare TaylorT4! and TaylorT5!.\n\nHere, u̇ is the time-derivative of the state vector, which is stored in the PNSystem object p.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.TaylorT1RHS!","page":"Dynamics","title":"PostNewtonian.TaylorT1RHS!","text":"TaylorT1RHS!\n\nA SciMLBase.ODEFunction wrapper for TaylorT1!, suitable for passing into OrdinaryDiffEq.solve.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.TaylorT4!-Tuple{Any, Any}","page":"Dynamics","title":"PostNewtonian.TaylorT4!","text":"TaylorT4!(u̇, pnsystem)\n\nCompute the right-hand side for the orbital evolution of a non-eccentric binary in the \"TaylorT4\" approximant.\n\nIn this approximant, we compute dotv by expanding the right-hand side of\n\ndotv = -fracmathcalF + dotM_1 + dotM_2 mathcalE\n\nas a series in v, truncating again at the specified PN order, and only then is the result evaluated.  Compare TaylorT1! and TaylorT5!.\n\nHere, u is the ODE state vector, which should just refer to the state vector stored in the PNSystem object p.  The parameter t represents the time, and will surely always be unused in this package, but is part of the DifferentialEquations API.\n\nnote: Truncation order vs. `PNOrder` vs. PN order\nWhen expanding the fraction given above as a series in v, the truncation order is not necessarily the value of PNOrder given in the input p.  Instead, it is the highest order of the series that is present in the numerator or denominator — which is what we would normally call the PN order of those expansions.  The PNOrder parameter is the highest order of the series that is allowed to be present in those expansions, so that if PNOrder is typemax(Int), the series will be expanded to the highest order given in any of the PN expansions, but the expansion of the ratio will not go to infinite order.  This is the reason that TaylorT4 and TaylorT5 do not approach TaylorT1 as PNOrder approaches typemax(Int).\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.TaylorT4RHS!","page":"Dynamics","title":"PostNewtonian.TaylorT4RHS!","text":"TaylorT4RHS!\n\nA SciMLBase.ODEFunction wrapper for TaylorT4!, suitable for passing into OrdinaryDiffEq.solve.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/#PostNewtonian.TaylorT5!-Tuple{Any, Any}","page":"Dynamics","title":"PostNewtonian.TaylorT5!","text":"TaylorT5!(u̇, pnsystem)\n\nCompute the right-hand side for the orbital evolution of a non-eccentric binary in the \"TaylorT5\" approximant.\n\nIn this approximant, we compute dotv by expanding the right-hand side of the multiplicative inverse of the usual expression\n\nfrac1dotv=fracdtdv = -fracmathcalE mathcalF + dotM_1 + dotM_2\n\nas a series in v, truncating again at the specified PN order, evaluating the result, and then taking the multiplicative inverse again to find dotv.  This approximant was introduced by Ajith (2011) [see Eq. (3.5)].  Compare TaylorT1! and TaylorT4!.\n\nHere, u is the ODE state vector, which should just refer to the state vector stored in the PNSystem object p.  The parameter t represents the time, and will surely always be unused in this package, but is part of the DifferentialEquations API.\n\n\n\n\n\n","category":"method"},{"location":"internals/dynamics/#PostNewtonian.TaylorT5RHS!","page":"Dynamics","title":"PostNewtonian.TaylorT5RHS!","text":"TaylorT5RHS!\n\nA SciMLBase.ODEFunction wrapper for TaylorT5!, suitable for passing into OrdinaryDiffEq.solve.\n\n\n\n\n\n","category":"function"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"note: Truncation order vs. `PNOrder` vs. PN order\nWhen expanding the fraction given above as a series in v, the truncation order is not necessarily the value of PNOrder given in the input p.  Instead, it is the highest order of the series that is present in the numerator or denominator — which is what we would normally call the PN order of those expansions.  The PNOrder parameter is the highest order of the series that is allowed to be present in those expansions, so that if PNOrder is effectively infinite, the series will be expanded to the highest order given in any of the PN expansions, but the expansion of the ratio will not go to infinite order.  This is the reason that TaylorT4 and TaylorT5 do not approach TaylorT1 as PNOrder approaches typemax(Int).  This design decision was made to ensure feasibility of the calculations.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"Note that, internally, the TaylorT* functions call causes_domain_error!.  This is a fairly simplistic detection of when evolved parameters will lead to bad values.  It may be desirable to extend this detection to be more sophisticated.","category":"page"},{"location":"internals/dynamics/","page":"Dynamics","title":"Dynamics","text":"PostNewtonian.causes_domain_error!","category":"page"},{"location":"internals/dynamics/#PostNewtonian.causes_domain_error!","page":"Dynamics","title":"PostNewtonian.causes_domain_error!","text":"causes_domain_error!(u̇, p)\n\nEnsure that these parameters correspond to a physically valid set of PN parameters.\n\nIf the parameters are not valid, this function should modify u̇ to indicate that the current step is invalid.  This is done by filling u̇ with NaNs, which will be detected by the ODE solver and cause it to try a different (smaller) step size.\n\nCurrently, the only check that is done is to test that these parameters result in a PN parameter v>0.  In the future, this function may be expanded to include other checks.\n\n\n\n\n\n","category":"function"}]
}
