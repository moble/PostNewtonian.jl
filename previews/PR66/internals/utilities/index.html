<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities ¬∑ PostNewtonian.jl</title><meta name="title" content="Utilities ¬∑ PostNewtonian.jl"/><meta property="og:title" content="Utilities ¬∑ PostNewtonian.jl"/><meta property="twitter:title" content="Utilities ¬∑ PostNewtonian.jl"/><meta name="description" content="Documentation for PostNewtonian.jl."/><meta property="og:description" content="Documentation for PostNewtonian.jl."/><meta property="twitter:description" content="Documentation for PostNewtonian.jl."/><meta property="og:url" content="https://moble.github.io/PostNewtonian.jl/stable/internals/utilities/"/><meta property="twitter:url" content="https://moble.github.io/PostNewtonian.jl/stable/internals/utilities/"/><link rel="canonical" href="https://moble.github.io/PostNewtonian.jl/stable/internals/utilities/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PostNewtonian.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Interface</span><ul><li><a class="tocitem" href="../../interface/high-level/">High-level interface</a></li><li><a class="tocitem" href="../../interface/units/">Units</a></li><li><a class="tocitem" href="../../interface/differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../../interface/assorted_binaries/">Assorted binaries</a></li><li><a class="tocitem" href="../../interface/python/">Python</a></li><li><a class="tocitem" href="../../interface/gwframes/">GWFrames</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../code_structure/">Code structure</a></li><li><a class="tocitem" href="../pn_systems/">PN systems</a></li><li><a class="tocitem" href="../fundamental_variables/">Fundamental variables</a></li><li><a class="tocitem" href="../derived_variables/">Derived variables</a></li><li><a class="tocitem" href="../pn_expressions/">PN expressions</a></li><li><a class="tocitem" href="../dynamics/">Dynamics</a></li><li><a class="tocitem" href="../waveforms/">Waveforms</a></li><li class="is-active"><a class="tocitem" href>Utilities</a><ul class="internal"><li><a class="tocitem" href="#PN-terms-and-PN-expansions"><span>PN terms and PN expansions</span></a></li><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Termination-criteria"><span>Termination criteria</span></a></li><li><a class="tocitem" href="#Manipulating-ODE-solutions"><span>Manipulating ODE solutions</span></a></li><li><a class="tocitem" href="#Truncated-series"><span>Truncated series</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../adding_terms/">Adding terms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/moble/PostNewtonian.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/moble/PostNewtonian.jl/blob/main/docs/src/internals/utilities.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><h2 id="PN-terms-and-PN-expansions"><a class="docs-heading-anchor" href="#PN-terms-and-PN-expansions">PN terms and PN expansions</a><a id="PN-terms-and-PN-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#PN-terms-and-PN-expansions" title="Permalink"></a></h2><p>The basic building blocks of post-Newtonian theory are the terms and expansions.  These are used to build up the various expressions that describe the dynamics of the system.  The terms are the individual parts of the expansions, while the expansions are the full expressions that are expanded in powers of <span>$1/c$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.PNTerm" href="#PostNewtonian.PNTerm"><code>PostNewtonian.PNTerm</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PNTerm{T,PNOrder,c‚Åª¬πExponent}</code></pre><p>This object represents a single term in a PNExpansion.  It has a single field: <code>coeff</code>, which is the coefficient of the term.  The type parameter <code>T</code> is the type of the coefficient.  The type parameter <code>PNOrder</code> is a half-integer (just as in <a href="../pn_systems/#PostNewtonian.PNSystem"><code>PNSystem</code></a>s) representing the PN order of the expansion.  And the type parameter <code>c‚Åª¬πExponent</code> is an integer representing the exponent of the PN expansion parameter <span>$1/c$</span>.</p><p><code>PNTerm</code>s can be multiplied and divided by scalars and exponentiated by integers, to produce another <code>PNTerm</code>.  They can also be added to other <code>PNTerm</code>s to produce a <code>PNExpansion</code>.</p><p>A simple way to define a <code>PNTerm</code> or a <code>PNExpansion</code> is to define the PN expansion parameter</p><pre><code class="language-julia hljs">c = PNExpansionParameter(pnsystem)</code></pre><p>and use that naturally in formulas, as in</p><pre><code class="language-julia hljs">e = 1 + (v/c)^2 * (-ŒΩ/12 - 3//4) + (v/c)^4 * (-ŒΩ^2/24 + 19ŒΩ/8 - 27//8)</code></pre><p>Any exponent higher than the desired <code>PNOrder</code> will be automatically set to zero.</p><p>Useful facts:</p><ul><li><code>v</code> has order <code>1/c</code></li><li><code>x</code> has order <code>1/c^2</code></li><li><code>Œ≥</code> has order <code>1/c^2</code></li><li><code>1/r</code> has order <code>1/c^2</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/pn_expansion.jl#L168-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.PNExpansionParameter" href="#PostNewtonian.PNExpansionParameter"><code>PostNewtonian.PNExpansionParameter</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PNExpansionParameter(pnsystem)</code></pre><p>Create a <a href="#PostNewtonian.PNTerm"><code>PNTerm</code></a> object representing the post-Newtonian expansion parameter <span>$c$</span>. This can be used to automatically create more complicated <code>PNTerm</code>s, which combine to form a <a href="#PostNewtonian.PNExpansion"><code>PNExpansion</code></a>.  This is a simple but effective way to write PN formulas while automatically tracking the PN order of each term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/pn_expansion.jl#L414-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.PNExpansion" href="#PostNewtonian.PNExpansion"><code>PostNewtonian.PNExpansion</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PNExpansion{N,T,NMax}</code></pre><p>This object can be multiplied by a scalar or another <code>PNExpansion</code> object, and contains a tuple of coefficients.  The coefficients are stored in the order of the expansion, with the zeroth-order coefficient first.  Multiplication by a scalar just multiplies each of the elements.  Multiplication by another <code>PNExpansion</code> object is done by convolving the two tuples of coefficients.</p><p>Blanchet (2014) defines the post-Newtonian expansion parameter as follows:</p><blockquote><p>This parameter represents essentially a slow motion estimate <span>$œµ ‚àº ùë£/ùëê$</span>, where <span>$ùë£$</span> denotes a typical internal velocity.  By a slight abuse of notation, following Chandrasekhar et al. [...], we shall henceforth write formally <span>$œµ ‚â° 1/ùëê$</span>, even though <span>$œµ$</span> is dimensionless whereas <span>$ùëê$</span> has the dimension of a velocity. Thus, <span>$1/ùëê ‚â™ 1$</span> in the case of post-Newtonian sources. The small post-Newtonian remainders will be denoted <span>$ùí™(1/ùëê^ùëõ)$</span>. Furthermore, [...] we shall refer to a small post-Newtonian term with formal order <span>$ùí™(1/ùëê^ùëõ)$</span> relative to the Newtonian acceleration in the equations of motion, as <span>$\frac{ùëõ}{2}\text{PN}$</span>.</p></blockquote><p>Therefore, we consider the coefficients of the <code>PNExpansion</code> to be a polynomial in <span>$1/ùëê$</span>. Here, the type parameter <code>N</code> corresponds to the number of elements actually present in the tuple of coefficients, and <code>T</code> is the type of the coefficients.  The <code>NMax</code> parameter is the maximum number of elements, related to the usual PN order by</p><p class="math-container">\[\text{pn_order} = \frac{\texttt{NMax}-1} {2}.\]</p><p>The <code>N</code> parameter is not related to the PN order; it is just used by Julia to know how many elements are currently in the coefficients, but is required to be 1 ‚â§ N ‚â§ NMax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/pn_expansion.jl#L11-L41">source</a></section></article><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><p>Some of the most useful features of this package are the macros allowing us to write PN expressions in fairly natural form, without worrying about calculating all the variables needed for each expression, or manually accounting for the various PN orders to which we may need to truncate PN expansions.  To achieve this, we rely primarily on two macros.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.@pn_expansion-Tuple{Any, Any}" href="#PostNewtonian.@pn_expansion-Tuple{Any, Any}"><code>PostNewtonian.@pn_expansion</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pn_expansion [pnsystem] expansion</code></pre><p>Gather terms in <code>expansion</code> by the powers of <span>$1/c$</span> involved, zeroing out any terms with powers of <span>$1/c$</span> higher than the <code>pnsystem</code>&#39;s <code>PNOrder</code> parameter, and combine the terms using the <code>PNExpansionReducer</code> specified in argument of the function that includes this macro call.</p><p>This expansion is achieved by setting ‚Äî inside a <code>let</code> block created by this macro ‚Äî</p><p>Note that the <code>pnsystem</code> argument can be inserted automatically by <a href="#PostNewtonian.@pn_expression-Tuple{Any}"><code>@pn_expression</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/macros.jl#L152-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.@pn_expression-Tuple{Any}" href="#PostNewtonian.@pn_expression-Tuple{Any}"><code>PostNewtonian.@pn_expression</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pn_expression [arg_index=1] func</code></pre><p>This macro takes the function <code>func</code>, looks for various symbols inside that function, and if present defines them appropriately inside that function.</p><p>The first argument to this macro is <code>arg_index</code>, which just tells us which argument to the function <code>func</code> is a <code>PNSystem</code>.  For example, the variables defined in <a href="../fundamental_variables/#Fundamental-variables"><code>PostNewtonian.FundamentalVariables</code></a> all take a single argument of <code>pnsystem</code>, which is used to compute the values for those variables; this macro just needs to know where to find <code>pnsystem</code>.</p><p>Once it has this information, there are five types of transformations it will make:</p><ol><li>Adds a keyword argument <code>pn_expansion_reducer::Val{PNExpansionReducer}=Val(sum)</code> to the function signature.  This is used to determine how to reduce the PN expansion terms. The default is <code>Val(sum)</code>, which will just return a single number,  but <code>Val(identity)</code> can be used to return the expansion.  This should be used inside the function as <code>PNExpansionReducer</code>, and will be automatically used inside any <code>@pn_expansion</code>.</li><li>For every <a href="../fundamental_variables/#Fundamental-variables">fundamental</a> or <a href="../derived_variables/#Derived-variables">derived</a> variable, the name of that variable used in the body of <code>func</code> will be replaced by its value when called with <code>pnsystem</code>.  For example, you can simply use the symbols <code>M‚ÇÅ</code> or <code>Œº</code> in your code, rather than calling them as <a href="../fundamental_variables/#PostNewtonian.FundamentalVariables.M‚ÇÅ"><code>M‚ÇÅ(pnsystem)</code></a> or <a href="../derived_variables/#PostNewtonian.DerivedVariables.Œº"><code>Œº(pnsystem)</code></a> every time they appear.</li><li>Every <code>Irrational</code> defined in <code>Base.MathConstants</code> or <code>PostNewtonian.MathConstants</code> will be transformed to the <code>eltype</code> of <code>pnsystem</code>.  This lets you naturally use such constants in expressions like <code>2œÄ/3</code> without automatically converting to <code>Float64</code>.</li><li>Each of a short list of functions given by <code>unary_funcs</code> in <code>utilities/macros.jl</code> will first convert their arguments to the <code>eltype</code> of <code>pnsystem</code>.  In particular, you can use expressions like <code>‚àö10</code> or <code>ln(2)</code> without the result being converted to a <code>Float64</code>.</li><li>Insert the <code>pnsystem</code> argument as the first argument to each occurrence of <code>@pn_expansion</code> that needs it.</li></ol><p>To be more explicit, the first three are achieved by defining the relevant quantities in a <code>let</code> block placed around the body of <code>func</code>, so that the values may be used efficiently without recomputation.</p><p>If you need to use one of the fundamental- or derived-variable functions as arguments of values other than those encapsulated in <code>pnsystem</code>, you&#39;ll need to address them explicitly with the module name ‚Äî as in <code>PostNewtonian.v(;Œ©, M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/macros.jl#L103-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.type_converter-Tuple{Any, Any}" href="#PostNewtonian.type_converter-Tuple{Any, Any}"><code>PostNewtonian.type_converter</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">type_converter(pnsystem, x)</code></pre><p>Convert <code>x</code> to a type appropriate for the float type of <code>pnsystem</code>.</p><p>This is sort of an expansion of the <code>convert</code> function, but with nicer syntax for types from this package, including the ability to do really weird things for <code>SymbolicPNSystem</code>.  It&#39;s needed to ensure that the types of variables and constants are correct when we use them in expressions, rather than just assuming everything is a <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/macros.jl#L1-L10">source</a></section></article><h2 id="Termination-criteria"><a class="docs-heading-anchor" href="#Termination-criteria">Termination criteria</a><a id="Termination-criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Termination-criteria" title="Permalink"></a></h2><p>Hopefully, it should not be necessary to directly use these termination criteria.  They are used by default in the <a href="../dynamics/#PostNewtonian.orbital_evolution"><code>orbital_evolution</code></a> function. But certain particularly extreme physical parameters may lead ODEs that are difficult to integrate ‚Äî especially if new PN systems or terms are introduced. These, or similar functions may be helpful examples of <a href="https://docs.sciml.ai/DiffEqDocs/stable/features/callback_functions/">&quot;callbacks&quot;</a> that can be passed to the ODE integrator.</p><p>Note that several of these will issue warnings if the evolution has to be terminated for particularly bad or suspicious reasons, even if the <code>quiet</code> flag is set to <code>true</code>.  See the documentation of the <code>quiet</code> argument to the <a href="../dynamics/#PostNewtonian.orbital_evolution"><code>orbital_evolution</code></a> function for an example of how to use <code>Logging</code> to quiet even the warnings.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.decreasing_v_terminator" href="#PostNewtonian.decreasing_v_terminator"><code>PostNewtonian.decreasing_v_terminator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decreasing_v_terminator([quiet])</code></pre><p>Construct termination criterion to stop integration when <code>v</code> is decreasing.</p><p>Note that some systems may truly have decreasing <code>v</code> as physical solutions ‚Äî including eccentric systems and possibly precessing systems.  You may prefer to implement another solution, like detecting when <code>v</code> decreases below some threshold, or detecting when <code>v</code> is decreasing too quickly.  See this function&#39;s source code for a simple</p><p>If this terminator is triggered while <code>v</code> is less than 0.35, a warning will always be issued; otherwise an <code>info</code> message will be issued only if the <code>quiet</code> flag is set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/termination_criteria.jl#L131-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.dtmin_terminator" href="#PostNewtonian.dtmin_terminator"><code>PostNewtonian.dtmin_terminator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dtmin_terminator(T, [quiet])</code></pre><p>Construct termination criterion to terminate when <code>dt</code> drops below <code>‚àöeps(T)</code>.</p><p>Pass <code>force_dtmin=true</code> to <code>solve</code> when using this callback.  Otherwise, the time-step size may decrease too much <em>within</em> a single time step, so that the integrator itself will quit before reaching this callback, leading to a less graceful exit.</p><p>If this terminator is triggered while <code>v</code> is less than 0.35, a warning will always be issued; otherwise an <code>info</code> message will be issued only if the <code>quiet</code> flag is set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/termination_criteria.jl#L94-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.nonfinite_terminator-Tuple{}" href="#PostNewtonian.nonfinite_terminator-Tuple{}"><code>PostNewtonian.nonfinite_terminator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonfinite_terminator()</code></pre><p>Construct termination criterion to stop integration when any NaN or Inf is found in the data after an integration step.</p><p>If this terminator is triggered, a warning will always be issued.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/termination_criteria.jl#L169-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.termination_backwards" href="#PostNewtonian.termination_backwards"><code>PostNewtonian.termination_backwards</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">termination_backwards(v‚ÇÅ, [quiet])</code></pre><p>Construct termination criteria of solving PN evolution backwards in time</p><p>These criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at <code>v‚ÇÅ</code>.</p><p>The optional <code>quiet</code> argument will silence informational messages about reaching the target value of <code>v‚ÇÅ</code> if set to <code>true</code>, but warnings will still be issued when terminating for other reasons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/termination_criteria.jl#L49-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.termination_forwards" href="#PostNewtonian.termination_forwards"><code>PostNewtonian.termination_forwards</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">termination_forwards(v‚Çë, [quiet])</code></pre><p>Construct termination criteria of solving PN evolution forwards in time</p><p>These criteria include checking that the masses are positive and the dimensionless spins are less than 1, as well as ensuring that the evolution will terminate at <code>v‚Çë</code>.</p><p>The optional <code>quiet</code> argument will silence informational messages about reaching the target value of <code>v‚Çë</code> if set to <code>true</code>, but warnings will still be issued when terminating for other reasons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/termination_criteria.jl#L1-L12">source</a></section></article><h2 id="Manipulating-ODE-solutions"><a class="docs-heading-anchor" href="#Manipulating-ODE-solutions">Manipulating ODE solutions</a><a id="Manipulating-ODE-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-ODE-solutions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.combine_solutions-Tuple{Any, Any}" href="#PostNewtonian.combine_solutions-Tuple{Any, Any}"><code>PostNewtonian.combine_solutions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine_solutions(sol‚Çã, sol‚Çä)</code></pre><p>Combine ODESolutions</p><p>This function is internal to this package.  It is not entirely general, but allows us to combine the backwards- and forwards-in-time solutions of the PN orbital-evolution ODE equations into a single <code>ODESolution</code> object that should behave just as if it were the result of <code>solve</code>.  In particular, indexing, interpolation, and iterations should behave exactly as <a href="https://diffeq.sciml.ai/stable/basics/solution/">described in the <code>DifferentialEquations</code> docs</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/combine_solutions.jl#L66-L78">source</a></section></article><h3 id="Irrational-constants"><a class="docs-heading-anchor" href="#Irrational-constants">Irrational constants</a><a id="Irrational-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Irrational-constants" title="Permalink"></a></h3><p>These quantities are constants that appear in PN expressions, so they are not exported, but can be used by importing them explicitly or by using the fully qualified names.  They are defined here as <code>Irrational</code>s.  This means that Julia <em>can</em> convert them to float types as necessary.  Unfortunately, by default Julia converts to <code>Float64</code>.  For example, <code>BigFloat(2Œ∂3)</code> will be a <code>BigFloat</code>, but will only have the precision of a <code>Float64</code>, because <code>2Œ∂3</code> is converted first. To get full precision, you&#39;ll need to do things like <code>2BigFloat(Œ∂3)</code>.</p><p>One approach to avoiding this is to explicitly redefine these constants as floats of the desired precision, using <code>let</code> to essentially overwrite the name:</p><pre><code class="language-julia hljs">function foo(x)
    let Œ∂3=oftype(x, Œ∂3)
        2Œ∂3 + x
    end
end</code></pre><p>Inside the <code>let</code> block, <code>Œ∂3</code> is no longer an <code>Irrational</code>; it has been converted to whatever number type <code>x</code> is.  Thus, when multiplying by 2, it is not converted to a <code>Float64</code>; its precision matches that of <code>x</code>.</p><p>This can be quite awkward, so the macro <a href="#PostNewtonian.@pn_expression-Tuple{Any}"><code>PostNewtonian.@pn_expression</code></a> is provided to (among other things) automatically search for all <code>Irrational</code>s and replace them with the appropriate float values.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.Œ≥‚Çë" href="#PostNewtonian.MathConstants.Œ≥‚Çë"><code>PostNewtonian.MathConstants.Œ≥‚Çë</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Œ≥‚Çë</code></pre><p><a href="https://en.wikipedia.org/wiki/Euler%27s_constant">Euler&#39;s constant</a> (also known as the Euler‚ÄìMascheroni constant) is defined as the limit as <span>$n \to \infty$</span> of the difference between the <span>$n$</span>th partial sum of the harmonic series and <span>$\log(n)$</span>.  This is OEIS sequence <a href="https://oeis.org/A001620">A001620</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.Œ≥‚Çë
Œ≥‚Çë = 0.5772156649015...

julia&gt; n=10_000_000; sum(1 ./ (1:n))-log(n)
0.5772157149015307</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L34-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.Œ∂3" href="#PostNewtonian.MathConstants.Œ∂3"><code>PostNewtonian.MathConstants.Œ∂3</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Œ∂3
apery</code></pre><p><a href="https://en.wikipedia.org/wiki/Ap%C3%A9ry%27s_constant">Ap√©ry&#39;s constant</a> is defined as <span>$Œ∂(3)$</span>, where <span>$Œ∂$</span> is the Riemann zeta function.  This is OEIS sequence <a href="https://oeis.org/A002117">A002117</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.apery
Œ∂3 = 1.2020569031595...

julia&gt; PostNewtonian.Œ∂3
Œ∂3 = 1.2020569031595...

julia&gt; sum((1:10_000_000).^-3)
1.2020569031595896</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.ln2" href="#PostNewtonian.MathConstants.ln2"><code>PostNewtonian.MathConstants.ln2</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ln2
log2</code></pre><p>The natural logarithm of 2.  This is OEIS sequence <a href="https://oeis.org/A002162">A002162</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.ln2
ln2 = 0.6931471805599...

julia&gt; exp(PostNewtonian.ln2)
2.0

julia&gt; exp(big(PostNewtonian.ln2))
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L74-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.ln3" href="#PostNewtonian.MathConstants.ln3"><code>PostNewtonian.MathConstants.ln3</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ln3
log3</code></pre><p>The natural logarithm of 3.  This is OEIS sequence <a href="https://oeis.org/A002391">A002391</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.ln3
ln3 = 1.0986122886681...

julia&gt; exp(PostNewtonian.ln3)
3.0000000000000004

julia&gt; exp(big(PostNewtonian.ln3))
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.ln5" href="#PostNewtonian.MathConstants.ln5"><code>PostNewtonian.MathConstants.ln5</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ln5
log5</code></pre><p>The natural logarithm of 5.  This is OEIS sequence <a href="https://oeis.org/A016628">A016628</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.ln5
ln5 = 1.6094379124341...

julia&gt; exp(PostNewtonian.ln5)
4.999999999999999

julia&gt; exp(big(PostNewtonian.ln5))
5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L116-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.ln¬≥‚ï±‚ÇÇ" href="#PostNewtonian.MathConstants.ln¬≥‚ï±‚ÇÇ"><code>PostNewtonian.MathConstants.ln¬≥‚ï±‚ÇÇ</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ln¬≥‚ï±‚ÇÇ
log¬≥‚ï±‚ÇÇ
log3halves</code></pre><p>The natural logarithm of 3//2.  This is OEIS sequence <a href="https://oeis.org/A016578">A016578</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.ln¬≥‚ï±‚ÇÇ
ln¬≥‚ï±‚ÇÇ = 0.4054651081081...

julia&gt; exp(PostNewtonian.ln¬≥‚ï±‚ÇÇ)
1.5

julia&gt; exp(big(PostNewtonian.ln¬≥‚ï±‚ÇÇ))
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L137-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.MathConstants.ln‚Åµ‚ï±‚ÇÇ" href="#PostNewtonian.MathConstants.ln‚Åµ‚ï±‚ÇÇ"><code>PostNewtonian.MathConstants.ln‚Åµ‚ï±‚ÇÇ</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ln‚Åµ‚ï±‚ÇÇ
log‚Åµ‚ï±‚ÇÇ
log5halves</code></pre><p>The natural logarithm of 5//2.  This is OEIS sequence <a href="https://oeis.org/A016579">A016579</a>.</p><pre><code class="language-julia-repl hljs">julia&gt; PostNewtonian.ln‚Åµ‚ï±‚ÇÇ
ln‚Åµ‚ï±‚ÇÇ = 0.9162907318741...

julia&gt; exp(PostNewtonian.ln‚Åµ‚ï±‚ÇÇ)
2.5

julia&gt; exp(big(PostNewtonian.ln‚Åµ‚ï±‚ÇÇ))
2.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/mathconstants.jl#L160-L178">source</a></section></article><h2 id="Truncated-series"><a class="docs-heading-anchor" href="#Truncated-series">Truncated series</a><a id="Truncated-series-1"></a><a class="docs-heading-anchor-permalink" href="#Truncated-series" title="Permalink"></a></h2><p>We also have some utilities for dealing with series ‚Äî or more precisely summations, since we only handle finitely many terms.  In particular, we need <em>truncated</em> multiplication (and some times division) of truncated series.  This multiplication is associative and there is a multiplicative identity element ‚Äî though not always a multiplicative inverse ‚Äî which means that this structure naturally forms a <a href="https://en.wikipedia.org/wiki/Monoid">monoid</a>.  (In fact, it also forms more general structures, like a commutative algebra; all we need is the monoidal structure.)</p><p>Here, we are assuming that there is a fixed order at which the series are truncated, and that truncated multiplication preserves that order. That is, if <span>$A$</span> and <span>$B$</span> are summations in terms up to <span>$v^N$</span> for some integer <span>$N$</span>, we want their product and ratio (if it exists) to also be a summation in terms up to <span>$v^N$</span>.</p><p>Note that we are not referring to these summations as &quot;polynomials&quot; in <span>$v$</span>, because the coefficients will sometimes involve <span>$\ln(v)$</span> ‚Äî which is not technically permitted for polynomials.  In particular, the presence of logarithms is irrelevant to our meaning of the &quot;order&quot; of the truncated series.  This is standard practice in post-Newtonian theory.<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><p>The following functions implement this behavior:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.truncated_series_inverse" href="#PostNewtonian.truncated_series_inverse"><code>PostNewtonian.truncated_series_inverse</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncated_series_inverse(a)
truncated_series_inverse!(b, a)</code></pre><p>Given the coefficients <code>a</code> of a series, find the coefficients <code>b</code> of the <em>multiplicative</em> inverse of that series, up to the order of the original series.  That is, if</p><p class="math-container">\[A \colonequals \sum_{i=0}^n a_{i-1} v^i,\]</p><p>then we return the coefficients <code>b</code> of the series</p><p class="math-container">\[B \colonequals \sum_{i=0}^n b_{i-1} v^i\]</p><p>such that</p><p class="math-container">\[A\, B = 1 + \mathcal{O}(v^{n+1}).\]</p><p>See <a href="#PostNewtonian.lagrange_inversion"><code>lagrange_inversion</code></a> for the <em>compositional</em> inverse (a.k.a. reversion), which returns the coefficients of <span>$f^{-1}$</span> such that <span>$f^{-1}(f(v)) = v + \mathcal{O}(v^{n+1})$</span>.</p><p>Note that this function returns the <em>coefficients</em> of the inverse, rather than its value. This is relevant for use in <a href="#PostNewtonian.truncated_series_product"><code>truncated_series_product</code></a> and <a href="#PostNewtonian.truncated_series_ratio"><code>truncated_series_ratio</code></a> ‚Äî the latter of which just combines the former with this function.</p><p>For example, suppose the input coefficients represent the series</p><p class="math-container">\[A \colonequals \sum_{i=0}^n a_{i-1} v^i.\]</p><p>(Remember that Julia&#39;s indexing is 1-based, so we subtract 1 to get the index of the coefficient of <span>$v^i$</span>.)  Then we return the coefficients <code>b</code> of the series</p><p class="math-container">\[B \colonequals \sum_{i=0}^n b_{i-1} v^i\]</p><p>such that</p><p class="math-container">\[A\, B = 1 + \mathcal{O}(v^{n+1}).\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires that <code>a[1]</code> be nonzero.  If you have a series that starts at a higher term ‚Äî say, <span>$v^n$</span> for <span>$n&gt;0$</span> ‚Äî you should factor out the <span>$v^n$</span>, and multiply the series resulting from this function by <span>$v^{-n}$</span>.</p></div></div><p><strong>Explanation</strong></p><p>The inverse coefficients can be computed fairly easily by induction.  Start by defining</p><p class="math-container">\[b_0 = 1/a_0.\]</p><p>Now, assuming that we&#39;ve computed all coefficients up to and including <span>$b_{i}$</span>, we can compute <span>$b_{i+1}$</span> from the condition that the term proportional to <span>$v^{i+1}$</span> in the product of the series and its inverse must be zero.  This gives</p><p class="math-container">\[b_{i+1} = -b_0\sum_{j=1}^{i} a_j b_{i-j}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_monoid.jl#L1-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.truncated_series_product" href="#PostNewtonian.truncated_series_product"><code>PostNewtonian.truncated_series_product</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncated_series_product(a, b, v)</code></pre><p>Evaluate the truncated product of the series <code>a</code> and <code>b</code>, which are expanded in powers of <code>v</code>.</p><p>Note that this function returns the <em>value</em> of the summation, rather than its coefficients.</p><p>Here we define the series in terms of the coefficients <code>a</code> and <code>b</code> as</p><p class="math-container">\[A \colonequals \sum_{i=0}^n a_{i-1} v^i
\qquad
B \colonequals \sum_{i=0}^n b_{i-1} v^i,\]</p><p>and return the <em>value</em> of the product <span>$A\, B$</span> truncated at <span>$v^n$</span>.</p><p>Internally, the sums are performed using <code>evalpoly</code>.</p><p>See also <a href="#PostNewtonian.truncated_series_ratio"><code>truncated_series_ratio</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_monoid.jl#L85-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.truncated_series_ratio" href="#PostNewtonian.truncated_series_ratio"><code>PostNewtonian.truncated_series_ratio</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncated_series_ratio(a, b, v)</code></pre><p>Evaluate the truncated ratio of the series <code>a</code> and <code>b</code>, which are expanded in powers of <code>v</code>.</p><p>Note that this function returns the <em>value</em> of the summation, rather than its coefficients.</p><p>Here we define the series in terms of the coefficients <code>a</code> and <code>b</code> as</p><p class="math-container">\[A \colonequals \sum_{i=0}^n a_{i-1} v^i
\qquad
B \colonequals \sum_{i=0}^n b_{i-1} v^i,\]</p><p>and return the <em>value</em> of the ratio <span>$A / B$</span> truncated at <span>$v^n$</span>.</p><p>This function simply combines <a href="#PostNewtonian.truncated_series_product"><code>truncated_series_product</code></a> and <a href="#PostNewtonian.truncated_series_inverse"><code>truncated_series_inverse</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_monoid.jl#L130-L147">source</a></section><section><div><pre><code class="language-julia hljs">truncated_series_ratio(a, b)</code></pre><p>Evaluate the truncated ratio of the series <code>a</code> and <code>b</code>, evaluated at expansion value 1. This is relevant when the expansion is not in the dynamic variable <code>v</code>, for example, but in powers of <span>$1/c$</span> as in post-Newtonian expansions.  (That is, when the <code>v</code> dependence is already include in the input coefficients.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_monoid.jl#L152-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.lagrange_inversion" href="#PostNewtonian.lagrange_inversion"><code>PostNewtonian.lagrange_inversion</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lagrange_inversion(a)</code></pre><p>Compute the <em>compositional</em> inverse (a.k.a. reversion) of the power series expansion</p><p class="math-container">\[f(x) = a[1]*x + a[2]*x^2 + \ldots + a[n-1]*x^{n-1}\]</p><p>about 0, where <code>a</code> is an NTuple.  Note, in particular, that there is no constant term.  The result is a similar NTuple <code>b</code> allowing us to write</p><p class="math-container">\[f^{-1}(y) = b[1]*y + b[2]*y^2 + \ldots + b[n-1]*y^{n-1},\]</p><p>such that <span>$f^{-1}(f(x)) = f(f^{-1}(y)) = x$</span> mod <span>$x^n$</span>.</p><p>See <a href="#PostNewtonian.truncated_series_inverse"><code>truncated_series_inverse</code></a> for the <em>multiplicative</em> inverse.</p><p>When the constant coefficient <span>$a_0$</span> is nonzero, the result must be expanded about a different point, which is done by evaluating the output as <span>$f^{-1}(y-a_0)$</span>.  Similarly, if the original expansion is about a point <span>$x_0 ‚â† 0$</span>, the result must be shifted by adding <span>$x_0$</span> to the output.</p><p><a href="https://doi.org/10.1090/S0025-5718-2014-02857-3">Johansson (2015)</a> summarizes this basic form of the algorithm nicely:</p><blockquote><p>Our setting is the ring of truncated power series <span>$R[[x]]/\langle x^n \rangle$</span> over a commutative coefficient ring <span>$R$</span> in which the integers <span>$1,...,n‚àí1$</span> are cancellable (i.e., nonzero and not zero divisors).  [...]  If <span>$f(x) = x/h(x)$</span> where <span>$h(0)$</span> is a unit, then the compositional inverse or reversion <span>$f^{-1}(x)$</span> satisfying <span>$f(f^{-1}(x)) = f^{-1}(f(x)) = x$</span> exists and its coefficients are given by</p><p class="math-container">\[[x^k] f^{-1}(x) = \frac{1}{k} [x^{k-1}] h(x)^k.\]</p></blockquote><p>Note that Johansson also presents a pair of asymptotically faster algorithms for computing the compositional inverse.  Because of the low orders of the power series expansions we typically work with, it is not clear if the improved scaling of those algorithms would actually be beneficial in practice, so we stick with the basic algorithm here ‚Äî though they would not be too difficult to implement if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_inversion.jl#L353-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.x‚ï±f_mod_x‚Åø‚Åª¬π" href="#PostNewtonian.x‚ï±f_mod_x‚Åø‚Åª¬π"><code>PostNewtonian.x‚ï±f_mod_x‚Åø‚Åª¬π</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x‚ï±f_mod_x‚Åø‚Åª¬π(a)</code></pre><p>Compute the truncated power series expansion of <span>$x/f$</span> mod <span>$x^{n-1}$</span>, where <span>$f$</span> is the power series expansion of a function <span>$f(x)$</span></p><p class="math-container">\[f(x) = a[1] x + a[2] x^2 + a[3] x^3 + \ldots + a[n-1] x^{n-1}.\]</p><p>Note, in particular that there is no constant term.  The result is a power series expansion</p><p class="math-container">\[h(x) = h[1] + h[2] x + h[3] x^2 + \ldots + h[n-1] x^{n-2},\]</p><p>which notably <em>does</em> have a constant term.</p><p>This function is essentially a helper function for the <a href="#PostNewtonian.lagrange_inversion"><code>lagrange_inversion</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_inversion.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.h‚Å±‚úñh_mod_x‚Åø‚Åª¬π" href="#PostNewtonian.h‚Å±‚úñh_mod_x‚Åø‚Åª¬π"><code>PostNewtonian.h‚Å±‚úñh_mod_x‚Åø‚Åª¬π</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">h‚Å±‚úñh_mod_x‚Åø‚Åª¬π(h, i)</code></pre><p>Compute the truncated power series expansion of <span>$h^i$</span> mod <span>$x^{n-1}$</span>, where <span>$h$</span> is the power series expansion of a function <span>$h(x)$</span></p><p class="math-container">\[h(x) = h[1] + h[2] x + h[3] x^2 + \ldots + h[n-1] x^{n-2}.\]</p><p>The result is a power series expansion</p><p class="math-container">\[h^i(x) = h^i[1] + h^i[2] x + h^i[3] x^2 + \ldots + h^i[n-1] x^{n-2}.\]</p><p>This function is essentially a helper function for the <a href="#PostNewtonian.lagrange_inversion"><code>lagrange_inversion</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/truncated_series_inversion.jl#L98-L114">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.apply_to_first_add!-Tuple{Any, Any}" href="#PostNewtonian.apply_to_first_add!-Tuple{Any, Any}"><code>PostNewtonian.apply_to_first_add!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_to_first_add!(expr, func)</code></pre><p>Apply <code>func</code> to the first sub-expression found in a &quot;prewalk&quot;-traversal of <code>expr</code> that satisfies <a href="#PostNewtonian.isadd-Tuple{Any}"><code>isadd</code></a>.  If <code>func</code> acts in place, so does this function.  In either case, the expression should be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.find_symbols_of_type-Tuple{Any, Any}" href="#PostNewtonian.find_symbols_of_type-Tuple{Any, Any}"><code>PostNewtonian.find_symbols_of_type</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_symbols_of_type(mod, T)</code></pre><p>Given a module <code>mod</code> (not just its name, but the actual imported module), find all objects inside that module that are instances of the given type <code>T</code>.  The returned quantity is a vector of <code>Symbol</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.flatten_binary!-Tuple{Any, Any}" href="#PostNewtonian.flatten_binary!-Tuple{Any, Any}"><code>PostNewtonian.flatten_binary!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten_binary!(expr, symbols)</code></pre><p>Flatten nested binary operations ‚Äî that is, apply associativity repeatedly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.isadd-Tuple{Any}" href="#PostNewtonian.isadd-Tuple{Any}"><code>PostNewtonian.isadd</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isadd(x)</code></pre><p>Return <code>true</code> if the <code>Expr</code> <code>x</code> is a call to <code>(+)</code> or <code>:+</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.iscall-Tuple{Any, Any}" href="#PostNewtonian.iscall-Tuple{Any, Any}"><code>PostNewtonian.iscall</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iscall(x, symbols)</code></pre><p>Return <code>true</code> if the <code>Expr</code> <code>x</code> is a call to any element of <code>symbols</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.ismul-Tuple{Any}" href="#PostNewtonian.ismul-Tuple{Any}"><code>PostNewtonian.ismul</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismul(x)</code></pre><p>Return <code>true</code> if the <code>Expr</code> <code>x</code> is a call to <code>(*)</code> or <code>:*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PostNewtonian.value-Tuple{Any}" href="#PostNewtonian.value-Tuple{Any}"><code>PostNewtonian.value</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(x)</code></pre><p>Return <code>x</code> or the value wrapped by the <code>Dual</code> number <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/moble/PostNewtonian.jl/blob/abf3db10e2b8df189498fbe39f54406f0367b9bf/src/utilities/misc.jl#L1-L5">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Different texts in post-Newtonian theory treat these logarithmic   terms with varying levels of rigor.  The preferred method is   <a href="https://en.wikipedia.org/wiki/Hadamard_regularization">Hadamard   regularization</a>   (often referred to in the literature as the <em>partie finie</em>).  A   good summary is found in Section 6 of <a href="https://link.springer.com/article/10.12942/lrr-2014-2">Blanchet&#39;s Living   Review</a>.   Another potential approach could be taken following <a href="https://doi.org/10.1016/0001-8708(89)90079-0">this   paper</a>.  But for   our purposes, it will suffice to take the simplistic approach of   treating logarithmic terms as if they were any other constant.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../waveforms/">¬´ Waveforms</a><a class="docs-footer-nextpage" href="../../adding_terms/">Adding terms ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 13 August 2024 17:12">Tuesday 13 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
